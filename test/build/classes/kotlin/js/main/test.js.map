{"version":3,"file":"test.js","sources":["collections/Collections.kt","../../../../../src/commonMain/kotlin/com/lightningkite/krosslin/test/models/User.kt","collections/Maps.kt","../../../../../src/commonMain/kotlin/com/lightningkite/krosslin/test/MainVG.kt","../../../../../src/commonMain/kotlin/com/lightningkite/krosslin/test/models/Post.kt","../../../../../src/commonMain/kotlin/com/lightningkite/krosslin/test/SelectorVG.kt","../../../../../src/commonMain/kotlin/com/lightningkite/krosslin/test/settings.kt","../../../../../src/commonMain/kotlin/com/lightningkite/krosslin/test/TestFormsVG.kt","../../../../../src/commonMain/kotlin/com/lightningkite/mirror/form/FormState.kt","collections/MutableCollections.kt","util/Standard.kt","../../../../../src/commonMain/kotlin/com/lightningkite/krosslin/test/TestViewsVG.kt","../../../../../src/commonMain/kotlin/mirror/BackedByString.mirror.kt","../../../../../src/commonMain/kotlin/mirror/Database.Request.mirror.kt","../../../../../src/commonMain/kotlin/mirror/Email.mirror.kt","../../../../../src/commonMain/kotlin/mirror/FormEditOnly.mirror.kt","../../../../../src/commonMain/kotlin/mirror/FormHidden.mirror.kt","../../../../../src/commonMain/kotlin/mirror/FormNeedsNoContext.mirror.kt","../../../../../src/commonMain/kotlin/mirror/Post.Access.mirror.kt","../../../../../src/commonMain/kotlin/mirror/Post.mirror.kt","../../../../../src/commonMain/kotlin/mirror/registerKrosslinTest.kt","../../../../../src/commonMain/kotlin/mirror/User.Access.mirror.kt","../../../../../src/commonMain/kotlin/mirror/User.GetToken.mirror.kt","../../../../../src/commonMain/kotlin/mirror/User.mirror.kt","../../../../../src/commonMain/kotlin/mirror/User.ResetPassword.mirror.kt","../../../../../src/commonMain/kotlin/mirror/User.Role.mirror.kt","../../../../../src/commonMain/kotlin/mirror/User.Token.mirror.kt","../../../../../src/jsMain/kotlin/com/lightningkite/krosslin/test/Main.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package com.lightningkite.krosslin.test.models\r\n\r\nimport com.lightningkite.kommon.string.Email\r\nimport com.lightningkite.lokalize.time.TimeStamp\r\nimport com.lightningkite.mirror.archive.database.Database\r\nimport com.lightningkite.mirror.archive.model.HasUuid\r\nimport com.lightningkite.mirror.archive.model.Uuid\r\nimport com.lightningkite.mirror.form.info.FormEditOnly\r\nimport com.lightningkite.mirror.form.info.FormHidden\r\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\r\nimport com.lightningkite.mirror.info.ThrowsTypes\r\nimport com.lightningkite.mirror.request.Request\r\n\r\n\r\ndata class User(\r\n        @FormHidden override var id: Uuid = Uuid.randomUUID4(),\r\n        @FormNeedsNoContext var email: Email = Email(\"\"),\r\n        @FormEditOnly var password: String = \"\",\r\n        var role: User.Role = User.Role.Citizen,\r\n        @FormEditOnly var rejectTokensBefore: TimeStamp = TimeStamp(0)\r\n) : HasUuid {\r\n\r\n\r\n    //region Helper Data\r\n\r\n    data class Token(val string: String)\r\n    \r\n    enum class Role {\r\n        Citizen,\r\n        Admin\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region Server Functions\r\n\r\n    data class Access(val token: User.Token? = null): Database.Request<User>\r\n\r\n    @ThrowsTypes(arrayOf(\"NoSuchElementException\", \"ForbiddenException\"))\r\n    data class GetToken(val email: Email, val password: String) : Request<User.Token>\r\n\r\n    data class ResetPassword(val email: Email) : Request<Unit>\r\n\r\n    //endregion\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","package com.lightningkite.krosslin.test\n\nimport com.lightningkite.kommon.collection.*\nimport com.lightningkite.reacktive.list.WrapperObservableList\n\nclass MainVG<VIEW>() : MyViewGenerator<VIEW> {\n    override val title: String = \"KotlinX UI Test\"\n\n    val stack = WrapperObservableList<MyViewGenerator<VIEW>>()\n\n    init {\n        //Startup\n        registerEverything()\n        stack.push(SelectorVG(stack))\n    }\n\n    override fun generate(dependency: MyViewFactory<VIEW>): VIEW = with(dependency) {\n        window(\n                dependency = dependency,\n                stack = stack,\n                tabs = listOf()\n        )\n    }\n}\n","package com.lightningkite.krosslin.test.models\r\n\r\nimport com.lightningkite.lokalize.time.TimeStamp\r\nimport com.lightningkite.lokalize.time.now\r\nimport com.lightningkite.mirror.archive.database.Database\r\nimport com.lightningkite.mirror.archive.model.HasUuid\r\nimport com.lightningkite.mirror.archive.model.Reference\r\nimport com.lightningkite.mirror.archive.model.Uuid\r\nimport com.lightningkite.mirror.form.info.FormHidden\r\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\r\n\r\ndata class Post(\r\n        @FormHidden override val id: Uuid = Uuid.randomUUID4(),\r\n        @FormNeedsNoContext var title: String = \"\",\r\n        var author: Reference<User>,\r\n        var posted: TimeStamp = TimeStamp.now(),\r\n        var body: String = \"\"\r\n) : HasUuid {\r\n\r\n\r\n    //region Server Functions\r\n\r\n    data class Access(val token: User.Token? = null): Database.Request<Post>\r\n\r\n    //endregion\r\n}\r\n","package com.lightningkite.krosslin.test\n\nimport com.lightningkite.kommon.collection.*\nimport com.lightningkite.kommon.string.Email\nimport com.lightningkite.reacktive.list.observableListOf\nimport com.lightningkite.reacktive.list.MutableObservableList\nimport com.lightningkite.koolui.concepts.Importance\nimport com.lightningkite.koolui.views.ViewFactory\nimport com.lightningkite.koolui.views.ViewGenerator\nimport com.lightningkite.krosslin.test.models.Post\nimport com.lightningkite.krosslin.test.models.PostMirror\nimport com.lightningkite.krosslin.test.models.User\nimport com.lightningkite.krosslin.test.models.UserMirror\nimport com.lightningkite.mirror.archive.database.RamDatabase\nimport com.lightningkite.mirror.archive.model.Reference\nimport com.lightningkite.mirror.form.FormRequest\nimport com.lightningkite.mirror.form.FormState\nimport com.lightningkite.mirror.form.GeneralRequest\nimport com.lightningkite.mirror.form.other.DatabaseVG\nimport com.lightningkite.mirror.info.ListMirror\nimport com.lightningkite.mirror.info.StringMirror\nimport com.lightningkite.reacktive.property.StandardObservableProperty\nimport com.lightningkite.reacktive.property.transform\n\nclass SelectorVG<VIEW>(\n        val stack: MutableObservableList<MyViewGenerator<VIEW>>\n) : MyViewGenerator<VIEW> {\n    override val title: String = \"KotlinX UI Test\"\n\n    val userAdmin = User(email = Email(\"joseph@lightningkite.com\"), password = \"test\", role = User.Role.Admin)\n    val userCitizen = User(email = Email(\"citizen@gmail.com\"), password = \"test\", role = User.Role.Citizen)\n    val userDb = RamDatabase<User>(UserMirror, backingData = mutableListOf(userAdmin, userCitizen))\n    val postDb = RamDatabase<Post>(PostMirror, backingData = mutableListOf(\n            Post(title = \"Test Post\", author = Reference(userAdmin.id), body = \"Hello, this is my test post.  It could be much much longer, but it's not.  I'm bored now.\")\n    ))\n    val general = GeneralRequest(\n            databases = mapOf(\n                    UserMirror to userDb,\n                    PostMirror to postDb\n            )\n    )\n\n    val tests = observableListOf(\n            \"Form\" to { TestFormsVG(stack) },\n            \"View\" to { TestViewsVG(stack) },\n            \"ListTest\" to {\n                FormRequest<List<String>>(\n                        general = general.copy(stack = stack as MutableObservableList<ViewGenerator<ViewFactory<Any?>, Any?>>),\n                        type = ListMirror(StringMirror),\n                        observable = StandardObservableProperty(FormState.success(listOf(\"First\", \"Second\", \"Third\")))\n                ).getVG<MyViewFactory<VIEW>, VIEW>()\n            },\n            \"PostDB\" to { DatabaseVG(stack = stack, type = PostMirror, database = postDb, generalRequest = general.copy(stack = stack)) },\n            \"UserDB\" to { DatabaseVG(stack = stack, type = UserMirror, database = userDb, generalRequest = general.copy(stack = stack)) }\n    )\n\n    override fun generate(dependency: MyViewFactory<VIEW>): VIEW = with(dependency) {\n        list(data = tests, makeView = { itemObs ->\n            button(\n                    label = itemObs.transform { item -> item.first },\n                    importance = Importance.Low,\n                    onClick = {\n                        stack.push(itemObs.value.second.invoke())\n                    }\n            )\n        }).margin(8f)\n    }\n}\n","package com.lightningkite.krosslin.test\n\nimport com.lightningkite.kommon.atomic.AtomicReference\nimport com.lightningkite.koolui.views.ViewFactory\nimport com.lightningkite.koolui.views.ViewGenerator\nimport com.lightningkite.krosslin.test.models.registerKrosslinTest\nimport com.lightningkite.mirror.archive.model.registerArchive\nimport com.lightningkite.mirror.ktor.HttpClientRequestHandler\nimport com.lightningkite.mirror.request.Request\nimport com.lightningkite.mirror.request.registerKotlin\nimport com.lightningkite.mirror.request.registerRequests\nimport io.ktor.client.HttpClient\nimport kotlinx.serialization.json.Json\n\ninterface MyViewFactory<VIEW> : ViewFactory<VIEW> {}\ntypealias MyViewGenerator<VIEW> = ViewGenerator<MyViewFactory<VIEW>, VIEW>\n\nfun registerEverything(){\n    registerKrosslinTest()\n    registerArchive()\n    registerKotlin()\n    registerRequests()\n}\n\nval rpcRequestSerializer = Json.nonstrict\nval atomicRequestHandler = AtomicReference<Request.Handler>(HttpClientRequestHandler(\n        client = HttpClient(),\n        url = \"http://localhost:8080/rpc\",\n        serializer = rpcRequestSerializer\n))\nsuspend fun <T> Request<T>.invoke() = atomicRequestHandler.value.invoke(this)","package com.lightningkite.krosslin.test\n\nimport com.lightningkite.kommon.collection.*\nimport com.lightningkite.koolui.builders.launchInfoDialog\nimport com.lightningkite.reacktive.list.MutableObservableList\nimport com.lightningkite.koolui.views.ViewFactory\nimport com.lightningkite.koolui.views.ViewGenerator\nimport com.lightningkite.mirror.form.FormRequest\nimport com.lightningkite.mirror.form.FormState\nimport com.lightningkite.mirror.form.GeneralRequest\nimport com.lightningkite.mirror.form.ViewSize\nimport com.lightningkite.mirror.form.form.FormViewGenerator\nimport com.lightningkite.mirror.info.MirrorRegistry\nimport com.lightningkite.mirror.info.MirrorType\nimport com.lightningkite.reacktive.list.asObservableList\nimport com.lightningkite.reacktive.property.StandardObservableProperty\nimport com.lightningkite.reacktive.property.transform\n\nclass TestFormsVG<VIEW>(\n        val stack: MutableObservableList<MyViewGenerator<VIEW>>\n) : MyViewGenerator<VIEW> {\n    override val title: String = \"KotlinX UI Test\"\n\n    val options = MirrorRegistry.index.value.byClass.values.asSequence().flatMap { sequenceOf(it, it.nullable) }.toList().asObservableList()\n\n    override fun generate(dependency: MyViewFactory<VIEW>): VIEW = with(dependency) {\n        list(options){ obs ->\n            button(label = obs.transform { it.base.localName + if(it.isNullable) \" (Optional)\" else \"\" }){\n                @Suppress(\"UNCHECKED_CAST\") val request = FormRequest<Any?>(\n                        general = GeneralRequest(stack = stack),\n                        type = obs.value as MirrorType<Any?>,\n                        observable = StandardObservableProperty<FormState<Any?>>(FormState.empty()).also { it += { println(\"New value is: ${it}\")} }\n                )\n                stack.pushFrom(this@TestFormsVG, FormViewGenerator(request.getVG(), request.observable){\n                    launchInfoDialog(\"Result\", it.toString())\n                })\n            }.altClickable {\n                @Suppress(\"UNCHECKED_CAST\") val request = FormRequest<Any?>(\n                        general = GeneralRequest(stack = stack),\n                        type = obs.value as MirrorType<Any?>,\n                        observable = StandardObservableProperty<FormState<Any?>>(FormState.empty()).also { it += { println(\"New value is: ${it}\")} },\n                        scale = ViewSize.Summary\n                )\n                stack.pushFrom(this@TestFormsVG, FormViewGenerator(request.getVG(), request.observable){\n                    launchInfoDialog(\"Result\", it.toString())\n                })\n            }\n        }\n    }\n}\n","package com.lightningkite.mirror.form\r\n\r\nsealed class FormState<out T> {\r\n    abstract val valueOrNull: T?\r\n    open val isEmpty: Boolean get() = false\r\n    abstract fun <A> breakDown(get: (T) -> A): FormState<A>?\r\n    abstract fun <A> map(get: (T) -> A): FormState<A>\r\n    abstract fun <A> asType(): FormState<A>\r\n\r\n    data class Success<T>(val value: T) : FormState<T>() {\r\n        override val valueOrNull: T? get() = value\r\n        override fun <A> breakDown(get: (T) -> A): FormState<A>? = success(value.let(get))\r\n        override fun <A> map(get: (T) -> A): FormState<A> = success(value.let(get))\r\n        override fun <A> asType(): FormState<A> = empty()\r\n    }\r\n\r\n    data class Invalid<T>(val cause: Any? = null) : FormState<T>() {\r\n        override val valueOrNull: T? get() = null\r\n        override fun <A> breakDown(get: (T) -> A): FormState<A>? = null\r\n        override fun <A> map(get: (T) -> A): FormState<A> = Invalid(cause)\r\n        override fun <A> asType(): FormState<A> = Invalid(cause)\r\n    }\r\n\r\n    object Empty : FormState<Any?>() {\r\n        override val valueOrNull: Any? get() = null\r\n        override val isEmpty: Boolean\r\n            get() = true\r\n\r\n        override fun <A> breakDown(get: (Any?) -> A): FormState<A>? = null\r\n        override fun <A> map(get: (Any?) -> A): FormState<A> = empty()\r\n        override fun <A> asType(): FormState<A> = empty()\r\n    }\r\n\r\n    companion object {\r\n        @Suppress(\"UNCHECKED_CAST\", \"NOTHING_TO_INLINE\")\r\n        inline fun <T> empty() = Empty as FormState<T>\r\n\r\n        fun <T> success(value: T) = Success(value)\r\n        fun <T> invalid(cause: Any?) = Invalid<T>(cause)\r\n\r\n        fun <T> combineFailures(parts: Sequence<Pair<String, FormState<*>>>): FormState<T>? {\r\n            for ((key, part) in parts) {\r\n                if (part.isEmpty) return empty()\r\n                if (part is Invalid) return invalid(\"$key: \" + part.cause)\r\n            }\r\n            return null\r\n        }\r\n    }\r\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n/**\n * Randomly shuffles elements in this mutable list using the specified [random] instance as the source of randomness.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package com.lightningkite.krosslin.test\n\nimport com.lightningkite.reacktive.list.MutableObservableList\nimport com.lightningkite.krosslin.test.models.Post\nimport com.lightningkite.mirror.archive.model.Reference\nimport com.lightningkite.mirror.archive.model.Uuid\nimport com.lightningkite.mirror.form.DisplayRequest\nimport com.lightningkite.mirror.form.GeneralRequest\nimport com.lightningkite.mirror.info.ListMirror\nimport com.lightningkite.reacktive.property.ConstantObservableProperty\n\nclass TestViewsVG<VIEW>(\n        val stack: MutableObservableList<MyViewGenerator<VIEW>>\n) : MyViewGenerator<VIEW> {\n    override val title: String = \"KotlinX UI Test\"\n\n    val things = listOf(\n            32,\n            \"Hello world!\",\n            Post(author = Reference(Uuid.randomUUID4()), title = \"Hello!\", body = \"This is the body of the post\"),\n            false\n    )\n\n    override fun generate(dependency: MyViewFactory<VIEW>): VIEW = with(dependency) {\n        DisplayRequest<List<Any?>>(\n                general = GeneralRequest(),\n                type = ListMirror.minimal,\n                observable = ConstantObservableProperty(things)\n        ).getVG<MyViewFactory<VIEW>, VIEW>().generate(dependency)\n    }\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.kommon.string\n\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\n\nobject BackedByStringMirror : PolymorphicMirror<BackedByString>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<BackedByString> get() = BackedByString::class as KClass<BackedByString>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Interface, Modifier.Abstract)\n    override val implements: Array<MirrorClass<*>> get() = arrayOf(AnyMirror)\n    override val packageName: String get() = \"com.lightningkite.kommon.string\"\n    override val localName: String get() = \"BackedByString\"\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.mirror.archive.database\n\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\n\ndata class DatabaseRequestMirror<T: kotlin.Any>(\n    val TMirror: MirrorType<T>\n) : PolymorphicMirror<Database.Request<T>>() {\n    \n    override val mirrorClassCompanion: MirrorClassCompanion? get() = Companion\n    companion object : MirrorClassCompanion {\n        val TMirrorMinimal get() = AnyMirror\n        \n        override val minimal = DatabaseRequestMirror(TypeArgumentMirrorType(\"T\", Variance.INVARIANT, TMirrorMinimal))\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun make(typeArguments: List<MirrorType<*>>): MirrorClass<*> = DatabaseRequestMirror(typeArguments[0] as MirrorType<kotlin.Any>)\n        \n        @Suppress(\"UNCHECKED_CAST\")\n        fun make(\n            TMirror: MirrorType<*>? = null\n        ) = DatabaseRequestMirror<kotlin.Any>(\n            TMirror = (TMirror ?: TMirrorMinimal) as MirrorType<kotlin.Any>\n        )\n    }\n    \n    override val typeParameters: Array<MirrorType<*>> get() = arrayOf(TMirror)\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<Database.Request<T>> get() = Database.Request::class as KClass<Database.Request<T>>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Interface, Modifier.Abstract)\n    override val implements: Array<MirrorClass<*>> get() = arrayOf(AnyMirror)\n    override val packageName: String get() = \"com.lightningkite.mirror.archive.database\"\n    override val localName: String get() = \"Database.Request\"\n    override val owningClass: KClass<*>? get() = Database::class\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.kommon.string\n\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\nimport com.lightningkite.kommon.string.BackedByStringMirror\n\nobject EmailMirror : MirrorClass<Email>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<Email> get() = Email::class as KClass<Email>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Inline)\n    override val packageName: String get() = \"com.lightningkite.kommon.string\"\n    override val localName: String get() = \"Email\"\n    override val implements: Array<MirrorClass<*>> get() = arrayOf(com.lightningkite.kommon.string.BackedByStringMirror)\n    \n    val fieldString: Field<Email,kotlin.String> = Field(\n        owner = this,\n        index = 0,\n        name = \"string\",\n        type = StringMirror,\n        optional = false,\n        get = { it.string },\n        annotations = listOf<Annotation>()\n    )\n    \n    override val fields: Array<Field<Email, *>> = arrayOf(fieldString)\n    \n    override fun deserialize(decoder: Decoder): Email {\n        var stringSet = false\n        var fieldString: kotlin.String? = null\n        val decoderStructure = decoder.beginStructure(this)\n        loop@ while (true) {\n            when (decoderStructure.decodeElementIndex(this)) {\n                CompositeDecoder.READ_ALL -> {\n                    fieldString = decoderStructure.decodeStringElement(this, 0)\n                    stringSet = true\n                    break@loop\n                }\n                CompositeDecoder.READ_DONE -> break@loop\n                0 -> {\n                    fieldString = decoderStructure.decodeStringElement(this, 0)\n                    stringSet = true\n                }\n                else -> {}\n            }\n        }\n        decoderStructure.endStructure(this)\n        if(!stringSet) {\n            throw MissingFieldException(\"string\")\n        }\n        return Email(\n            string = fieldString as kotlin.String\n        )\n    }\n    \n    override fun serialize(encoder: Encoder, obj: Email) {\n        val encoderStructure = encoder.beginStructure(this)\n        encoderStructure.encodeStringElement(this, 0, obj.string)\n        encoderStructure.endStructure(this)\n    }\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.mirror.form.info\n\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\n\nclass FormEditOnlyMirror(\n): MirrorAnnotation {\n    override val annotationType: KClass<out Annotation> get() = FormEditOnly::class\n    override fun asMap(): Map<String, Any?> = mapOf(\n    )\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.mirror.form.info\n\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\n\nclass FormHiddenMirror(\n): MirrorAnnotation {\n    override val annotationType: KClass<out Annotation> get() = FormHidden::class\n    override fun asMap(): Map<String, Any?> = mapOf(\n    )\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.mirror.form.info\n\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\n\nclass FormNeedsNoContextMirror(\n): MirrorAnnotation {\n    override val annotationType: KClass<out Annotation> get() = FormNeedsNoContext::class\n    override fun asMap(): Map<String, Any?> = mapOf(\n    )\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.krosslin.test.models\n\nimport com.lightningkite.lokalize.time.TimeStamp\nimport com.lightningkite.lokalize.time.now\nimport com.lightningkite.mirror.archive.database.Database\nimport com.lightningkite.mirror.archive.model.HasUuid\nimport com.lightningkite.mirror.archive.model.Reference\nimport com.lightningkite.mirror.archive.model.Uuid\nimport com.lightningkite.mirror.form.info.FormHidden\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\nimport com.lightningkite.mirror.archive.database.DatabaseRequestMirror\n\nobject PostAccessMirror : MirrorClass<Post.Access>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<Post.Access> get() = Post.Access::class as KClass<Post.Access>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Data)\n    override val packageName: String get() = \"com.lightningkite.krosslin.test.models\"\n    override val localName: String get() = \"Post.Access\"\n    override val implements: Array<MirrorClass<*>> get() = arrayOf(DatabaseRequestMirror(PostMirror))\n    override val owningClass: KClass<*>? get() = Post::class\n    \n    val fieldToken: Field<Post.Access,User.Token?> = Field(\n        owner = this,\n        index = 0,\n        name = \"token\",\n        type = UserTokenMirror.nullable,\n        optional = true,\n        get = { it.token },\n        annotations = listOf<Annotation>()\n    )\n    \n    override val fields: Array<Field<Post.Access, *>> = arrayOf(fieldToken)\n    \n    override fun deserialize(decoder: Decoder): Post.Access {\n        var tokenSet = false\n        var fieldToken: User.Token? = null\n        val decoderStructure = decoder.beginStructure(this)\n        loop@ while (true) {\n            when (decoderStructure.decodeElementIndex(this)) {\n                CompositeDecoder.READ_ALL -> {\n                    fieldToken = decoderStructure.decodeSerializableElement(this, 0, UserTokenMirror.nullable)\n                    tokenSet = true\n                    break@loop\n                }\n                CompositeDecoder.READ_DONE -> break@loop\n                0 -> {\n                    fieldToken = decoderStructure.decodeSerializableElement(this, 0, UserTokenMirror.nullable)\n                    tokenSet = true\n                }\n                else -> {}\n            }\n        }\n        decoderStructure.endStructure(this)\n        if(!tokenSet) {\n            fieldToken = null\n        }\n        return Post.Access(\n            token = fieldToken as User.Token?\n        )\n    }\n    \n    override fun serialize(encoder: Encoder, obj: Post.Access) {\n        val encoderStructure = encoder.beginStructure(this)\n        encoderStructure.encodeSerializableElement(this, 0, UserTokenMirror.nullable, obj.token)\n        encoderStructure.endStructure(this)\n    }\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.krosslin.test.models\n\nimport com.lightningkite.lokalize.time.TimeStamp\nimport com.lightningkite.lokalize.time.now\nimport com.lightningkite.mirror.archive.database.Database\nimport com.lightningkite.mirror.archive.model.HasUuid\nimport com.lightningkite.mirror.archive.model.Reference\nimport com.lightningkite.mirror.archive.model.Uuid\nimport com.lightningkite.mirror.form.info.FormHidden\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\nimport com.lightningkite.mirror.form.info.FormNeedsNoContextMirror\nimport com.lightningkite.mirror.archive.model.UuidMirror\nimport com.lightningkite.mirror.archive.model.HasUuidMirror\nimport com.lightningkite.mirror.archive.model.ReferenceMirror\nimport com.lightningkite.lokalize.time.TimeStampMirror\nimport com.lightningkite.mirror.form.info.FormHiddenMirror\n\nobject PostMirror : MirrorClass<Post>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<Post> get() = Post::class as KClass<Post>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Data)\n    override val packageName: String get() = \"com.lightningkite.krosslin.test.models\"\n    override val localName: String get() = \"Post\"\n    override val implements: Array<MirrorClass<*>> get() = arrayOf(HasUuidMirror)\n    \n    val fieldId: Field<Post,Uuid> = Field(\n        owner = this,\n        index = 0,\n        name = \"id\",\n        type = UuidMirror,\n        optional = true,\n        get = { it.id },\n        annotations = listOf<Annotation>(FormHiddenMirror())\n    )\n    \n    val fieldTitle: Field<Post,String> = Field(\n        owner = this,\n        index = 1,\n        name = \"title\",\n        type = StringMirror,\n        optional = true,\n        get = { it.title },\n        set = { it, value -> it.title = value },\n        annotations = listOf<Annotation>(FormNeedsNoContextMirror())\n    )\n    \n    val fieldAuthor: Field<Post,Reference<User>> = Field(\n        owner = this,\n        index = 2,\n        name = \"author\",\n        type = ReferenceMirror(UserMirror),\n        optional = false,\n        get = { it.author },\n        set = { it, value -> it.author = value },\n        annotations = listOf<Annotation>()\n    )\n    \n    val fieldPosted: Field<Post,TimeStamp> = Field(\n        owner = this,\n        index = 3,\n        name = \"posted\",\n        type = TimeStampMirror,\n        optional = true,\n        get = { it.posted },\n        set = { it, value -> it.posted = value },\n        annotations = listOf<Annotation>()\n    )\n    \n    val fieldBody: Field<Post,String> = Field(\n        owner = this,\n        index = 4,\n        name = \"body\",\n        type = StringMirror,\n        optional = true,\n        get = { it.body },\n        set = { it, value -> it.body = value },\n        annotations = listOf<Annotation>()\n    )\n    \n    override val fields: Array<Field<Post, *>> = arrayOf(fieldId, fieldTitle, fieldAuthor, fieldPosted, fieldBody)\n    \n    override fun deserialize(decoder: Decoder): Post {\n        var idSet = false\n        var fieldId: Uuid? = null\n        var titleSet = false\n        var fieldTitle: String? = null\n        var authorSet = false\n        var fieldAuthor: Reference<User>? = null\n        var postedSet = false\n        var fieldPosted: TimeStamp? = null\n        var bodySet = false\n        var fieldBody: String? = null\n        val decoderStructure = decoder.beginStructure(this)\n        loop@ while (true) {\n            when (decoderStructure.decodeElementIndex(this)) {\n                CompositeDecoder.READ_ALL -> {\n                    fieldId = decoderStructure.decodeSerializableElement(this, 0, UuidMirror)\n                    idSet = true\n                    fieldTitle = decoderStructure.decodeStringElement(this, 1)\n                    titleSet = true\n                    fieldAuthor = decoderStructure.decodeSerializableElement(this, 2, ReferenceMirror(UserMirror))\n                    authorSet = true\n                    fieldPosted = decoderStructure.decodeSerializableElement(this, 3, TimeStampMirror)\n                    postedSet = true\n                    fieldBody = decoderStructure.decodeStringElement(this, 4)\n                    bodySet = true\n                    break@loop\n                }\n                CompositeDecoder.READ_DONE -> break@loop\n                0 -> {\n                    fieldId = decoderStructure.decodeSerializableElement(this, 0, UuidMirror)\n                    idSet = true\n                }\n                1 -> {\n                    fieldTitle = decoderStructure.decodeStringElement(this, 1)\n                    titleSet = true\n                }\n                2 -> {\n                    fieldAuthor = decoderStructure.decodeSerializableElement(this, 2, ReferenceMirror(UserMirror))\n                    authorSet = true\n                }\n                3 -> {\n                    fieldPosted = decoderStructure.decodeSerializableElement(this, 3, TimeStampMirror)\n                    postedSet = true\n                }\n                4 -> {\n                    fieldBody = decoderStructure.decodeStringElement(this, 4)\n                    bodySet = true\n                }\n                else -> {}\n            }\n        }\n        decoderStructure.endStructure(this)\n        if(!idSet) {\n            fieldId = Uuid.randomUUID4()\n        }\n        if(!titleSet) {\n            fieldTitle = \"\"\n        }\n        if(!authorSet) {\n            throw MissingFieldException(\"author\")\n        }\n        if(!postedSet) {\n            fieldPosted = TimeStamp.now()\n        }\n        if(!bodySet) {\n            fieldBody = \"\"\n        }\n        return Post(\n            id = fieldId as Uuid,\n            title = fieldTitle as String,\n            author = fieldAuthor as Reference<User>,\n            posted = fieldPosted as TimeStamp,\n            body = fieldBody as String\n        )\n    }\n    \n    override fun serialize(encoder: Encoder, obj: Post) {\n        val encoderStructure = encoder.beginStructure(this)\n        encoderStructure.encodeSerializableElement(this, 0, UuidMirror, obj.id)\n        encoderStructure.encodeStringElement(this, 1, obj.title)\n        encoderStructure.encodeSerializableElement(this, 2, ReferenceMirror(UserMirror), obj.author)\n        encoderStructure.encodeSerializableElement(this, 3, TimeStampMirror, obj.posted)\n        encoderStructure.encodeStringElement(this, 4, obj.body)\n        encoderStructure.endStructure(this)\n    }\n}\n","package com.lightningkite.krosslin.test.models\n\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\n\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\n\nfun registerKrosslinTest() = MirrorRegistry.register(\n    com.lightningkite.krosslin.test.models.UserResetPasswordMirror,\n    com.lightningkite.kommon.string.EmailMirror,\n    com.lightningkite.kommon.string.BackedByStringMirror,\n    com.lightningkite.krosslin.test.models.UserGetTokenMirror,\n    com.lightningkite.krosslin.test.models.UserAccessMirror,\n    com.lightningkite.mirror.archive.database.DatabaseRequestMirror.minimal,\n    com.lightningkite.krosslin.test.models.UserRoleMirror,\n    com.lightningkite.krosslin.test.models.UserTokenMirror,\n    com.lightningkite.krosslin.test.models.UserMirror,\n    com.lightningkite.krosslin.test.models.PostAccessMirror,\n    com.lightningkite.krosslin.test.models.PostMirror\n)","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.krosslin.test.models\n\nimport com.lightningkite.kommon.string.Email\nimport com.lightningkite.lokalize.time.TimeStamp\nimport com.lightningkite.mirror.archive.database.Database\nimport com.lightningkite.mirror.archive.model.HasUuid\nimport com.lightningkite.mirror.archive.model.Uuid\nimport com.lightningkite.mirror.form.info.FormEditOnly\nimport com.lightningkite.mirror.form.info.FormHidden\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\nimport com.lightningkite.mirror.info.ThrowsTypes\nimport com.lightningkite.mirror.request.Request\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\nimport com.lightningkite.mirror.archive.database.DatabaseRequestMirror\n\nobject UserAccessMirror : MirrorClass<User.Access>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<User.Access> get() = User.Access::class as KClass<User.Access>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Data)\n    override val packageName: String get() = \"com.lightningkite.krosslin.test.models\"\n    override val localName: String get() = \"User.Access\"\n    override val implements: Array<MirrorClass<*>> get() = arrayOf(DatabaseRequestMirror(UserMirror))\n    override val owningClass: KClass<*>? get() = User::class\n    \n    val fieldToken: Field<User.Access,User.Token?> = Field(\n        owner = this,\n        index = 0,\n        name = \"token\",\n        type = UserTokenMirror.nullable,\n        optional = true,\n        get = { it.token },\n        annotations = listOf<Annotation>()\n    )\n    \n    override val fields: Array<Field<User.Access, *>> = arrayOf(fieldToken)\n    \n    override fun deserialize(decoder: Decoder): User.Access {\n        var tokenSet = false\n        var fieldToken: User.Token? = null\n        val decoderStructure = decoder.beginStructure(this)\n        loop@ while (true) {\n            when (decoderStructure.decodeElementIndex(this)) {\n                CompositeDecoder.READ_ALL -> {\n                    fieldToken = decoderStructure.decodeSerializableElement(this, 0, UserTokenMirror.nullable)\n                    tokenSet = true\n                    break@loop\n                }\n                CompositeDecoder.READ_DONE -> break@loop\n                0 -> {\n                    fieldToken = decoderStructure.decodeSerializableElement(this, 0, UserTokenMirror.nullable)\n                    tokenSet = true\n                }\n                else -> {}\n            }\n        }\n        decoderStructure.endStructure(this)\n        if(!tokenSet) {\n            fieldToken = null\n        }\n        return User.Access(\n            token = fieldToken as User.Token?\n        )\n    }\n    \n    override fun serialize(encoder: Encoder, obj: User.Access) {\n        val encoderStructure = encoder.beginStructure(this)\n        encoderStructure.encodeSerializableElement(this, 0, UserTokenMirror.nullable, obj.token)\n        encoderStructure.endStructure(this)\n    }\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.krosslin.test.models\n\nimport com.lightningkite.kommon.string.Email\nimport com.lightningkite.lokalize.time.TimeStamp\nimport com.lightningkite.mirror.archive.database.Database\nimport com.lightningkite.mirror.archive.model.HasUuid\nimport com.lightningkite.mirror.archive.model.Uuid\nimport com.lightningkite.mirror.form.info.FormEditOnly\nimport com.lightningkite.mirror.form.info.FormHidden\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\nimport com.lightningkite.mirror.info.ThrowsTypes\nimport com.lightningkite.mirror.request.Request\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\nimport com.lightningkite.kommon.string.EmailMirror\nimport com.lightningkite.mirror.request.RequestMirror\nimport com.lightningkite.mirror.info.ThrowsTypesMirror\n\nobject UserGetTokenMirror : MirrorClass<User.GetToken>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<User.GetToken> get() = User.GetToken::class as KClass<User.GetToken>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Data)\n    override val packageName: String get() = \"com.lightningkite.krosslin.test.models\"\n    override val localName: String get() = \"User.GetToken\"\n    override val implements: Array<MirrorClass<*>> get() = arrayOf(RequestMirror(UserTokenMirror))\n    override val owningClass: KClass<*>? get() = User::class\n    override val annotations: List<Annotation> = listOf(ThrowsTypesMirror(arrayOf(\"NoSuchElementException\",\"ForbiddenException\")))\n    \n    val fieldEmail: Field<User.GetToken,Email> = Field(\n        owner = this,\n        index = 0,\n        name = \"email\",\n        type = EmailMirror,\n        optional = false,\n        get = { it.email },\n        annotations = listOf<Annotation>()\n    )\n    \n    val fieldPassword: Field<User.GetToken,String> = Field(\n        owner = this,\n        index = 1,\n        name = \"password\",\n        type = StringMirror,\n        optional = false,\n        get = { it.password },\n        annotations = listOf<Annotation>()\n    )\n    \n    override val fields: Array<Field<User.GetToken, *>> = arrayOf(fieldEmail, fieldPassword)\n    \n    override fun deserialize(decoder: Decoder): User.GetToken {\n        var emailSet = false\n        var fieldEmail: Email? = null\n        var passwordSet = false\n        var fieldPassword: String? = null\n        val decoderStructure = decoder.beginStructure(this)\n        loop@ while (true) {\n            when (decoderStructure.decodeElementIndex(this)) {\n                CompositeDecoder.READ_ALL -> {\n                    fieldEmail = decoderStructure.decodeSerializableElement(this, 0, EmailMirror)\n                    emailSet = true\n                    fieldPassword = decoderStructure.decodeStringElement(this, 1)\n                    passwordSet = true\n                    break@loop\n                }\n                CompositeDecoder.READ_DONE -> break@loop\n                0 -> {\n                    fieldEmail = decoderStructure.decodeSerializableElement(this, 0, EmailMirror)\n                    emailSet = true\n                }\n                1 -> {\n                    fieldPassword = decoderStructure.decodeStringElement(this, 1)\n                    passwordSet = true\n                }\n                else -> {}\n            }\n        }\n        decoderStructure.endStructure(this)\n        if(!emailSet) {\n            throw MissingFieldException(\"email\")\n        }\n        if(!passwordSet) {\n            throw MissingFieldException(\"password\")\n        }\n        return User.GetToken(\n            email = fieldEmail as Email,\n            password = fieldPassword as String\n        )\n    }\n    \n    override fun serialize(encoder: Encoder, obj: User.GetToken) {\n        val encoderStructure = encoder.beginStructure(this)\n        encoderStructure.encodeSerializableElement(this, 0, EmailMirror, obj.email)\n        encoderStructure.encodeStringElement(this, 1, obj.password)\n        encoderStructure.endStructure(this)\n    }\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.krosslin.test.models\n\nimport com.lightningkite.kommon.string.Email\nimport com.lightningkite.lokalize.time.TimeStamp\nimport com.lightningkite.mirror.archive.database.Database\nimport com.lightningkite.mirror.archive.model.HasUuid\nimport com.lightningkite.mirror.archive.model.Uuid\nimport com.lightningkite.mirror.form.info.FormEditOnly\nimport com.lightningkite.mirror.form.info.FormHidden\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\nimport com.lightningkite.mirror.info.ThrowsTypes\nimport com.lightningkite.mirror.request.Request\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\nimport com.lightningkite.mirror.form.info.FormNeedsNoContextMirror\nimport com.lightningkite.mirror.archive.model.UuidMirror\nimport com.lightningkite.kommon.string.EmailMirror\nimport com.lightningkite.mirror.form.info.FormEditOnlyMirror\nimport com.lightningkite.mirror.archive.model.HasUuidMirror\nimport com.lightningkite.lokalize.time.TimeStampMirror\nimport com.lightningkite.mirror.form.info.FormHiddenMirror\n\nobject UserMirror : MirrorClass<User>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<User> get() = User::class as KClass<User>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Data)\n    override val packageName: String get() = \"com.lightningkite.krosslin.test.models\"\n    override val localName: String get() = \"User\"\n    override val implements: Array<MirrorClass<*>> get() = arrayOf(HasUuidMirror)\n    \n    val fieldId: Field<User,Uuid> = Field(\n        owner = this,\n        index = 0,\n        name = \"id\",\n        type = UuidMirror,\n        optional = true,\n        get = { it.id },\n        set = { it, value -> it.id = value },\n        annotations = listOf<Annotation>(FormHiddenMirror())\n    )\n    \n    val fieldEmail: Field<User,Email> = Field(\n        owner = this,\n        index = 1,\n        name = \"email\",\n        type = EmailMirror,\n        optional = true,\n        get = { it.email },\n        set = { it, value -> it.email = value },\n        annotations = listOf<Annotation>(FormNeedsNoContextMirror())\n    )\n    \n    val fieldPassword: Field<User,String> = Field(\n        owner = this,\n        index = 2,\n        name = \"password\",\n        type = StringMirror,\n        optional = true,\n        get = { it.password },\n        set = { it, value -> it.password = value },\n        annotations = listOf<Annotation>(FormEditOnlyMirror())\n    )\n    \n    val fieldRole: Field<User,User.Role> = Field(\n        owner = this,\n        index = 3,\n        name = \"role\",\n        type = UserRoleMirror,\n        optional = true,\n        get = { it.role },\n        set = { it, value -> it.role = value },\n        annotations = listOf<Annotation>()\n    )\n    \n    val fieldRejectTokensBefore: Field<User,TimeStamp> = Field(\n        owner = this,\n        index = 4,\n        name = \"rejectTokensBefore\",\n        type = TimeStampMirror,\n        optional = true,\n        get = { it.rejectTokensBefore },\n        set = { it, value -> it.rejectTokensBefore = value },\n        annotations = listOf<Annotation>(FormEditOnlyMirror())\n    )\n    \n    override val fields: Array<Field<User, *>> = arrayOf(fieldId, fieldEmail, fieldPassword, fieldRole, fieldRejectTokensBefore)\n    \n    override fun deserialize(decoder: Decoder): User {\n        var idSet = false\n        var fieldId: Uuid? = null\n        var emailSet = false\n        var fieldEmail: Email? = null\n        var passwordSet = false\n        var fieldPassword: String? = null\n        var roleSet = false\n        var fieldRole: User.Role? = null\n        var rejectTokensBeforeSet = false\n        var fieldRejectTokensBefore: TimeStamp? = null\n        val decoderStructure = decoder.beginStructure(this)\n        loop@ while (true) {\n            when (decoderStructure.decodeElementIndex(this)) {\n                CompositeDecoder.READ_ALL -> {\n                    fieldId = decoderStructure.decodeSerializableElement(this, 0, UuidMirror)\n                    idSet = true\n                    fieldEmail = decoderStructure.decodeSerializableElement(this, 1, EmailMirror)\n                    emailSet = true\n                    fieldPassword = decoderStructure.decodeStringElement(this, 2)\n                    passwordSet = true\n                    fieldRole = decoderStructure.decodeSerializableElement(this, 3, UserRoleMirror)\n                    roleSet = true\n                    fieldRejectTokensBefore = decoderStructure.decodeSerializableElement(this, 4, TimeStampMirror)\n                    rejectTokensBeforeSet = true\n                    break@loop\n                }\n                CompositeDecoder.READ_DONE -> break@loop\n                0 -> {\n                    fieldId = decoderStructure.decodeSerializableElement(this, 0, UuidMirror)\n                    idSet = true\n                }\n                1 -> {\n                    fieldEmail = decoderStructure.decodeSerializableElement(this, 1, EmailMirror)\n                    emailSet = true\n                }\n                2 -> {\n                    fieldPassword = decoderStructure.decodeStringElement(this, 2)\n                    passwordSet = true\n                }\n                3 -> {\n                    fieldRole = decoderStructure.decodeSerializableElement(this, 3, UserRoleMirror)\n                    roleSet = true\n                }\n                4 -> {\n                    fieldRejectTokensBefore = decoderStructure.decodeSerializableElement(this, 4, TimeStampMirror)\n                    rejectTokensBeforeSet = true\n                }\n                else -> {}\n            }\n        }\n        decoderStructure.endStructure(this)\n        if(!idSet) {\n            fieldId = Uuid.randomUUID4()\n        }\n        if(!emailSet) {\n            fieldEmail = Email(\"\")\n        }\n        if(!passwordSet) {\n            fieldPassword = \"\"\n        }\n        if(!roleSet) {\n            fieldRole = User.Role.Citizen\n        }\n        if(!rejectTokensBeforeSet) {\n            fieldRejectTokensBefore = TimeStamp(0)\n        }\n        return User(\n            id = fieldId as Uuid,\n            email = fieldEmail as Email,\n            password = fieldPassword as String,\n            role = fieldRole as User.Role,\n            rejectTokensBefore = fieldRejectTokensBefore as TimeStamp\n        )\n    }\n    \n    override fun serialize(encoder: Encoder, obj: User) {\n        val encoderStructure = encoder.beginStructure(this)\n        encoderStructure.encodeSerializableElement(this, 0, UuidMirror, obj.id)\n        encoderStructure.encodeSerializableElement(this, 1, EmailMirror, obj.email)\n        encoderStructure.encodeStringElement(this, 2, obj.password)\n        encoderStructure.encodeSerializableElement(this, 3, UserRoleMirror, obj.role)\n        encoderStructure.encodeSerializableElement(this, 4, TimeStampMirror, obj.rejectTokensBefore)\n        encoderStructure.endStructure(this)\n    }\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.krosslin.test.models\n\nimport com.lightningkite.kommon.string.Email\nimport com.lightningkite.lokalize.time.TimeStamp\nimport com.lightningkite.mirror.archive.database.Database\nimport com.lightningkite.mirror.archive.model.HasUuid\nimport com.lightningkite.mirror.archive.model.Uuid\nimport com.lightningkite.mirror.form.info.FormEditOnly\nimport com.lightningkite.mirror.form.info.FormHidden\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\nimport com.lightningkite.mirror.info.ThrowsTypes\nimport com.lightningkite.mirror.request.Request\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\nimport com.lightningkite.kommon.string.EmailMirror\nimport com.lightningkite.mirror.request.RequestMirror\n\nobject UserResetPasswordMirror : MirrorClass<User.ResetPassword>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<User.ResetPassword> get() = User.ResetPassword::class as KClass<User.ResetPassword>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Data)\n    override val packageName: String get() = \"com.lightningkite.krosslin.test.models\"\n    override val localName: String get() = \"User.ResetPassword\"\n    override val implements: Array<MirrorClass<*>> get() = arrayOf(RequestMirror(UnitMirror))\n    override val owningClass: KClass<*>? get() = User::class\n    \n    val fieldEmail: Field<User.ResetPassword,Email> = Field(\n        owner = this,\n        index = 0,\n        name = \"email\",\n        type = EmailMirror,\n        optional = false,\n        get = { it.email },\n        annotations = listOf<Annotation>()\n    )\n    \n    override val fields: Array<Field<User.ResetPassword, *>> = arrayOf(fieldEmail)\n    \n    override fun deserialize(decoder: Decoder): User.ResetPassword {\n        var emailSet = false\n        var fieldEmail: Email? = null\n        val decoderStructure = decoder.beginStructure(this)\n        loop@ while (true) {\n            when (decoderStructure.decodeElementIndex(this)) {\n                CompositeDecoder.READ_ALL -> {\n                    fieldEmail = decoderStructure.decodeSerializableElement(this, 0, EmailMirror)\n                    emailSet = true\n                    break@loop\n                }\n                CompositeDecoder.READ_DONE -> break@loop\n                0 -> {\n                    fieldEmail = decoderStructure.decodeSerializableElement(this, 0, EmailMirror)\n                    emailSet = true\n                }\n                else -> {}\n            }\n        }\n        decoderStructure.endStructure(this)\n        if(!emailSet) {\n            throw MissingFieldException(\"email\")\n        }\n        return User.ResetPassword(\n            email = fieldEmail as Email\n        )\n    }\n    \n    override fun serialize(encoder: Encoder, obj: User.ResetPassword) {\n        val encoderStructure = encoder.beginStructure(this)\n        encoderStructure.encodeSerializableElement(this, 0, EmailMirror, obj.email)\n        encoderStructure.endStructure(this)\n    }\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.krosslin.test.models\n\nimport com.lightningkite.kommon.string.Email\nimport com.lightningkite.lokalize.time.TimeStamp\nimport com.lightningkite.mirror.archive.database.Database\nimport com.lightningkite.mirror.archive.model.HasUuid\nimport com.lightningkite.mirror.archive.model.Uuid\nimport com.lightningkite.mirror.form.info.FormEditOnly\nimport com.lightningkite.mirror.form.info.FormHidden\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\nimport com.lightningkite.mirror.info.ThrowsTypes\nimport com.lightningkite.mirror.request.Request\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\n\nobject UserRoleMirror : MirrorEnum<User.Role>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<User.Role> get() = User.Role::class as KClass<User.Role>\n    override val modifiers: Array<Modifier> get() = arrayOf()\n    override val packageName: String get() = \"com.lightningkite.krosslin.test.models\"\n    override val localName: String get() = \"User.Role\"\n    override val enumValues: Array<User.Role> get() = arrayOf(User.Role.Citizen,User.Role.Admin)\n    override val owningClass: KClass<*>? get() = User::class\n}\n","//Generated by Lightning Kite's Mirror plugin\n//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT\npackage com.lightningkite.krosslin.test.models\n\nimport com.lightningkite.kommon.string.Email\nimport com.lightningkite.lokalize.time.TimeStamp\nimport com.lightningkite.mirror.archive.database.Database\nimport com.lightningkite.mirror.archive.model.HasUuid\nimport com.lightningkite.mirror.archive.model.Uuid\nimport com.lightningkite.mirror.form.info.FormEditOnly\nimport com.lightningkite.mirror.form.info.FormHidden\nimport com.lightningkite.mirror.form.info.FormNeedsNoContext\nimport com.lightningkite.mirror.info.ThrowsTypes\nimport com.lightningkite.mirror.request.Request\nimport com.lightningkite.mirror.info.*\nimport kotlin.reflect.KClass\nimport kotlinx.serialization.*\nimport mirror.kotlin.*\n\nobject UserTokenMirror : MirrorClass<User.Token>() {\n    @Suppress(\"UNCHECKED_CAST\")\n    override val kClass: KClass<User.Token> get() = User.Token::class as KClass<User.Token>\n    override val modifiers: Array<Modifier> get() = arrayOf(Modifier.Data)\n    override val packageName: String get() = \"com.lightningkite.krosslin.test.models\"\n    override val localName: String get() = \"User.Token\"\n    override val implements: Array<MirrorClass<*>> get() = arrayOf()\n    override val owningClass: KClass<*>? get() = User::class\n    \n    val fieldString: Field<User.Token,String> = Field(\n        owner = this,\n        index = 0,\n        name = \"string\",\n        type = StringMirror,\n        optional = false,\n        get = { it.string },\n        annotations = listOf<Annotation>()\n    )\n    \n    override val fields: Array<Field<User.Token, *>> = arrayOf(fieldString)\n    \n    override fun deserialize(decoder: Decoder): User.Token {\n        var stringSet = false\n        var fieldString: String? = null\n        val decoderStructure = decoder.beginStructure(this)\n        loop@ while (true) {\n            when (decoderStructure.decodeElementIndex(this)) {\n                CompositeDecoder.READ_ALL -> {\n                    fieldString = decoderStructure.decodeStringElement(this, 0)\n                    stringSet = true\n                    break@loop\n                }\n                CompositeDecoder.READ_DONE -> break@loop\n                0 -> {\n                    fieldString = decoderStructure.decodeStringElement(this, 0)\n                    stringSet = true\n                }\n                else -> {}\n            }\n        }\n        decoderStructure.endStructure(this)\n        if(!stringSet) {\n            throw MissingFieldException(\"string\")\n        }\n        return User.Token(\n            string = fieldString as String\n        )\n    }\n    \n    override fun serialize(encoder: Encoder, obj: User.Token) {\n        val encoderStructure = encoder.beginStructure(this)\n        encoderStructure.encodeStringElement(this, 0, obj.string)\n        encoderStructure.endStructure(this)\n    }\n}\n","package com.lightningkite.krosslin.test\n\nimport com.lightningkite.koolui.color.*\nimport com.lightningkite.koolui.views.*\nimport com.lightningkite.koolui.builders.*\nimport com.lightningkite.koolui.*\nimport com.lightningkite.krosslin.test.MainVG\nimport com.lightningkite.krosslin.test.MyViewFactory\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.get\nimport kotlin.browser.document\nimport kotlin.browser.window\n\n\nclass Factory() : MyViewFactory<HTMLElement>, ViewFactory<HTMLElement> by HtmlViewFactory(Theme.dark()) {}\n\nfun main(args: Array<String>) {\n    window.onload = {\n        document.body!!.appendChild(\n                Factory().contentRoot(MainVG<HTMLElement>())\n        )\n    }\n}\n"],"names":[],"mappings":"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"}