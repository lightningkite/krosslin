{"version":3,"file":"reacktive.js","sources":["generated/_Collections.kt","comparisons/Comparisons.kt","kotlin/Comparator.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/collection/MutableObservableCollection.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/EnablingMutableCollection.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/EnablingObject.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/invokeAll.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/ConstantObservableList.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/EnablingObservableList.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/extensions.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/FilteringObservableList.kt","util/Standard.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/FlatMappingObservableList.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/IndexObservableList.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/IndexObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/LastObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/MappingMutableObservableList.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/MappingObservableList.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/MutableObservableList.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/MutableObservableListFromProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/ObservableList.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/ObservableListAsMutable.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/ObservableListFromProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/list/WrapperObservableList.kt","collections/Collections.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/map/GroupingObservableMap.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/map/HelpersMutable.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/mapping/CollectionWriteOnlyMapping.kt","collections/Maps.kt","collections/MutableCollections.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/mapping/Iterator.ext.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/NoOpMutableCollection.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/CombineObservableProperty2.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/CombineObservableProperty3.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/CombineObservablePropertyBlind.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/ConstantObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/LateInitObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/lifecycle/openCloseBinding.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/lifecycle/bind.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/lifecycle/listen.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/MutableListFromProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/ReferenceObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/StandardObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/SubObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/TransformMutableObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/TransformObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/update.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/VirtualMutableObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/property/VirtualObservableProperty.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/set/MappingMutableObservableSet.kt","../../../../../src/commonMain/kotlin/com/lightningkite/reacktive/set/MappingObservableSet.kt"],"sourcesContent":["/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual interface Comparator<T> {\n    @JsName(\"compare\")\n    actual fun compare(a: T, b: T): Int\n}\n\npublic actual inline fun <T> Comparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> = object : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparison(a, b)\n}\n","package com.lightningkite.reacktive.collection\r\n\r\ninterface MutableObservableCollection<V> : MutableCollection<V>, ObservableCollection<V>{\r\n    fun change(old: V, new: V){\r\n        if(!remove(old)) throw IllegalArgumentException(\"$old not in the collection!\")\r\n        add(new)\r\n    }\r\n    fun replace(collection: Collection<V>)\r\n}\r\n","package com.lightningkite.reacktive\r\n\r\n\r\n/**\r\n * A collection that calls [enable] when the collection has an element in it, and [disable] when the collection is empty.\r\n * Created by joseph on 12/2/16.\r\n */\r\nabstract class EnablingMutableCollection<E>(val wraps:MutableList<E> = ArrayList()) : MutableList<E> by wraps {\r\n\r\n    abstract fun enable(): Unit\r\n    abstract fun disable(): Unit\r\n\r\n    var active = false\r\n    fun forceUp() {\r\n        if (!active) {\r\n            active = true\r\n            enable()\r\n        }\r\n    }\r\n\r\n    fun checkDown() {\r\n        if (wraps.isEmpty() && active) {\r\n            active = false\r\n            disable()\r\n        }\r\n    }\r\n\r\n    override fun add(element: E): Boolean {\r\n        forceUp()\r\n        val result = wraps.add(element)\r\n        return result\r\n    }\r\n\r\n    override fun addAll(elements: Collection<E>): Boolean {\r\n        forceUp()\r\n        val result = wraps.addAll(elements)\r\n        return result\r\n    }\r\n\r\n    override fun clear() {\r\n        wraps.clear()\r\n        checkDown()\r\n    }\r\n\r\n    override fun remove(element: E): Boolean {\r\n        val result = wraps.remove(element)\r\n        checkDown()\r\n        return result\r\n    }\r\n\r\n    override fun removeAll(elements: Collection<E>): Boolean {\r\n        val result = wraps.removeAll(elements)\r\n        checkDown()\r\n        return result\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<E>): Boolean {\r\n        val result = wraps.retainAll(elements)\r\n        checkDown()\r\n        return result\r\n    }\r\n}\r\n","package com.lightningkite.reacktive\r\n\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\n\r\nabstract class EnablingObject {\r\n    abstract fun enable()\r\n    abstract fun disable()\r\n    abstract fun refresh()\r\n\r\n    fun refreshIfNotActive(){\r\n        if(listenings == 0) refresh()\r\n    }\r\n\r\n    val enabled: Boolean get() = listenings > 0\r\n    protected var listenings = 0\r\n        set(value) {\r\n            val oldValue = field\r\n            field = value\r\n            if (value == 0 && oldValue != 0) {\r\n                disable()\r\n            }\r\n            if (value != 0 && oldValue == 0) {\r\n                refresh()\r\n                enable()\r\n            }\r\n        }\r\n\r\n    open inner class SubEnablingCollection<A> : EnablingMutableCollection<A>() {\r\n        override fun enable() {\r\n            listenings++\r\n        }\r\n        override fun disable() {\r\n            listenings--\r\n        }\r\n    }\r\n\r\n    abstract inner class SubEnablingObservableProperty<A> : ObservableProperty<A>, EnablingMutableCollection<(A) -> Unit>() {\r\n\r\n        override fun enable() {\r\n            listenings++\r\n        }\r\n\r\n        override fun disable() {\r\n            listenings--\r\n        }\r\n\r\n        fun update(){\r\n            for(item in this){\r\n                item.invoke(value)\r\n            }\r\n        }\r\n    }\r\n}\r\n","package com.lightningkite.reacktive\r\n\r\n/**\r\n * These functions are extremely handy for using collections as events.  Example:\r\n * <code>\r\n *     val onIntFound = ArrayList<(Int)->Unit>()\r\n *     onIntFound += { println(it) } //adds a listener\r\n *     onIntFound.invokeAll(1)\r\n *     onIntFound.invokeAll(2)\r\n *     onIntFound.invokeAll(3)\r\n * </code>\r\n * Created by joseph on 9/27/17.\r\n */\r\n\r\n/**\r\n * Invokes all of the functions in this iterable.\r\n */\r\nfun Iterable<() -> Unit>.invokeAll() {\r\n    for (item in this) {\r\n        item()\r\n    }\r\n}\r\n\r\n/**\r\n * Invokes all of the functions in this iterable with the given arguments.\r\n */\r\nfun <A> Iterable<(A) -> Unit>.invokeAll(a: A) {\r\n    for (item in this) {\r\n        item(a)\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Invokes all of the functions in this iterable with the given arguments.\r\n */\r\nfun <A, B> Iterable<(A, B) -> Unit>.invokeAll(a: A, b: B) {\r\n    for (item in this) {\r\n        item(a, b)\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Invokes all of the functions in this iterable with the given arguments.\r\n */\r\nfun <A, B, C> Iterable<(A, B, C) -> Unit>.invokeAll(a: A, b: B, c: C) {\r\n    for (item in this) {\r\n        item(a, b, c)\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Invokes all of the functions in this iterable with the given arguments.\r\n */\r\nfun <A, B, C, D> Iterable<(A, B, C, D) -> Unit>.invokeAll(a: A, b: B, c: C, d: D) {\r\n    for (item in this) {\r\n        item(a, b, c, d)\r\n    }\r\n}","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.NoOpMutableCollection\r\nimport com.lightningkite.reacktive.property.ConstantObservableProperty\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\n\r\nclass ConstantObservableList<T>(val originalList: List<T>): ObservableList<T>, List<T> by originalList {\r\n    override val onListAdd: MutableCollection<(T, Int) -> Unit> get() = NoOpMutableCollection.type()\r\n    override val onListChange: MutableCollection<(T, T, Int) -> Unit> get() = NoOpMutableCollection.type()\r\n    override val onListMove: MutableCollection<(T, Int, Int) -> Unit> get() = NoOpMutableCollection.type()\r\n    override val onListRemove: MutableCollection<(T, Int) -> Unit> get() = NoOpMutableCollection.type()\r\n    override val onListReplace: MutableCollection<(ObservableList<T>) -> Unit> get() = NoOpMutableCollection.type()\r\n    override val onListUpdate: ObservableProperty<ObservableList<T>> get() = ConstantObservableProperty(this)\r\n}","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.EnablingObject\r\n\r\nabstract class EnablingObservableList<E> : ObservableList<E>, EnablingObject() {\r\n\r\n    override val onListAdd: MutableCollection<(E, Int) -> Unit> = SubEnablingCollection()\r\n    override val onListChange: MutableCollection<(E, E, Int) -> Unit> = SubEnablingCollection()\r\n    override val onListMove: MutableCollection<(E, Int, Int) -> Unit> = SubEnablingCollection()\r\n    override val onListUpdate = object : SubEnablingObservableProperty<ObservableList<E>>(){\r\n        override val value: ObservableList<E> get() = this@EnablingObservableList\r\n    }\r\n    override val onListReplace: MutableCollection<(ObservableList<E>) -> Unit> = SubEnablingCollection()\r\n    override val onListRemove: MutableCollection<(E, Int) -> Unit> = SubEnablingCollection()\r\n\r\n}\r\n","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\n\r\nfun <E> Array<E>.asObservableList() = ConstantObservableList(this.toList())\r\nfun <E> List<E>.asObservableList() = ConstantObservableList(this)\r\nfun <E> MutableList<E>.asObservableList() = WrapperObservableList(this)\r\nfun <E> ObservableProperty<List<E>>.asObservableList() = ObservableListFromProperty(this)\r\n\r\nfun <E> observableListOf() = ConstantObservableList(emptyList<E>())\r\nfun <E> observableListOf(vararg elements: E) = ConstantObservableList(elements.toList())\r\nfun <E> mutableObservableListOf(vararg elements: E) = WrapperObservableList(elements.toMutableList())","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.list.asMutable\r\n\r\n/**\r\n * Allows you to observe the changes to a list.\r\n * Created by josep on 9/7/2015.\r\n */\r\nclass FilteringObservableList<E>(\r\n        val mutableSource: MutableObservableList<E>,\r\n        filter: (E) -> Boolean = { true }\r\n) : IndexObservableList<E>(mutableSource), MutableObservableList<E> {\r\n\r\n    override fun set(index: Int, element: E): E {\r\n        refreshIfNotActive()\r\n        mutableSource[sourceIndex(index)] = element\r\n        return element\r\n    }\r\n    override fun add(index: Int, element: E): Unit {\r\n        refreshIfNotActive()\r\n        mutableSource.add(sourceIndex(index), element)\r\n    }\r\n    override fun addAll(index: Int, elements: Collection<E>): Boolean {\r\n        refreshIfNotActive()\r\n        return mutableSource.addAll(sourceIndex(index), elements)\r\n    }\r\n    override fun move(fromIndex: Int, toIndex: Int) {\r\n        refreshIfNotActive()\r\n        mutableSource.move(sourceIndex(fromIndex), sourceIndex(toIndex))\r\n    }\r\n    override fun removeAt(index: Int): E {\r\n        refreshIfNotActive()\r\n        return mutableSource.removeAt(sourceIndex(index))\r\n    }\r\n    override fun replace(collection: Collection<E>) = mutableSource.replace(collection)\r\n    override fun add(element: E): Boolean = if(filter(element)){\r\n        mutableSource.add(element)\r\n        true\r\n    } else false\r\n    override fun addAll(elements: Collection<E>): Boolean = mutableSource.addAll(elements.filter(filter))\r\n    override fun clear() = mutableSource.clear()\r\n    override fun remove(element: E): Boolean = mutableSource.remove(element)\r\n    override fun removeAll(elements: Collection<E>): Boolean = mutableSource.removeAll(elements)\r\n    override fun retainAll(elements: Collection<E>): Boolean = mutableSource.retainAll(elements)\r\n\r\n\r\n    override fun refresh() {\r\n        resetIndex(source.indices.filter { filter(source[it]) })\r\n    }\r\n\r\n    var filter: (E) -> Boolean = filter\r\n        set(value) {\r\n            field = value\r\n            refresh()\r\n        }\r\n\r\n    init {\r\n        refresh()\r\n    }\r\n\r\n    override fun onSourceListAdd(element: E, sourceIndex: Int) {\r\n        if (filter(element)) {\r\n            addIndex(orderedTransformedIndexOrBetween(sourceIndex), sourceIndex)\r\n        }\r\n    }\r\n\r\n    override fun onSourceListChange(old: E, element: E, sourceIndex: Int) {\r\n        val oldPassed = sourceIndex in indexList\r\n        val passes = filter(element)\r\n        if (oldPassed && !passes) {\r\n            removeIndex(transformedIndexOrDefault(sourceIndex, -1))\r\n        }\r\n        if (passes && !oldPassed) {\r\n            addIndex(orderedTransformedIndexOrBetween(sourceIndex), sourceIndex)\r\n        }\r\n    }\r\n\r\n    override fun onSourceListMove(element: E, oldSourceIndex: Int, sourceIndex: Int) {\r\n        transformedIndex(sourceIndex)?.let {\r\n            moveIndex(\r\n                    it,\r\n                    orderedTransformedIndexOrBetween(sourceIndex).let{ new ->\r\n                        if(new > it) new - 1\r\n                        else new\r\n                    }\r\n            )\r\n        }\r\n    }\r\n\r\n    override fun onSourceListRemove(element: E, sourceIndex: Int) {\r\n        /*Handled by IndexObservableList*/\r\n    }\r\n}\r\n\r\nfun <E> MutableObservableList<E>.filtering(): FilteringObservableList<E> = FilteringObservableList(this)\r\nfun <E> MutableObservableList<E>.filtering(initFilter: (E) -> Boolean): FilteringObservableList<E> = FilteringObservableList(this, initFilter).apply {\r\n    filter = initFilter\r\n}\r\n\r\nfun <E> ObservableList<E>.filtering(): FilteringObservableList<E> = FilteringObservableList(this.asMutable())\r\nfun <E> ObservableList<E>.filtering(initFilter: (E) -> Boolean): FilteringObservableList<E> = FilteringObservableList(this.asMutable(), initFilter).apply {\r\n    filter = initFilter\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package com.lightningkite.reacktive.list\r\n\r\n\r\nimport com.lightningkite.reacktive.invokeAll\r\n\r\n/**\r\n * Gives you a flat-mapped view of an observable list.\r\n * Created by jivie on 5/6/16.\r\n */\r\nclass FlatMappingObservableList<S, E>(\r\n        val source: MutableObservableList<S>,\r\n        val mapper: (S) -> MutableObservableList<E>\r\n) : MutableObservableList<E>, EnablingObservableList<E>() {\r\n\r\n    val boundaryIndexes = ArrayList<Int>()\r\n\r\n    fun getIndex(pair: Pair<Int, Int>): Int {\r\n        return boundaryIndexes[pair.first] + pair.second\r\n    }\r\n\r\n    fun getIndicies(index: Int): Pair<Int, Int> {\r\n        for (outerIndex in 0..boundaryIndexes.lastIndex - 1) {\r\n            val position = boundaryIndexes[outerIndex + 1]\r\n            if (index < position) return outerIndex to index - boundaryIndexes[outerIndex]\r\n        }\r\n        throw IndexOutOfBoundsException()\r\n    }\r\n\r\n    fun modifyIndiciesAfter(listIndex: Int, by: Int) {\r\n        for (i in listIndex + 1..boundaryIndexes.lastIndex) {\r\n            boundaryIndexes[i] += by\r\n        }\r\n    }\r\n\r\n    fun insertBoundaryIndex(overallIndex: Int, size: Int): Int {\r\n        for (i in overallIndex..boundaryIndexes.lastIndex) {\r\n            boundaryIndexes[i] += size\r\n        }\r\n        val newStart = boundaryIndexes[overallIndex] - size\r\n        boundaryIndexes.add(overallIndex, newStart)\r\n        return newStart\r\n    }\r\n\r\n    fun removeBoundaryIndex(overallIndex: Int, item: S): Int {\r\n        val oldBoundary = boundaryIndexes[overallIndex]\r\n        val size = item.let(mapper).size\r\n        for (i in overallIndex..boundaryIndexes.lastIndex) {\r\n            boundaryIndexes[i] -= size\r\n        }\r\n        boundaryIndexes.removeAt(overallIndex)\r\n        return oldBoundary\r\n    }\r\n\r\n    override val size: Int\r\n        get() {\r\n            refreshIfNotActive()\r\n            return boundaryIndexes.last()\r\n        }\r\n\r\n    override fun contains(element: E): Boolean = source.any { mapper(it).contains(element) }\r\n    override fun containsAll(elements: Collection<E>): Boolean = source.flatMap(mapper).containsAll(elements)\r\n    override fun get(index: Int): E {\r\n        refreshIfNotActive()\r\n        val i = getIndicies(index)\r\n        return source[i.first].let(mapper)[i.second]\r\n    }\r\n\r\n    override fun indexOf(element: E): Int {\r\n        refreshIfNotActive()\r\n        return source.flatMap(mapper).indexOf(element)\r\n    } //TODO - could be more efficient\r\n\r\n    override fun isEmpty(): Boolean = source.isEmpty() || source.all { mapper(it).isEmpty() }\r\n    override fun lastIndexOf(element: E): Int {\r\n        refreshIfNotActive()\r\n        return source.flatMap(mapper).lastIndexOf(element)\r\n    } //TODO - could be more efficient\r\n\r\n    override fun add(element: E): Boolean {\r\n        refreshIfNotActive()\r\n        return source.last().let(mapper).add(element)\r\n    }\r\n\r\n    override fun add(index: Int, element: E) {\r\n        refreshIfNotActive()\r\n        val i = getIndicies(index)\r\n        source[i.first].let(mapper).add(i.second, element)\r\n    }\r\n\r\n    override fun move(fromIndex: Int, toIndex: Int) {\r\n        refreshIfNotActive()\r\n        val from = getIndicies(fromIndex)\r\n        val to = getIndicies(if (toIndex > fromIndex) toIndex - 1 else toIndex)\r\n        //TODO: Add/remove?\r\n        if (from.first != to.first) throw UnsupportedOperationException(\"You can't move an item between lists.\")\r\n        source[from.first].let(mapper).move(from.second, to.second)\r\n    }\r\n\r\n    override fun addAll(elements: Collection<E>): Boolean {\r\n        refreshIfNotActive()\r\n        return source.last().let(mapper).addAll(elements)\r\n    }\r\n\r\n    override fun addAll(index: Int, elements: Collection<E>): Boolean {\r\n        refreshIfNotActive()\r\n        val i = getIndicies(index)\r\n        return source[i.first].let(mapper).addAll(i.second, elements)\r\n    }\r\n\r\n    override fun clear() = source.clear()\r\n    override fun remove(element: E): Boolean {\r\n        refreshIfNotActive()\r\n        return source.any { it.let(mapper).remove(element) }\r\n    }\r\n\r\n    override fun removeAll(elements: Collection<E>): Boolean {\r\n        refreshIfNotActive()\r\n        source.forEach { it.let(mapper).removeAll(elements) }\r\n        return true\r\n    }\r\n\r\n    override fun removeAt(index: Int): E {\r\n        refreshIfNotActive()\r\n        val i = getIndicies(index)\r\n        return source[i.first].let(mapper).removeAt(i.second)\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<E>): Boolean = throw UnsupportedOperationException()\r\n    override fun set(index: Int, element: E): E {\r\n        refreshIfNotActive()\r\n        val i = getIndicies(index)\r\n        source[i.first].let(mapper)[i.second] = element\r\n        return element\r\n    }\r\n\r\n    override fun replace(collection: Collection<E>) = throw UnsupportedOperationException()\r\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = throw UnsupportedOperationException()\r\n\r\n    //TODO: Both of these can be supported.\r\n    override fun listIterator(): MutableListIterator<E> = throw UnsupportedOperationException()\r\n\r\n    override fun listIterator(index: Int): MutableListIterator<E> = throw UnsupportedOperationException()\r\n\r\n    override fun iterator(): MutableIterator<E> = object : MutableIterator<E> {\r\n        init {\r\n            refreshIfNotActive()\r\n        }\r\n\r\n        val sourceIterator = source.iterator()\r\n        var subIterator = if (sourceIterator.hasNext()) sourceIterator.next().let(mapper).iterator() else null\r\n        override fun hasNext(): Boolean {\r\n            return if (subIterator == null) false\r\n            else if (subIterator!!.hasNext()) true\r\n            else if (sourceIterator.hasNext()) {\r\n                subIterator = sourceIterator.next().let(mapper).iterator()\r\n                hasNext()\r\n            } else false\r\n        }\r\n\r\n        override fun next(): E {\r\n            if (!hasNext()) throw IllegalStateException(\"No more items\")\r\n            return subIterator!!.next()\r\n        }\r\n\r\n        override fun remove() {\r\n            subIterator!!.remove()\r\n        }\r\n    }\r\n\r\n    fun onTotalItemAdd(item: S, index: Int) {\r\n        val list = item.let(mapper)\r\n        val newBoundary = insertBoundaryIndex(index, list.size)\r\n        for (i in 0..list.size - 1) {\r\n            onListAdd.invokeAll(list[i], newBoundary + i)\r\n        }\r\n        onListUpdate.update()\r\n    }\r\n\r\n    fun onTotalItemRemove(item: S, index: Int) {\r\n        val list = item.let(mapper)\r\n        val oldBoundary = removeBoundaryIndex(index, item)\r\n        for (i in list.size - 1 downTo 0) {\r\n            if (try {\r\n                        list[list.size - 1]; true\r\n                    } catch (e: Exception) {\r\n                        false\r\n                    })\r\n                println(\"Get error at $i\")\r\n            onListRemove.invokeAll(list[i], oldBoundary + i)\r\n        }\r\n        onListUpdate.update()\r\n    }\r\n\r\n    fun clearOldListeners() {\r\n        for ((list, set) in listenerSets) {\r\n            list.removeListenerSet(set)\r\n        }\r\n    }\r\n\r\n    val listenerSets = HashMap<ObservableList<E>, ObservableListListenerSet<E>>()\r\n    val overallListenerSet: ObservableListListenerSet<S> = ObservableListListenerSet<S>(\r\n            onAddListener = { item, index ->\r\n                onTotalItemAdd(item, index)\r\n\r\n                val newSet = subListenerSet(item)\r\n                val list = item.let(mapper)\r\n                list.addListenerSet(newSet)\r\n                listenerSets[list] = newSet\r\n            },\r\n            onRemoveListener = { item, index ->\r\n                onTotalItemRemove(item, index)\r\n\r\n                val list: ObservableList<E> = item.let(mapper)\r\n                val set = listenerSets[list]\r\n                if (set != null) {\r\n                    list.removeListenerSet(set)\r\n                }\r\n            },\r\n            onMoveListener = { item, oldIndex, index ->\r\n                //TODO could move each item\r\n                onTotalItemRemove(item, oldIndex)\r\n                onTotalItemAdd(item, index)\r\n            },\r\n            onChangeListener = { old, item, index ->\r\n                //TODO could change ones that are there then remove/add until fully used\r\n                onTotalItemRemove(old, index)\r\n                onTotalItemAdd(item, index)\r\n            },\r\n            onReplaceListener = { _ ->\r\n                refresh()\r\n            }\r\n    )\r\n\r\n    fun subListenerSet(itemContainingList: S) = ObservableListListenerSet<E>(\r\n            onAddListener = { item, index ->\r\n                val myIndex = source.indexOf(itemContainingList)\r\n                if (myIndex == -1) throw IllegalStateException()\r\n                val fullIndex = getIndex(myIndex to index)\r\n                modifyIndiciesAfter(myIndex, 1)\r\n                onListAdd.invokeAll(item, fullIndex)\r\n                onListUpdate.update()\r\n            },\r\n            onRemoveListener = { item, index ->\r\n                val myIndex = source.indexOf(itemContainingList)\r\n                if (myIndex == -1) throw IllegalStateException()\r\n                val fullIndex = getIndex(myIndex to index)\r\n                modifyIndiciesAfter(myIndex, -1)\r\n                onListRemove.invokeAll(item, fullIndex)\r\n                onListUpdate.update()\r\n            },\r\n            onMoveListener = { item, oldIndex, index ->\r\n                val myIndex = source.indexOf(itemContainingList)\r\n                val oldTotalIndex = getIndex(myIndex to oldIndex)\r\n                val newTotalIndex = getIndex(myIndex to index)\r\n                onListMove.invokeAll(item, oldTotalIndex, newTotalIndex)\r\n                onListUpdate.update()\r\n            },\r\n            onChangeListener = { old, item, index ->\r\n                val myIndex = source.indexOf(itemContainingList)\r\n                if (myIndex == -1) throw IllegalStateException()\r\n                val fullIndex = getIndex(myIndex to index)\r\n                onListChange.invokeAll(old, item, fullIndex)\r\n                onListUpdate.update()\r\n            },\r\n            onReplaceListener = { _ ->\r\n                val myIndex = source.indexOf(itemContainingList)\r\n                if (myIndex == -1) throw IllegalStateException()\r\n                onTotalItemRemove(itemContainingList, myIndex)\r\n                onTotalItemAdd(itemContainingList, myIndex)\r\n            }\r\n    )\r\n\r\n    var connected = false\r\n    override fun enable() {\r\n        if (connected) return\r\n        for (item in source) {\r\n            val newSet = subListenerSet(item)\r\n            val list = item.let(mapper)\r\n            list.addListenerSet(newSet)\r\n            listenerSets[list] = newSet\r\n        }\r\n        source.addListenerSet(overallListenerSet)\r\n        connected = true\r\n    }\r\n\r\n    override fun disable() {\r\n        if (!connected) return\r\n        source.removeListenerSet(overallListenerSet)\r\n        clearOldListeners()\r\n        connected = false\r\n    }\r\n\r\n    override fun refresh() {\r\n        boundaryIndexes.clear()\r\n        var current = 0\r\n        boundaryIndexes.add(current)\r\n        for (s in source) {\r\n            current += s.let(mapper).size\r\n            boundaryIndexes.add(current)\r\n        }\r\n    }\r\n}\r\n\r\nfun <S, E> MutableObservableList<S>.flatMapping(mapper: (S) -> MutableObservableList<E>): FlatMappingObservableList<S, E> = FlatMappingObservableList(this, mapper)\r\nfun <S, E> ObservableList<S>.flatMapping(mapper: (S) -> ObservableList<E>): FlatMappingObservableList<S, E> = FlatMappingObservableList(this.asMutable()) { mapper.invoke(it).asMutable() }\r\n","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.invokeAll\r\n\r\n/**\r\n * An observable list of indexList that merely references another list.\r\n * Created by joseph on 11/2/16.\r\n */\r\nabstract class IndexObservableList<E>(\r\n        val source: ObservableList<E>\r\n) : EnablingObservableList<E>(), ObservableList<E>, Collection<E> by source {\r\n    val indexList = ArrayList<Int>()\r\n\r\n    fun shift(after: Int, by: Int) {\r\n        for (i in indexList.indices) {\r\n            if (indexList[i] > after)\r\n                indexList[i] += by\r\n        }\r\n    }\r\n\r\n    fun shiftIncluding(after: Int, by: Int) {\r\n        for (i in indexList.indices) {\r\n            if (indexList[i] >= after)\r\n                indexList[i] += by\r\n        }\r\n    }\r\n\r\n    fun sourceIndex(transformedIndex: Int): Int {\r\n        return indexList[transformedIndex]\r\n    }\r\n\r\n    fun transformedIndex(sourceIndex: Int): Int? {\r\n        return indexList.indexOf(sourceIndex).takeUnless { it == -1 }\r\n    }\r\n\r\n    fun transformedIndexOrDefault(sourceIndex: Int, default: Int = -1): Int {\r\n        return indexList.indexOf(sourceIndex).let {\r\n            if (it == -1) default\r\n            else it\r\n        }\r\n    }\r\n\r\n    fun orderedTransformedIndexOrBetween(sourceIndex: Int): Int {\r\n        return indexList.indexOfFirst { it > sourceIndex }.takeUnless { it == -1 } ?: indexList.lastIndex+1\r\n    }\r\n\r\n    fun addIndex(transformedIndex: Int, sourceIndex: Int) {\r\n        indexList.add(transformedIndex, sourceIndex)\r\n        onListAdd.invokeAll(get(transformedIndex), transformedIndex)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    fun removeIndex(transformedIndex: Int) {\r\n        val old = get(transformedIndex)\r\n        indexList.removeAt(transformedIndex)\r\n        onListRemove.invokeAll(old, transformedIndex)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    fun moveIndex(oldTransformedIndex: Int, transformedIndex: Int) {\r\n        indexList.add(transformedIndex, indexList.removeAt(oldTransformedIndex))\r\n        onListMove.invokeAll(get(transformedIndex), oldTransformedIndex, transformedIndex)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    fun resetIndex(newIndicies: List<Int>) {\r\n        indexList.clear()\r\n        indexList.addAll(newIndicies)\r\n        onListReplace.invokeAll(this)\r\n        onListUpdate.update()\r\n    }\r\n\r\n\r\n    abstract fun onSourceListAdd(element: E, sourceIndex: Int)\r\n    abstract fun onSourceListChange(old: E, element: E, sourceIndex: Int)\r\n    abstract fun onSourceListMove(element: E, oldSourceIndex: Int, sourceIndex: Int)\r\n    abstract fun onSourceListRemove(element: E, sourceIndex: Int)\r\n\r\n\r\n    val onListAddListener: (E, Int) -> Unit = { element, index ->\r\n        shiftIncluding(index, 1)\r\n        onSourceListAdd(element, index)\r\n    }\r\n    val onListChangeListener: (E, E, Int) -> Unit = { old, element, index ->\r\n        transformedIndex(index)?.let {\r\n            onListChange.invokeAll(old, element, it)\r\n            onListUpdate.update()\r\n        }\r\n        onSourceListChange(old, element, index)\r\n    }\r\n    val onListMoveListener: (E, Int, Int) -> Unit = { element, oldIndex, index ->\r\n        val oldTransformedIndex = transformedIndex(oldIndex)\r\n        shift(oldIndex, -1)\r\n        shiftIncluding(index, 1)\r\n        oldTransformedIndex?.let {\r\n            indexList[it] = index\r\n        }\r\n        onSourceListMove(element, oldIndex, index)\r\n    }\r\n    val onListReplaceListener: (ObservableList<E>) -> Unit = {\r\n        refresh()\r\n    }\r\n    val onListRemoveListener: (E, Int) -> Unit = { element, index ->\r\n        val transformed = transformedIndex(index)\r\n        if (transformed != null) {\r\n            indexList.removeAt(transformed)\r\n        }\r\n        shift(index, -1)\r\n        if (transformed != null) {\r\n            onListRemove.invokeAll(element, transformed)\r\n            onListUpdate.update()\r\n        }\r\n        onSourceListRemove(element, index)\r\n    }\r\n\r\n\r\n    override fun enable() {\r\n        source.onListAdd.add(onListAddListener)\r\n        source.onListChange.add(onListChangeListener)\r\n        source.onListMove.add(onListMoveListener)\r\n        source.onListReplace.add(onListReplaceListener)\r\n        source.onListRemove.add(onListRemoveListener)\r\n    }\r\n\r\n    override fun disable() {\r\n        source.onListAdd.remove(onListAddListener)\r\n        source.onListChange.remove(onListChangeListener)\r\n        source.onListMove.remove(onListMoveListener)\r\n        source.onListReplace.remove(onListReplaceListener)\r\n        source.onListRemove.remove(onListRemoveListener)\r\n    }\r\n\r\n\r\n//    override fun set(index: Int, element: E): E {\r\n//        refreshIfNotActive()\r\n//        source[sourceIndex(index)] = element\r\n//        return element\r\n//    }\r\n//\r\n//    override fun add(index: Int, element: E): Unit {\r\n//        refreshIfNotActive()\r\n//        source.add(sourceIndex(index), element)\r\n//    }\r\n//    override fun addAll(index: Int, elements: Collection<E>): Boolean {\r\n//        refreshIfNotActive()\r\n//        return source.addAll(sourceIndex(index), elements)\r\n//    }\r\n//\r\n//    override fun move(fromIndex: Int, toIndex: Int) {\r\n//        refreshIfNotActive()\r\n//        source.move(sourceIndex(fromIndex), sourceIndex(toIndex))\r\n//    }\r\n//\r\n//    override fun removeAt(index: Int): E {\r\n//        refreshIfNotActive()\r\n//        return source.removeAt(sourceIndex(index))\r\n//    }\r\n//\r\n//    override fun replace(collection: Collection<E>) = source.replace(collection)\r\n\r\n    override fun isEmpty(): Boolean {\r\n        refreshIfNotActive()\r\n        return indexList.isEmpty()\r\n    }\r\n\r\n    override fun contains(element: E): Boolean {\r\n        refreshIfNotActive()\r\n        return indexList.contains(source.indexOf(element))\r\n    }\r\n\r\n    override fun containsAll(elements: Collection<E>): Boolean {\r\n        refreshIfNotActive()\r\n        return indexList.containsAll(elements.map { source.indexOf(it) })\r\n    }\r\n\r\n    override fun listIterator(index: Int): MutableListIterator<E> = object : MutableListIterator<E> {\r\n        init {\r\n            refreshIfNotActive()\r\n        }\r\n\r\n        val inner = indexList.listIterator(index)\r\n        override fun hasPrevious(): Boolean = inner.hasPrevious()\r\n        override fun nextIndex(): Int = inner.nextIndex()\r\n        override fun previous(): E = source[inner.previous()]\r\n        override fun previousIndex(): Int = inner.previousIndex()\r\n        override fun hasNext(): Boolean = inner.hasNext()\r\n        override fun next(): E = source[inner.next()]\r\n\r\n        override fun add(element: E) = throw UnsupportedOperationException()\r\n        override fun remove() = inner.remove()\r\n        override fun set(element: E) = throw UnsupportedOperationException()\r\n    }\r\n\r\n    override fun listIterator(): MutableListIterator<E> = listIterator(0)\r\n    override fun iterator(): MutableIterator<E> = listIterator(0)\r\n\r\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = throw UnsupportedOperationException()\r\n    override fun get(index: Int): E {\r\n        refreshIfNotActive()\r\n        return source[sourceIndex(index)]\r\n    }\r\n\r\n    override fun indexOf(element: E): Int {\r\n        refreshIfNotActive()\r\n        return indexList.indexOf(source.indexOf(element))\r\n    }\r\n\r\n    override fun lastIndexOf(element: E): Int {\r\n        refreshIfNotActive()\r\n        return indexList.lastIndexOf(source.lastIndexOf(element))\r\n    }\r\n\r\n    override val size: Int\r\n        get() {\r\n            refreshIfNotActive()\r\n            return indexList.size\r\n        }\r\n\r\n}\r\n","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\nimport com.lightningkite.reacktive.property.update\r\n\r\nfun <E> ObservableList<E>.firstOrNullObservable() = IndexObservableProperty(this, 0)\r\nfun <E> ObservableList<E>.indexOrNullObservable(index:Int) = IndexObservableProperty(this, index)\r\n\r\nclass IndexObservableProperty<T>(\r\n    val list: ObservableList<T>,\r\n    val watchIndex: Int = 0\r\n) : ObservableProperty<T?>, EnablingMutableCollection<(T?) -> Unit>() {\r\n    override val value: T? get() = list.lastOrNull()\r\n\r\n    val onListAdd = { element: T, index: Int ->\r\n        if (index <= watchIndex) {\r\n            update()\r\n        }\r\n    }\r\n    val onListRemove = { element: T, index: Int ->\r\n        if (index >= watchIndex) {\r\n            update()\r\n        }\r\n    }\r\n    val onListMove = { element: T, oldIndex: Int, newIndex: Int ->\r\n        if (watchIndex in oldIndex .. newIndex) {\r\n            update()\r\n        }\r\n    }\r\n    val onListChange = { oldElement: T, element: T, index: Int ->\r\n        if (index == watchIndex) {\r\n            update()\r\n        }\r\n    }\r\n    val onListReplace = { list: ObservableList<T> ->\r\n        update()\r\n    }\r\n\r\n    override fun enable() {\r\n        list.onListAdd.add(onListAdd)\r\n        list.onListRemove.add(onListRemove)\r\n        list.onListMove.add(onListMove)\r\n        list.onListChange.add(onListChange)\r\n        list.onListReplace.add(onListReplace)\r\n    }\r\n\r\n    override fun disable() {\r\n        list.onListAdd.remove(onListAdd)\r\n        list.onListRemove.remove(onListRemove)\r\n        list.onListMove.remove(onListMove)\r\n        list.onListChange.remove(onListChange)\r\n        list.onListReplace.remove(onListReplace)\r\n    }\r\n}","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\nimport com.lightningkite.reacktive.property.update\r\n\r\nfun <E> ObservableList<E>.lastOrNullObservable() = LastObservableProperty(this)\r\n\r\nclass LastObservableProperty<T>(\r\n    val list: ObservableList<T>\r\n) : ObservableProperty<T?>, EnablingMutableCollection<(T?) -> Unit>() {\r\n    override val value: T? get() = list.lastOrNull()\r\n\r\n    val onListAdd = { element: T, index: Int ->\r\n        if (index == list.lastIndex) {\r\n            update()\r\n        }\r\n    }\r\n    val onListRemove = { element: T, index: Int ->\r\n        if (index >= list.lastIndex) {\r\n            update()\r\n        }\r\n    }\r\n    val onListMove = { element: T, oldIndex: Int, newIndex: Int ->\r\n        if (newIndex == list.lastIndex) {\r\n            update()\r\n        }\r\n        if (oldIndex == list.lastIndex) {\r\n            update()\r\n        }\r\n    }\r\n    val onListChange = { oldElement: T, element: T, index: Int ->\r\n        if (index == list.lastIndex) {\r\n            update()\r\n        }\r\n    }\r\n    val onListReplace = { list: ObservableList<T> ->\r\n        update()\r\n    }\r\n\r\n    override fun enable() {\r\n        list.onListAdd.add(onListAdd)\r\n        list.onListRemove.add(onListRemove)\r\n        list.onListMove.add(onListMove)\r\n        list.onListChange.add(onListChange)\r\n        list.onListReplace.add(onListReplace)\r\n    }\r\n\r\n    override fun disable() {\r\n        list.onListAdd.remove(onListAdd)\r\n        list.onListRemove.remove(onListRemove)\r\n        list.onListMove.remove(onListMove)\r\n        list.onListChange.remove(onListChange)\r\n        list.onListReplace.remove(onListReplace)\r\n    }\r\n}","package com.lightningkite.reacktive.list\r\n\r\n\r\nimport com.lightningkite.reacktive.mapping.mapping\r\nimport com.lightningkite.reacktive.mapping.mappingMutable\r\nimport com.lightningkite.reacktive.mapping.mappingWriteOnly\r\nimport com.lightningkite.reacktive.property.transform\r\n\r\n/**\r\n * Gives you a view of an observable list where the entries have been mapped.\r\n *\r\n * Created by jivie on 5/6/16.\r\n */\r\nclass MappingMutableObservableList<S, E>(\r\n        val mutableSource: MutableObservableList<S>,\r\n        transform: (S) -> E,\r\n        reverse: (E) -> S\r\n) : MappingObservableList<S, E>(mutableSource, transform, reverse), MutableObservableList<E> {\r\n    override val size: Int get() = mutableSource.size\r\n\r\n    override fun add(element: E): Boolean = mutableSource.add(reverse(element))\r\n    override fun add(index: Int, element: E) = mutableSource.add(index, reverse(element))\r\n    override fun move(fromIndex: Int, toIndex: Int) = mutableSource.move(fromIndex, toIndex)\r\n    override fun addAll(index: Int, elements: Collection<E>): Boolean = mutableSource.addAll(index, elements.map(reverse))\r\n    override fun addAll(elements: Collection<E>): Boolean = mutableSource.addAll(elements.map(reverse))\r\n    override fun clear() = mutableSource.clear()\r\n    override fun remove(element: E): Boolean = mutableSource.remove(reverse(element))\r\n    override fun removeAll(elements: Collection<E>): Boolean = mutableSource.removeAll(elements.map(reverse))\r\n    override fun removeAt(index: Int): E = transform(mutableSource.removeAt(index))\r\n    override fun retainAll(elements: Collection<E>): Boolean = mutableSource.retainAll(elements.map(reverse))\r\n    override fun set(index: Int, element: E): E = transform(mutableSource.set(index, reverse(element)))\r\n\r\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = mutableSource.subList(fromIndex, toIndex).map(transform).toMutableList()\r\n    override fun listIterator(): MutableListIterator<E> = mutableSource.listIterator().mapping(transform, reverse)\r\n    override fun listIterator(index: Int): MutableListIterator<E> = mutableSource.listIterator(index).mapping(transform, reverse)\r\n    override fun iterator(): MutableIterator<E> = mutableSource.iterator().mappingMutable(transform)\r\n    override fun replace(collection: Collection<E>) = mutableSource.replace(collection.map(reverse))\r\n}\r\n\r\nfun <S, E> MutableObservableList<S>.mapping(read: (S) -> E, write: (E) -> S): MappingMutableObservableList<S, E> = MappingMutableObservableList(this, read, write)\r\nfun <S, E> MutableObservableList<S>.mapping(read: (S) -> E): MappingMutableObservableList<S, E> = MappingMutableObservableList(this, read) { throw IllegalArgumentException() }\r\n","package com.lightningkite.reacktive.list\r\n\r\n\r\nimport com.lightningkite.reacktive.mapping.mapping\r\nimport com.lightningkite.reacktive.mapping.mappingWriteOnly\r\nimport com.lightningkite.reacktive.property.transform\r\n\r\n/**\r\n * Gives you a view of an observable list where the entries have been mapped.\r\n *\r\n * Created by jivie on 5/6/16.\r\n */\r\nopen class MappingObservableList<S, E>(val source: ObservableList<S>, val transform: (S) -> E, val reverse: (E) -> S) : ObservableList<E> {\r\n    override val size: Int get() = source.size\r\n\r\n    override fun contains(element: E): Boolean = source.contains(reverse(element))\r\n    override fun containsAll(elements: Collection<E>): Boolean = source.containsAll(elements.map(reverse))\r\n    override fun get(index: Int): E = transform(source.get(index))\r\n    override fun indexOf(element: E): Int = source.indexOf(reverse(element))\r\n    override fun isEmpty(): Boolean = source.isEmpty()\r\n    override fun lastIndexOf(element: E): Int = source.lastIndexOf(reverse(element))\r\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = source.subList(fromIndex, toIndex).map(transform).toMutableList()\r\n\r\n    override fun listIterator(): ListIterator<E> = source.listIterator().mapping(transform)\r\n    override fun listIterator(index: Int): ListIterator<E> = source.listIterator(index).mapping(transform)\r\n    override fun iterator(): Iterator<E> = source.iterator().mapping(transform)\r\n\r\n    val listenerMapper = { input: (E, Int) -> Unit ->\r\n        { element: S, index: Int ->\r\n            input(transform(element), index)\r\n        }\r\n    }\r\n    override val onListAdd: MutableCollection<(E, Int) -> Unit> = source.onListAdd.mappingWriteOnly(listenerMapper)\r\n    override val onListRemove: MutableCollection<(E, Int) -> Unit> = source.onListRemove.mappingWriteOnly(listenerMapper)\r\n    override val onListMove: MutableCollection<(E, Int, Int) -> Unit> = source.onListMove.mappingWriteOnly { input: (E, Int, Int) -> Unit ->\r\n        { element: S, oldIndex: Int, index: Int ->\r\n            input(transform(element), oldIndex, index)\r\n        }\r\n    }\r\n    override val onListChange: MutableCollection<(E, E, Int) -> Unit> = source.onListChange.mappingWriteOnly { input: (E, E, Int) -> Unit ->\r\n        { old: S, element: S, index: Int ->\r\n            input(transform(old), transform(element), index)\r\n        }\r\n    }\r\n\r\n    override val onListUpdate = source.onListUpdate.transform<ObservableList<S>, ObservableList<E>> { _ -> this@MappingObservableList }\r\n    override val onListReplace: MutableCollection<(ObservableList<E>) -> Unit> = source.onListReplace.mappingWriteOnly { input -> { input(this) } }\r\n}\r\n\r\nfun <S, E> ObservableList<S>.mapping(read: (S) -> E, write: (E) -> S) = MappingObservableList(this, read, write)\r\nfun <S, E> ObservableList<S>.mapping(read: (S) -> E) = MappingObservableList(this, read) { throw IllegalArgumentException() }\r\n","package com.lightningkite.reacktive.list\r\n\r\n\r\nimport com.lightningkite.reacktive.collection.MutableObservableCollection\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\n\r\n/**\r\n * Allows you to observe the changes to a list.\r\n * Created by josep on 9/7/2015.\r\n */\r\ninterface MutableObservableList<E> : MutableList<E>, ObservableList<E>, MutableObservableCollection<E> {\r\n\r\n    override fun change(old: E, new: E) {\r\n        set(indexOf(old), new)\r\n    }\r\n\r\n    fun move(fromIndex: Int, toIndex: Int)\r\n    fun updateAt(index: Int) {\r\n        this[index] = this[index]\r\n    }\r\n\r\n    fun update(element: E): Boolean {\r\n        val index = indexOf(element)\r\n        if (index != -1)\r\n            updateAt(index)\r\n        return index != -1\r\n    }\r\n}\r\n","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.invokeAll\r\nimport com.lightningkite.reacktive.property.*\r\n\r\nclass MutableObservableListFromProperty<E>(val property: MutableObservableProperty<List<E>>) : EnablingObservableList<E>(), MutableObservableList<E> {\r\n\r\n    val collection = MutableListFromProperty<E>(property)\r\n    var updateFromUs = false\r\n\r\n    override fun set(index: Int, element: E): E {\r\n        val old = collection[index]\r\n        updateFromUs = true\r\n        collection[index] = element\r\n        onListChange.invokeAll(old, element, index)\r\n        onListUpdate.update()\r\n        return element\r\n    }\r\n\r\n    override fun add(element: E): Boolean {\r\n        updateFromUs = true\r\n        val result = collection.add(element)\r\n        val index = collection.size - 1\r\n        if (result) {\r\n            onListAdd.invokeAll(element, index)\r\n            onListUpdate.update()\r\n        }\r\n        return result\r\n    }\r\n\r\n    override fun add(index: Int, element: E) {\r\n        updateFromUs = true\r\n        collection.add(index, element)\r\n        onListAdd.invokeAll(element, index)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    override fun addAll(elements: Collection<E>): Boolean {\r\n        var index = collection.size\r\n        for (e in elements) {\r\n            updateFromUs = true\r\n            collection.add(e)\r\n            onListAdd.invokeAll(e, index)\r\n            index++\r\n        }\r\n        onListUpdate.update()\r\n        return true\r\n    }\r\n\r\n    override fun addAll(index: Int, elements: Collection<E>): Boolean {\r\n        var currentIndex = index\r\n        for (e in elements) {\r\n            updateFromUs = true\r\n            collection.add(currentIndex, e)\r\n            onListAdd.invokeAll(e, currentIndex)\r\n            currentIndex++\r\n        }\r\n        onListUpdate.update()\r\n        return true\r\n    }\r\n\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    override fun remove(element: E): Boolean {\r\n        val index = indexOf(element)\r\n        if (index == -1) return false\r\n        updateFromUs = true\r\n        collection.removeAt(index)\r\n        onListRemove.invokeAll(element, index)\r\n        onListUpdate.update()\r\n        return true\r\n    }\r\n\r\n    override fun removeAt(index: Int): E {\r\n        updateFromUs = true\r\n        val element = collection.removeAt(index)\r\n        onListRemove.invokeAll(element, index)\r\n        onListUpdate.update()\r\n        return element\r\n    }\r\n\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    override fun removeAll(elements: Collection<E>): Boolean {\r\n        for (element in elements) {\r\n            val index = indexOf(element)\r\n            if (index == -1) return false\r\n            updateFromUs = true\r\n            collection.removeAt(index)\r\n            onListRemove.invokeAll(element, index)\r\n        }\r\n        onListUpdate.update()\r\n        return true\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<E>): Boolean {\r\n        throw UnsupportedOperationException()\r\n    }\r\n\r\n    override fun clear() {\r\n        updateFromUs = true\r\n        collection.clear()\r\n        onListReplace.invokeAll(this)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    override fun isEmpty(): Boolean = collection.isEmpty()\r\n    override fun contains(element: E): Boolean = collection.contains(element)\r\n    override fun containsAll(elements: Collection<E>): Boolean = collection.containsAll(elements)\r\n    override fun listIterator(): MutableListIterator<E> = listIterator(0)\r\n    override fun listIterator(index: Int): MutableListIterator<E> = object : MutableListIterator<E> {\r\n\r\n        val inner = collection.listIterator(index)\r\n        var cursor: Int = index\r\n        var lastIndex: Int = -1\r\n        var lastElement: E? = null\r\n\r\n        override fun add(element: E) {\r\n            updateFromUs = true\r\n            inner.add(element)\r\n            onListRemove.invokeAll(lastElement!!, cursor)\r\n            cursor++\r\n            lastIndex = -1\r\n            onListUpdate.update()\r\n        }\r\n\r\n        override fun hasPrevious(): Boolean = inner.hasPrevious()\r\n\r\n        override fun nextIndex(): Int = cursor\r\n\r\n        override fun previous(): E {\r\n            val element = inner.previous()\r\n            lastElement = element\r\n            lastIndex = cursor\r\n            cursor--\r\n            return element\r\n        }\r\n\r\n        override fun previousIndex(): Int = cursor - 1\r\n\r\n        override fun set(element: E) {\r\n            updateFromUs = true\r\n            inner.set(element)\r\n            onListChange.invokeAll(lastElement!!, element, lastIndex)\r\n            onListUpdate.update()\r\n        }\r\n        override fun hasNext(): Boolean = inner.hasNext()\r\n        override fun next(): E {\r\n            val element = inner.next()\r\n            lastElement = element\r\n            lastIndex = cursor\r\n            cursor++\r\n            return element\r\n        }\r\n\r\n        override fun remove() {\r\n            if (lastIndex == -1) throw IllegalStateException()\r\n            updateFromUs = true\r\n            inner.remove()\r\n            onListRemove.invokeAll(lastElement!!, lastIndex)\r\n            onListUpdate.update()\r\n            cursor = lastIndex\r\n            lastIndex = -1\r\n        }\r\n\r\n    }\r\n\r\n    override fun iterator(): MutableIterator<E> = listIterator(0)\r\n\r\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = collection.subList(fromIndex, toIndex)\r\n    override fun get(index: Int): E = collection[index]\r\n    override fun indexOf(element: E): Int = collection.indexOf(element)\r\n    override fun lastIndexOf(element: E): Int = collection.lastIndexOf(element)\r\n    override val size: Int get() = collection.size\r\n\r\n    override fun replace(collection: Collection<E>) {\r\n        updateFromUs = true\r\n        this.collection.clear()\r\n        updateFromUs = true\r\n        this.collection.addAll(collection)\r\n        onListReplace.invokeAll(this)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    override fun move(fromIndex: Int, toIndex: Int) {\r\n        updateFromUs = true\r\n        val item = collection.removeAt(fromIndex)\r\n        updateFromUs = true\r\n        collection.add(toIndex, item)\r\n        onListMove.invokeAll(item, fromIndex, toIndex)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    val listener = label@{ list: List<E> ->\r\n        if(updateFromUs){\r\n            updateFromUs = false\r\n            return@label\r\n        }\r\n        onListReplace.invokeAll(this)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    override fun enable() {\r\n        property.add(listener)\r\n    }\r\n\r\n    override fun disable() {\r\n        property.remove(listener)\r\n    }\r\n\r\n    override fun refresh() {\r\n        listener(property.value)\r\n    }\r\n}","package com.lightningkite.reacktive.list\r\n\r\n\r\nimport com.lightningkite.reacktive.mapping.mappingWriteOnly\r\nimport com.lightningkite.reacktive.collection.ObservableCollection\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\nimport com.lightningkite.reacktive.property.transform\r\n\r\n/**\r\n * Allows you to observe the changes to a list.\r\n * Created by josep on 9/7/2015.\r\n */\r\ninterface ObservableList<E> : List<E>, ObservableCollection<E> {\r\n    val onListAdd: MutableCollection<(E, Int) -> Unit>\r\n    val onListChange: MutableCollection<(E, E, Int) -> Unit>\r\n    val onListMove: MutableCollection<(E, Int, Int) -> Unit>\r\n    val onListRemove: MutableCollection<(E, Int) -> Unit>\r\n    val onListReplace: MutableCollection<(ObservableList<E>) -> Unit>\r\n    val onListUpdate: ObservableProperty<ObservableList<E>>\r\n\r\n    override val onCollectionAdd: MutableCollection<(value: E) -> Unit> get() = onListAdd.mappingWriteOnly { callback ->\r\n        { item, index -> callback.invoke(item) }\r\n    }\r\n    override val onCollectionChange: MutableCollection<(old: E, new: E) -> Unit> get() = onListChange.mappingWriteOnly { callback ->\r\n        { old, item, index -> callback.invoke(old, item) }\r\n    }\r\n    override val onCollectionRemove: MutableCollection<(value: E) -> Unit> get() = onListRemove.mappingWriteOnly { callback ->\r\n        { item, index -> callback.invoke(item) }\r\n    }\r\n    override val onCollectionUpdate: ObservableProperty<ObservableCollection<E>> get() = onListUpdate.transform { this }\r\n    override val onCollectionReplace: MutableCollection<(ObservableCollection<E>) -> Unit> get() = onListReplace.mappingWriteOnly { callback ->\r\n        { list -> callback.invoke(this) }\r\n    }\r\n}\r\n","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.mapping.asMutable\r\n\r\n/**\r\n * Makes an observable collection mutable.\r\n * Meant to be used in temporary function calls to reduce the number of classes\r\n */\r\nclass ObservableListAsMutable<V>(val source:ObservableList<V>) : MutableObservableList<V>, ObservableList<V> by source {\r\n    override fun add(index: Int, element: V) {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun addAll(index: Int, elements: Collection<V>): Boolean {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun move(fromIndex: Int, toIndex: Int) {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun removeAt(index: Int): V {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun set(index: Int, element: V): V {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun change(old: V, new: V) {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun replace(collection: Collection<V>) {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun add(element: V): Boolean {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun addAll(elements: Collection<V>): Boolean {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun clear() {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun remove(element: V): Boolean {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun removeAll(elements: Collection<V>): Boolean {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<V>): Boolean {\r\n        throw UnsupportedOperationException(\"The underlying collection is not mutable.\")\r\n    }\r\n\r\n    override fun iterator(): MutableIterator<V> = source.iterator().asMutable()\r\n    override fun listIterator(): MutableListIterator<V> = source.listIterator().asMutable()\r\n    override fun listIterator(index: Int): MutableListIterator<V> = source.listIterator(index).asMutable()\r\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<V> = source.subList(fromIndex, toIndex).toMutableList()\r\n}\r\n\r\nfun <V> ObservableList<V>.asMutable():MutableObservableList<V> = ObservableListAsMutable(this)\r\n\r\n","package com.lightningkite.reacktive.list\r\n\r\nimport com.lightningkite.reacktive.invokeAll\r\nimport com.lightningkite.reacktive.property.MutableObservableProperty\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\nimport com.lightningkite.reacktive.property.update\r\n\r\nclass ObservableListFromProperty<E>(val property: ObservableProperty<List<E>>) : EnablingObservableList<E>() {\r\n    override val size: Int\r\n        get() = property.value.size\r\n\r\n    override fun contains(element: E): Boolean = property.value.contains(element)\r\n\r\n    override fun containsAll(elements: Collection<E>): Boolean = property.value.containsAll(elements)\r\n\r\n    override fun get(index: Int): E = property.value.get(index)\r\n\r\n    override fun indexOf(element: E): Int = property.value.indexOf(element)\r\n\r\n    override fun isEmpty(): Boolean = property.value.isEmpty()\r\n\r\n    override fun iterator(): Iterator<E> = property.value.iterator()\r\n\r\n    override fun lastIndexOf(element: E): Int = property.value.lastIndexOf(element)\r\n\r\n    override fun listIterator(): ListIterator<E> = property.value.listIterator()\r\n\r\n    override fun listIterator(index: Int): ListIterator<E> = property.value.listIterator(index)\r\n\r\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = property.value.subList(fromIndex, toIndex)\r\n\r\n    val listener = { list: List<E> ->\r\n        onListReplace.invokeAll(this)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    override fun enable() {\r\n        property.add(listener)\r\n    }\r\n\r\n    override fun disable() {\r\n        property.remove(listener)\r\n    }\r\n\r\n    override fun refresh() {\r\n        listener(property.value)\r\n    }\r\n}","package com.lightningkite.reacktive.list\r\n\r\n\r\nimport com.lightningkite.reacktive.invokeAll\r\nimport com.lightningkite.reacktive.property.ReferenceObservableProperty\r\nimport com.lightningkite.reacktive.property.update\r\n\r\n/**\r\n * Allows you to observe the changes to a list.\r\n * Created by josep on 9/7/2015.\r\n */\r\nclass WrapperObservableList<E>(\r\n        val collection: MutableList<E> = mutableListOf()\r\n) : MutableObservableList<E> {\r\n\r\n    override val onListAdd = HashSet<(E, Int) -> Unit>()\r\n    override val onListChange = HashSet<(E, E, Int) -> Unit>()\r\n    override val onListMove = HashSet<(E, Int, Int) -> Unit>()\r\n    override val onListUpdate = ReferenceObservableProperty<ObservableList<E>>({ this@WrapperObservableList }, { replace(it) })\r\n    override val onListReplace = HashSet<(ObservableList<E>) -> Unit>()\r\n    override val onListRemove = HashSet<(E, Int) -> Unit>()\r\n\r\n    override fun set(index: Int, element: E): E {\r\n        val old = collection[index]\r\n        collection[index] = element\r\n        onListChange.invokeAll(old, element, index)\r\n        onListUpdate.update()\r\n        return element\r\n    }\r\n\r\n    override fun add(element: E): Boolean {\r\n        val result = collection.add(element)\r\n        val index = collection.size - 1\r\n        if (result) {\r\n            onListAdd.invokeAll(element, index)\r\n            onListUpdate.update()\r\n        }\r\n        return result\r\n    }\r\n\r\n    override fun add(index: Int, element: E) {\r\n        collection.add(index, element)\r\n        onListAdd.invokeAll(element, index)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    override fun addAll(elements: Collection<E>): Boolean {\r\n        var index = collection.size\r\n        for (e in elements) {\r\n            collection.add(e)\r\n            onListAdd.invokeAll(e, index)\r\n            index++\r\n        }\r\n        onListUpdate.update()\r\n        return true\r\n    }\r\n\r\n    override fun addAll(index: Int, elements: Collection<E>): Boolean {\r\n        var currentIndex = index\r\n        for (e in elements) {\r\n            collection.add(currentIndex, e)\r\n            onListAdd.invokeAll(e, currentIndex)\r\n            currentIndex++\r\n        }\r\n        onListUpdate.update()\r\n        return true\r\n    }\r\n\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    override fun remove(element: E): Boolean {\r\n        val index = indexOf(element)\r\n        if (index == -1) return false\r\n        collection.removeAt(index)\r\n        onListRemove.invokeAll(element, index)\r\n        onListUpdate.update()\r\n        return true\r\n    }\r\n\r\n    override fun removeAt(index: Int): E {\r\n        val element = collection.removeAt(index)\r\n        onListRemove.invokeAll(element, index)\r\n        onListUpdate.update()\r\n        return element\r\n    }\r\n\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    override fun removeAll(elements: Collection<E>): Boolean {\r\n        for (element in elements) {\r\n            val index = indexOf(element)\r\n            if (index == -1) return false\r\n            collection.removeAt(index)\r\n            onListRemove.invokeAll(element, index)\r\n        }\r\n        onListUpdate.update()\r\n        return true\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<E>): Boolean {\r\n        throw UnsupportedOperationException()\r\n    }\r\n\r\n    override fun clear() {\r\n        collection.clear()\r\n        onListReplace.invokeAll(this)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    override fun isEmpty(): Boolean = collection.isEmpty()\r\n    override fun contains(element: E): Boolean = collection.contains(element)\r\n    override fun containsAll(elements: Collection<E>): Boolean = collection.containsAll(elements)\r\n    override fun listIterator(): MutableListIterator<E> = listIterator(0)\r\n    override fun listIterator(index: Int): MutableListIterator<E> = object : MutableListIterator<E> {\r\n\r\n        val inner = collection.listIterator(index)\r\n        var cursor: Int = index\r\n        var lastIndex: Int = -1\r\n        var lastElement: E? = null\r\n\r\n        override fun add(element: E) {\r\n            inner.add(element)\r\n            onListRemove.invokeAll(lastElement!!, cursor)\r\n            cursor++\r\n            lastIndex = -1\r\n            onListUpdate.update()\r\n        }\r\n\r\n        override fun hasPrevious(): Boolean = inner.hasPrevious()\r\n\r\n        override fun nextIndex(): Int = cursor\r\n\r\n        override fun previous(): E {\r\n            val element = inner.previous()\r\n            lastElement = element\r\n            lastIndex = cursor\r\n            cursor--\r\n            return element\r\n        }\r\n\r\n        override fun previousIndex(): Int = cursor - 1\r\n\r\n        override fun set(element: E) {\r\n            inner.set(element)\r\n            onListChange.invokeAll(lastElement!!, element, lastIndex)\r\n            onListUpdate.update()\r\n        }\r\n        override fun hasNext(): Boolean = inner.hasNext()\r\n        override fun next(): E {\r\n            val element = inner.next()\r\n            lastElement = element\r\n            lastIndex = cursor\r\n            cursor++\r\n            return element\r\n        }\r\n\r\n        override fun remove() {\r\n            if (lastIndex == -1) throw IllegalStateException()\r\n            inner.remove()\r\n            onListRemove.invokeAll(lastElement!!, lastIndex)\r\n            onListUpdate.update()\r\n            cursor = lastIndex\r\n            lastIndex = -1\r\n        }\r\n\r\n    }\r\n\r\n    override fun iterator(): MutableIterator<E> = listIterator(0)\r\n\r\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = collection.subList(fromIndex, toIndex)\r\n    override fun get(index: Int): E = collection[index]\r\n    override fun indexOf(element: E): Int = collection.indexOf(element)\r\n    override fun lastIndexOf(element: E): Int = collection.lastIndexOf(element)\r\n    override val size: Int get() = collection.size\r\n\r\n    override fun replace(collection: Collection<E>) {\r\n        this.collection.clear()\r\n        this.collection.addAll(collection)\r\n        onListReplace.invokeAll(this)\r\n        onListUpdate.update()\r\n    }\r\n\r\n    override fun move(fromIndex: Int, toIndex: Int) {\r\n        val item = collection.removeAt(fromIndex)\r\n        collection.add(toIndex, item)\r\n        onListMove.invokeAll(item, fromIndex, toIndex)\r\n        onListUpdate.update()\r\n    }\r\n}\r\n\r\nfun <E> MutableList<E>.observable() = WrapperObservableList(this)\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package com.lightningkite.reacktive.map\r\n\r\nimport com.lightningkite.reacktive.EnablingObject\r\nimport com.lightningkite.reacktive.collection.MutableObservableCollection\r\nimport com.lightningkite.reacktive.collection.ObservableCollection\r\nimport com.lightningkite.reacktive.invokeAll\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\nimport com.lightningkite.reacktive.property.ReferenceObservableProperty\r\nimport com.lightningkite.reacktive.property.update\r\n\r\nclass GroupingObservableMap<K, E>(\r\n        val source: ObservableCollection<E>,\r\n        val getKey: (E) -> K\r\n) : ObservableMap<K, InnerCollection<E>>, EnablingObject() {\r\n\r\n    inner class OnUpdateClass : ObservableProperty<ObservableMap<K, InnerCollection<E>>>, MutableCollection<(ObservableMap<K, InnerCollection<E>>) -> Unit> by this.SubEnablingCollection() {\r\n        override val value: ObservableMap<K, InnerCollection<E>>\r\n            get() = this@GroupingObservableMap\r\n\r\n        fun update() {\r\n            for (item in this) {\r\n                item.invoke(this@GroupingObservableMap)\r\n            }\r\n        }\r\n    }\r\n\r\n    override val onMapPut: MutableCollection<(key: K, hadPrevious: Boolean, previous: InnerCollection<E>?, new: InnerCollection<E>) -> Unit> = this.SubEnablingCollection()\r\n    override val onMapRemove: MutableCollection<(key: K, value: InnerCollection<E>) -> Unit> = this.SubEnablingCollection()\r\n    override val onMapUpdate: OnUpdateClass = OnUpdateClass()\r\n    override val onMapReplace: MutableCollection<(ObservableMap<K, InnerCollection<E>>) -> Unit> = this.SubEnablingCollection()\r\n\r\n    override val entries = EntryObservableSet(\r\n            parent = this,\r\n            nonObservableEntryIterator = {underlying.entries.iterator()}\r\n    )\r\n    override val keys = KeyObservableSet(\r\n            parent = this,\r\n            nonObservableEntryIterator = {underlying.entries.iterator()}\r\n    )\r\n    override val values = ValueObservableSet(\r\n            parent = this,\r\n            nonObservableEntryIterator = {underlying.entries.iterator()}\r\n    )\r\n\r\n    val underlying = HashMap<K, InnerCollection<E>>()\r\n\r\n    override val size: Int\r\n        get() {\r\n            this.refreshIfNotActive()\r\n            return underlying.size\r\n        }\r\n\r\n    override fun containsKey(key: K): Boolean {\r\n        this.refreshIfNotActive()\r\n        return underlying.containsKey(key)\r\n    }\r\n\r\n    override fun containsValue(value: InnerCollection<E>): Boolean {\r\n        this.refreshIfNotActive()\r\n        return underlying.containsValue(value)\r\n    }\r\n\r\n    override fun get(key: K): InnerCollection<E>? {\r\n        this.refreshIfNotActive()\r\n        return underlying.get(key)\r\n    }\r\n\r\n    override fun isEmpty(): Boolean {\r\n        this.refreshIfNotActive()\r\n        return underlying.isEmpty()\r\n    }\r\n\r\n    private fun grab(key: K) = underlying[key] ?: run {\r\n        val new = InnerCollection(this, ArrayList<E>())\r\n        underlying[key] = new\r\n        onMapPut.invokeAll(key, false, null, new)\r\n        onMapUpdate.update()\r\n        new\r\n    }\r\n\r\n\r\n    val onCollectionAddListener: (value: E) -> Unit = {\r\n        grab(it.let(getKey)).add(it)\r\n    }\r\n    val onCollectionChangeListener: (old: E, new: E) -> Unit = { old, new ->\r\n        var oldKey = old.let(getKey)\r\n        if(old !in grab(oldKey)){\r\n            //Find where it actually is.\r\n            //This is necessary to handle mutations that aren't part of the event system.\r\n            oldKey = underlying.entries.first { old in it.value }.key\r\n        }\r\n        val newKey = new.let(getKey)\r\n        if (oldKey == newKey) {\r\n            grab(newKey).change(old, new)\r\n        } else {\r\n            if(!grab(oldKey).remove(old)) throw IllegalStateException()\r\n            grab(newKey).add(new)\r\n        }\r\n    }\r\n    val onCollectionRemoveListener: (value: E) -> Unit = { value ->\r\n        val key = value.let(getKey)\r\n        grab(key).let {\r\n            if(!it.remove(value)) throw IllegalStateException()\r\n            if (it.isEmpty()) {\r\n                underlying.remove(key)\r\n                onMapRemove.invokeAll(key, it)\r\n                onMapUpdate.update()\r\n            }\r\n        }\r\n    }\r\n    val onCollectionReplaceListener: (ObservableCollection<E>) -> Unit = {}\r\n\r\n    override fun enable() {\r\n        source.onCollectionAdd.add(onCollectionAddListener)\r\n        source.onCollectionChange.add(onCollectionChangeListener)\r\n        source.onCollectionRemove.add(onCollectionRemoveListener)\r\n        source.onCollectionReplace.add(onCollectionReplaceListener)\r\n    }\r\n\r\n    override fun disable() {\r\n        source.onCollectionAdd.remove(onCollectionAddListener)\r\n        source.onCollectionChange.remove(onCollectionChangeListener)\r\n        source.onCollectionRemove.remove(onCollectionRemoveListener)\r\n        source.onCollectionReplace.remove(onCollectionReplaceListener)\r\n    }\r\n\r\n    override fun refresh() {\r\n        val grouped = source.groupBy(getKey)\r\n        for ((key, collection) in grouped) {\r\n            grab(key).replace(collection)\r\n        }\r\n        for (key in underlying.keys) {\r\n            underlying[key]?.let {\r\n                if (it.isEmpty()) {\r\n                    underlying.remove(key)\r\n                }\r\n            }\r\n        }\r\n        onMapReplace.invokeAll(this)\r\n        onMapUpdate.update()\r\n    }\r\n}\r\n\r\nfun <K, E> ObservableCollection<E>.groupingBy(\r\n        getKey: (E) -> K\r\n) = GroupingObservableMap(this, getKey)\r\n\r\n\r\nclass InnerCollection<E>(val enablingObject: EnablingObject, val wraps: MutableCollection<E>) : MutableObservableCollection<E> {\r\n    override val size: Int get() = wraps.size\r\n    override fun contains(element: E): Boolean = wraps.contains(element)\r\n    override fun containsAll(elements: Collection<E>): Boolean = wraps.containsAll(elements)\r\n    override fun isEmpty(): Boolean = wraps.isEmpty()\r\n    override fun add(element: E): Boolean {\r\n        return if (wraps.add(element)) {\r\n            onCollectionAdd.invokeAll(element)\r\n            onCollectionUpdate.update()\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    }\r\n\r\n    override fun change(old: E, new: E) {\r\n        if(!wraps.remove(old)) throw IllegalStateException(\"Change attempted, but $old was not in the collection.\")\r\n        wraps.add(new)\r\n        onCollectionChange.invokeAll(old, new)\r\n        onCollectionUpdate.update()\r\n    }\r\n\r\n    override fun addAll(elements: Collection<E>): Boolean {\r\n        var added = false\r\n        for (element in elements) {\r\n            added = added || add(element)\r\n        }\r\n        return added\r\n    }\r\n\r\n    override fun clear() {\r\n        wraps.clear()\r\n        onCollectionReplace.invokeAll(this)\r\n        onCollectionUpdate.update()\r\n    }\r\n\r\n    override fun iterator(): MutableIterator<E> = object : MutableIterator<E> {\r\n\r\n        val underlying = wraps.iterator()\r\n        var last: E? = null\r\n\r\n        override fun hasNext(): Boolean = underlying.hasNext()\r\n\r\n        override fun next(): E {\r\n            val n = underlying.next()\r\n            last = n\r\n            return n\r\n        }\r\n\r\n        override fun remove() {\r\n            underlying.remove()\r\n            @Suppress(\"UNCHECKED_CAST\")\r\n            onCollectionRemove.invokeAll(last as E)\r\n            onCollectionUpdate.update()\r\n        }\r\n    }\r\n\r\n    override fun remove(element: E): Boolean {\r\n        return if (wraps.remove(element)) {\r\n            onCollectionRemove.invokeAll(element)\r\n            onCollectionUpdate.update()\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    }\r\n\r\n    override fun removeAll(elements: Collection<E>): Boolean {\r\n        var removed = false\r\n        for (element in elements) {\r\n            removed = removed || remove(element)\r\n        }\r\n        return removed\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<E>): Boolean {\r\n        return if (wraps.retainAll(elements)) {\r\n            onCollectionReplace.invokeAll(this)\r\n            onCollectionUpdate.update()\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    }\r\n\r\n    override fun replace(collection: Collection<E>) {\r\n        wraps.clear()\r\n        wraps.addAll(collection)\r\n        onCollectionReplace.invokeAll(this)\r\n        onCollectionUpdate.update()\r\n    }\r\n\r\n    override val onCollectionAdd: MutableCollection<(value: E) -> Unit> = enablingObject.SubEnablingCollection()\r\n    override val onCollectionChange: MutableCollection<(old: E, new: E) -> Unit> = enablingObject.SubEnablingCollection()\r\n    override val onCollectionRemove: MutableCollection<(value: E) -> Unit> = enablingObject.SubEnablingCollection()\r\n    override val onCollectionUpdate = ReferenceObservableProperty<ObservableCollection<E>>({ this@InnerCollection }, { replace(it) })\r\n    override val onCollectionReplace: MutableCollection<(ObservableCollection<E>) -> Unit> = enablingObject.SubEnablingCollection()\r\n}\r\n","package com.lightningkite.reacktive.map\r\n\r\nimport com.lightningkite.reacktive.mapping.mappingWriteOnly\r\nimport com.lightningkite.reacktive.collection.ObservableCollection\r\nimport com.lightningkite.reacktive.invokeAll\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\nimport com.lightningkite.reacktive.property.transform\r\nimport com.lightningkite.reacktive.set.MutableObservableSet\r\n\r\n\r\nprivate data class MutableDummyEntry<K, V>(val parent: MutableMap<K, V>, override val key: K, override val value: V) : MutableMap.MutableEntry<K, V> {\r\n    override fun setValue(newValue: V): V {\r\n        val old = value\r\n        parent[key] = newValue\r\n        return old\r\n    }\r\n}\r\n\r\nclass MutableEntryObservableSet<K, V>(\r\n        val parent: MutableObservableMap<K, V>,\r\n        val nonObservableEntryIterator: () -> MutableIterator<MutableMap.MutableEntry<K, V>>\r\n) : MutableObservableSet<MutableMap.MutableEntry<K, V>> {\r\n    override val size: Int get() = parent.size\r\n\r\n    override fun contains(element: MutableMap.MutableEntry<K, V>): Boolean {\r\n        return parent[element.key] == element.value\r\n    }\r\n\r\n    override fun containsAll(elements: Collection<MutableMap.MutableEntry<K, V>>): Boolean {\r\n        return elements.all { contains(it) }\r\n    }\r\n\r\n    override fun isEmpty(): Boolean = parent.isEmpty()\r\n\r\n    override val onCollectionAdd: MutableCollection<(value: MutableMap.MutableEntry<K, V>) -> Unit> = parent.onMapPut.mappingWriteOnly { callback ->\r\n        { key, hadPrevious, previous, new -> if (!hadPrevious) callback.invoke(MutableDummyEntry(parent, key, new)) }\r\n    }\r\n    override val onCollectionChange: MutableCollection<(old: MutableMap.MutableEntry<K, V>, new: MutableMap.MutableEntry<K, V>) -> Unit> = parent.onMapPut.mappingWriteOnly { callback ->\r\n        { key, hadPrevious, previous, new -> if (hadPrevious) callback.invoke(MutableDummyEntry(parent, key, previous as V), MutableDummyEntry(parent, key, new)) }\r\n    }\r\n    override val onCollectionRemove: MutableCollection<(value: MutableMap.MutableEntry<K, V>) -> Unit> = parent.onMapRemove.mappingWriteOnly { callback ->\r\n        { key, previous -> callback.invoke(MutableDummyEntry(parent, key, previous)) }\r\n    }\r\n    override val onCollectionUpdate: ObservableProperty<ObservableCollection<MutableMap.MutableEntry<K, V>>> = parent.onMapUpdate.transform { this }\r\n    override val onCollectionReplace: MutableCollection<(ObservableCollection<MutableMap.MutableEntry<K, V>>) -> Unit> = parent.onMapReplace.mappingWriteOnly { callback ->\r\n        { callback.invoke(this) }\r\n    }\r\n\r\n\r\n    override fun replace(collection: Collection<MutableMap.MutableEntry<K, V>>)\r\n            = parent.replace(collection.associate { it.key to it.value })\r\n\r\n    override fun add(element: MutableMap.MutableEntry<K, V>): Boolean {\r\n        parent.put(element.key, element.value)\r\n        return true\r\n    }\r\n\r\n    override fun addAll(elements: Collection<MutableMap.MutableEntry<K, V>>): Boolean {\r\n        var changed = false\r\n        for (element in elements) {\r\n            changed = changed || add(element)\r\n        }\r\n        return changed\r\n    }\r\n\r\n    override fun clear() {\r\n        parent.clear()\r\n    }\r\n\r\n    override fun iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = object : MutableIterator<MutableMap.MutableEntry<K, V>> {\r\n        val underlying = nonObservableEntryIterator()\r\n        var last: MutableMap.MutableEntry<K, V>? = null\r\n        override fun hasNext(): Boolean = underlying.hasNext()\r\n        override fun next(): MutableMap.MutableEntry<K, V> {\r\n            val n = underlying.next()\r\n            last = n\r\n            return MutableDummyEntry(parent, n.key, n.value)\r\n        }\r\n\r\n        override fun remove() {\r\n            underlying.remove()\r\n            parent.onMapRemove.invokeAll(last!!.key, last!!.value)\r\n        }\r\n    }\r\n\r\n    override fun remove(element: MutableMap.MutableEntry<K, V>): Boolean {\r\n        return if (contains(element)) {\r\n            parent.remove(element.key)\r\n            true\r\n        } else false\r\n    }\r\n\r\n    override fun removeAll(elements: Collection<MutableMap.MutableEntry<K, V>>): Boolean {\r\n        var removed = false\r\n        for (element in elements) {\r\n            removed = removed || remove(element)\r\n        }\r\n        return removed\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<MutableMap.MutableEntry<K, V>>): Boolean {\r\n        throw UnsupportedOperationException()\r\n    }\r\n\r\n}\r\n\r\nclass MutableKeyObservableSet<K, V>(\r\n        val parent: MutableObservableMap<K, V>,\r\n        val nonObservableEntryIterator: () -> MutableIterator<MutableMap.MutableEntry<K, V>>\r\n) : MutableObservableSet<K> {\r\n    override val size: Int get() = parent.size\r\n\r\n    override fun contains(element: K): Boolean {\r\n        return parent.containsKey(element)\r\n    }\r\n\r\n    override fun containsAll(elements: Collection<K>): Boolean {\r\n        return elements.all { contains(it) }\r\n    }\r\n\r\n    override fun isEmpty(): Boolean = parent.isEmpty()\r\n\r\n\r\n\r\n\r\n    override fun replace(collection: Collection<K>) = throw UnsupportedOperationException()\r\n\r\n    override fun add(element: K): Boolean = throw UnsupportedOperationException()\r\n\r\n    override fun addAll(elements: Collection<K>): Boolean = throw UnsupportedOperationException()\r\n\r\n    override fun clear() {\r\n        parent.clear()\r\n    }\r\n\r\n    override fun iterator(): MutableIterator<K> = object : MutableIterator<K> {\r\n        val underlying = nonObservableEntryIterator()\r\n        var last: MutableMap.MutableEntry<K, V>? = null\r\n        override fun hasNext(): Boolean = underlying.hasNext()\r\n        override fun next(): K {\r\n            val n = underlying.next()\r\n            last = n\r\n            return n.key\r\n        }\r\n\r\n        override fun remove() {\r\n            underlying.remove()\r\n            parent.onMapRemove.invokeAll(last!!.key, last!!.value)\r\n        }\r\n    }\r\n\r\n    override fun remove(element: K): Boolean {\r\n        return if (parent.containsKey(element)) {\r\n            parent.remove(element)\r\n            true\r\n        } else false\r\n    }\r\n\r\n    override fun removeAll(elements: Collection<K>): Boolean {\r\n        var removed = false\r\n        for (element in elements) {\r\n            removed = removed || remove(element)\r\n        }\r\n        return removed\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<K>): Boolean {\r\n        throw UnsupportedOperationException()\r\n    }\r\n\r\n\r\n\r\n    override val onCollectionAdd: MutableCollection<(value: K) -> Unit> = parent.onMapPut.mappingWriteOnly { callback ->\r\n        { key, hadPrevious, previous, new -> if (!hadPrevious) callback.invoke(key) }\r\n    }\r\n    override val onCollectionChange: MutableCollection<(old: K, new: K) -> Unit> = ArrayList() //never happens\r\n    override val onCollectionRemove: MutableCollection<(value: K) -> Unit> = parent.onMapRemove.mappingWriteOnly { callback ->\r\n        { key, previous -> callback.invoke(key) }\r\n    }\r\n    override val onCollectionUpdate: ObservableProperty<ObservableCollection<K>> = parent.onMapUpdate.transform { this }\r\n    override val onCollectionReplace: MutableCollection<(ObservableCollection<K>) -> Unit> = parent.onMapReplace.mappingWriteOnly { callback ->\r\n        { callback.invoke(this) }\r\n    }\r\n\r\n}\r\n\r\nclass MutableValueObservableSet<K, V>(\r\n        val parent: MutableObservableMap<K, V>,\r\n        val nonObservableEntryIterator: () -> MutableIterator<MutableMap.MutableEntry<K, V>>\r\n) : MutableObservableSet<V> {\r\n    override val size: Int get() = parent.size\r\n\r\n    override fun contains(element: V): Boolean {\r\n        return parent.containsValue(element)\r\n    }\r\n\r\n    override fun containsAll(elements: Collection<V>): Boolean {\r\n        return elements.all { contains(it) }\r\n    }\r\n\r\n    override fun isEmpty(): Boolean = parent.isEmpty()\r\n\r\n    override fun replace(collection: Collection<V>) = throw UnsupportedOperationException()\r\n\r\n    override fun add(element: V): Boolean {\r\n        throw UnsupportedOperationException()\r\n    }\r\n\r\n    override fun addAll(elements: Collection<V>): Boolean {\r\n        throw UnsupportedOperationException()\r\n    }\r\n\r\n    override fun clear() {\r\n        parent.clear()\r\n    }\r\n\r\n    override fun iterator(): MutableIterator<V> = object : MutableIterator<V> {\r\n        val underlying = nonObservableEntryIterator()\r\n        var last: MutableMap.MutableEntry<K, V>? = null\r\n        override fun hasNext(): Boolean = underlying.hasNext()\r\n        override fun next(): V {\r\n            val n = underlying.next()\r\n            last = n\r\n            return n.value\r\n        }\r\n\r\n        override fun remove() {\r\n            underlying.remove()\r\n            parent.onMapRemove.invokeAll(last!!.key, last!!.value)\r\n        }\r\n    }\r\n\r\n    override fun remove(element: V): Boolean {\r\n        val keyFor = parent.keys.find { parent[it] == element }\r\n        return if (keyFor != null) {\r\n            parent.remove(keyFor)\r\n            true\r\n        } else false\r\n    }\r\n\r\n    override fun removeAll(elements: Collection<V>): Boolean {\r\n        //TODO: Can speed up\r\n        var removed = false\r\n        for (element in elements) {\r\n            removed = removed || remove(element)\r\n        }\r\n        return removed\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<V>): Boolean {\r\n        throw UnsupportedOperationException()\r\n    }\r\n\r\n    override val onCollectionAdd: MutableCollection<(value: V) -> Unit> = parent.onMapPut.mappingWriteOnly { callback ->\r\n        { key, hadPrevious, previous, new -> if (!hadPrevious) callback.invoke(new) }\r\n    }\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    override val onCollectionChange: MutableCollection<(old: V, new: V) -> Unit> = parent.onMapPut.mappingWriteOnly { callback ->\r\n        { key, hadPrevious, previous, new -> if (hadPrevious) callback.invoke(previous as V, new) }\r\n    }\r\n    @Suppress(\"UNCHECKED_CAST\")\r\n    override val onCollectionRemove: MutableCollection<(value: V) -> Unit> = object : MutableCollection<(V) -> Unit> {\r\n        override val size: Int get() = parent.onMapPut.size + parent.onMapRemove.size\r\n\r\n        val mapPut: MutableMap<(V) -> Unit, (K, Boolean, V?, V) -> Unit> = mutableMapOf()\r\n        val mapRemove: MutableMap<(V) -> Unit, (K, V) -> Unit> = mutableMapOf()\r\n\r\n        val mapperPut = { callback: (V) -> Unit ->\r\n            { _: K, wasRemoval: Boolean, removed: V?, _: V -> if (wasRemoval) callback.invoke(removed as V) }\r\n        }\r\n        val mapperRemove = { callback: (V) -> Unit ->\r\n            { _: K, removed: V -> callback.invoke(removed) }\r\n        }\r\n\r\n        override fun add(element: (V) -> Unit): Boolean {\r\n            val mapped = mapperPut(element)\r\n            mapPut[element] = mapped\r\n            parent.onMapPut.add(mapped)\r\n            val mapped2 = mapperRemove(element)\r\n            mapRemove[element] = mapped2\r\n            parent.onMapRemove.add(mapped2)\r\n            return true\r\n        }\r\n\r\n        override fun addAll(elements: Collection<(V) -> Unit>): Boolean {\r\n            elements.forEach { add(it) }\r\n            return true\r\n        }\r\n\r\n        override fun remove(element: (V) -> Unit): Boolean {\r\n            return parent.onMapPut.remove(mapPut.remove(element)) and parent.onMapRemove.remove(mapRemove.remove(element))\r\n        }\r\n\r\n        override fun removeAll(elements: Collection<(V) -> Unit>): Boolean {\r\n            elements.forEach { remove(it) }\r\n            return true\r\n        }\r\n\r\n        override fun retainAll(elements: Collection<(V) -> Unit>): Boolean = throw UnsupportedOperationException()\r\n\r\n        override fun contains(element: (V) -> Unit): Boolean = throw IllegalStateException(\"Not readable\")\r\n        override fun containsAll(elements: Collection<(V) -> Unit>): Boolean = throw IllegalStateException(\"Not readable\")\r\n        override fun isEmpty(): Boolean = throw IllegalStateException(\"Not readable\")\r\n        override fun clear() = throw IllegalStateException(\"Not readable\")\r\n        override fun iterator(): MutableIterator<(V) -> Unit> = throw IllegalStateException(\"Not readable\")\r\n\r\n    }\r\n    override val onCollectionUpdate: ObservableProperty<ObservableCollection<V>> = parent.onMapUpdate.transform { this }\r\n    override val onCollectionReplace: MutableCollection<(ObservableCollection<V>) -> Unit> = parent.onMapReplace.mappingWriteOnly { callback ->\r\n        { callback.invoke(this) }\r\n    }\r\n\r\n}\r\n","package com.lightningkite.reacktive.mapping\r\n\r\nimport kotlin.collections.*\r\n\r\n\r\n/**\r\n * Maps a collection to a different type for writing only.\r\n * Why is this important?  Because you can add and removed mapped listeners to an event using this!\r\n * See the example in the tests.\r\n *\r\n * Created by joseph on 12/14/16.\r\n */\r\nclass CollectionWriteOnlyMapping<S, E>(val source: MutableCollection<S>, val inputMapper: (E) -> S) : MutableCollection<E> {\r\n    val map: MutableMap<E, S> = mutableMapOf()\r\n\r\n    override val size: Int get() = source.size\r\n\r\n    override fun add(element: E): Boolean {\r\n        val mapped = inputMapper(element)\r\n        map[element] = mapped\r\n        return source.add(mapped)\r\n    }\r\n\r\n    override fun addAll(elements: Collection<E>): Boolean {\r\n        val mapped = elements.map(inputMapper)\r\n        map.putAll(elements.zip(mapped))\r\n        return source.addAll(mapped)\r\n    }\r\n\r\n    override fun remove(element: E): Boolean = source.remove(map.remove(element))\r\n    override fun removeAll(elements: Collection<E>): Boolean = source.removeAll(elements.map { map[it] })\r\n    override fun retainAll(elements: Collection<E>): Boolean = source.retainAll(elements.map { map[it] })\r\n\r\n    override fun contains(element: E): Boolean = throw IllegalStateException(\"Not readable\")\r\n    override fun containsAll(elements: Collection<E>): Boolean = throw IllegalStateException(\"Not readable\")\r\n    override fun isEmpty(): Boolean = throw IllegalStateException(\"Not readable\")\r\n    override fun clear() = throw IllegalStateException(\"Not readable\")\r\n    override fun iterator(): MutableIterator<E> = throw IllegalStateException(\"Not readable\")\r\n}\r\n\r\nfun <S, E> MutableCollection<S>.mappingWriteOnly(inputMapper: (E) -> S) = CollectionWriteOnlyMapping(this, inputMapper)\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n/**\n * Randomly shuffles elements in this mutable list using the specified [random] instance as the source of randomness.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n","package com.lightningkite.reacktive.mapping\r\n\r\n/**\r\n * Returns a wrapper that maps the iterator to have items of a different type.\r\n */\r\nfun <S, T> MutableListIterator<S>.mapping(read: (S) -> T, write: (T) -> S): MutableListIterator<T> {\r\n    return object : MutableListIterator<T> {\r\n        override fun hasPrevious(): Boolean = this@mapping.hasPrevious()\r\n        override fun nextIndex(): Int = this@mapping.nextIndex()\r\n        override fun previous(): T = read(this@mapping.previous())\r\n        override fun previousIndex(): Int = this@mapping.previousIndex()\r\n        override fun add(element: T) = this@mapping.add(write(element))\r\n        override fun hasNext(): Boolean = this@mapping.hasNext()\r\n        override fun next(): T = read(this@mapping.next())\r\n        override fun remove() = this@mapping.remove()\r\n        override fun set(element: T) = this@mapping.set(write(element))\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a wrapper that maps the iterator to have items of a different type.\r\n */\r\nfun <S, T> MutableIterator<S>.mappingMutable(read: (S) -> T): MutableIterator<T> {\r\n    return object : MutableIterator<T> {\r\n        override fun hasNext(): Boolean = this@mappingMutable.hasNext()\r\n        override fun next(): T = read(this@mappingMutable.next())\r\n        override fun remove() = this@mappingMutable.remove()\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a wrapper that maps the iterator to have items of a different type.\r\n */\r\nfun <S, T> Iterator<S>.mapping(read: (S) -> T): Iterator<T> {\r\n    return object : Iterator<T> {\r\n        override fun hasNext(): Boolean = this@mapping.hasNext()\r\n        override fun next(): T = read(this@mapping.next())\r\n    }\r\n}\r\n\r\n/**\r\n * Basically casts the iterator to a mutable one, throwing exceptions if any mutations are called.\r\n **/\r\nfun <T> Iterator<T>.asMutable(): MutableIterator<T> = object : MutableIterator<T>, Iterator<T> by this {\r\n    override fun remove() {\r\n        throw UnsupportedOperationException(\"Underlying collection is actually immutable\")\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a wrapper that maps the iterator to have items of a different type.\r\n */\r\nfun <S, T> ListIterator<S>.mapping(read: (S) -> T): ListIterator<T> {\r\n    return object : ListIterator<T> {\r\n        override fun hasPrevious(): Boolean = this@mapping.hasPrevious()\r\n        override fun nextIndex(): Int = this@mapping.nextIndex()\r\n        override fun previous(): T = read(this@mapping.previous())\r\n        override fun previousIndex(): Int = this@mapping.previousIndex()\r\n        override fun hasNext(): Boolean = this@mapping.hasNext()\r\n        override fun next(): T = read(this@mapping.next())\r\n    }\r\n}\r\n\r\n/**\r\n * Basically casts the iterator to a mutable one, throwing exceptions if any mutations are called.\r\n **/\r\nfun <T> ListIterator<T>.asMutable(): MutableListIterator<T> = object : MutableListIterator<T>, ListIterator<T> by this {\r\n    override fun add(element: T) {\r\n        throw UnsupportedOperationException(\"Underlying collection is actually immutable\")\r\n    }\r\n\r\n    override fun remove() {\r\n        throw UnsupportedOperationException(\"Underlying collection is actually immutable\")\r\n    }\r\n\r\n    override fun set(element: T) {\r\n        throw UnsupportedOperationException(\"Underlying collection is actually immutable\")\r\n    }\r\n\r\n}\r\n","package com.lightningkite.reacktive\r\n\r\n@Suppress(\"UNCHECKED_CAST\")\r\nobject NoOpMutableCollection: MutableCollection<Any?> {\r\n\r\n    fun <T> type():MutableCollection<T> = this as MutableCollection<T>\r\n\r\n    override val size: Int\r\n        get() = 0\r\n\r\n    override fun contains(element: Any?): Boolean = false\r\n    override fun containsAll(elements: Collection<Any?>): Boolean = false\r\n    override fun isEmpty(): Boolean = true\r\n    override fun add(element: Any?): Boolean = false\r\n    override fun addAll(elements: Collection<Any?>): Boolean = false\r\n    override fun clear() {\r\n    }\r\n    override fun iterator(): MutableIterator<Any?> = object : MutableIterator<Any?> {\r\n        override fun hasNext(): Boolean = false\r\n        override fun next(): Any?  = throw UnsupportedOperationException()\r\n        override fun remove() {}\r\n    }\r\n    override fun remove(element: Any?): Boolean = false\r\n    override fun removeAll(elements: Collection<Any?>): Boolean = false\r\n    override fun retainAll(elements: Collection<Any?>): Boolean = false\r\n}","package com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\n\r\n\r\n/**\r\n * Combines several observable properties into one.\r\n * Created by joseph on 12/2/16.\r\n */\r\nclass CombineObservableProperty2<A, B, T>(\r\n        val observableA: ObservableProperty<A>,\r\n        val observableB: ObservableProperty<B>,\r\n        val combine: (A, B) -> T\r\n) : EnablingMutableCollection<(T) -> Unit>(), ObservableProperty<T> {\r\n\r\n    override var value = combine(observableA.value, observableB.value)\r\n\r\n    fun update() {\r\n        value = combine(observableA.value, observableB.value)\r\n        forEach { it.invoke(value) }\r\n    }\r\n\r\n    val callbackA = { item: A ->\r\n        update()\r\n    }\r\n    val callbackB = { item: B ->\r\n        update()\r\n    }\r\n\r\n    override fun enable() {\r\n        value = combine(observableA.value, observableB.value)\r\n        observableA.add(callbackA)\r\n        observableB.add(callbackB)\r\n    }\r\n\r\n    override fun disable() {\r\n        observableA.remove(callbackA)\r\n        observableB.remove(callbackB)\r\n    }\r\n}\r\n\r\ninfix fun <A, B> ObservableProperty<A>.pair(other:ObservableProperty<B>)\r\n        = CombineObservableProperty2(this, other) { a, b -> a to b}","package com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\n\r\n\r\n/**\r\n * Combines several observable properties into one.\r\n * Created by joseph on 12/2/16.\r\n */\r\nclass CombineObservableProperty3<A, B, C, T>(\r\n        val observableA: ObservableProperty<A>,\r\n        val observableB: ObservableProperty<B>,\r\n        val observableC: ObservableProperty<C>,\r\n        val combine: (A, B, C) -> T\r\n) : EnablingMutableCollection<(T) -> Unit>(), ObservableProperty<T> {\r\n\r\n    override var value = combine(observableA.value, observableB.value, observableC.value)\r\n\r\n    fun update() {\r\n        value = combine(observableA.value, observableB.value, observableC.value)\r\n        forEach { it.invoke(value) }\r\n    }\r\n\r\n    val callbackA = { item: A ->\r\n        update()\r\n    }\r\n    val callbackB = { item: B ->\r\n        update()\r\n    }\r\n    val callbackC = { item: C ->\r\n        update()\r\n    }\r\n\r\n    override fun enable() {\r\n        value = combine(observableA.value, observableB.value, observableC.value)\r\n        observableA.add(callbackA)\r\n        observableB.add(callbackB)\r\n        observableC.add(callbackC)\r\n    }\r\n\r\n    override fun disable() {\r\n        observableA.remove(callbackA)\r\n        observableB.remove(callbackB)\r\n        observableC.remove(callbackC)\r\n    }\r\n}","package com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\n\r\n\r\n/**\r\n * Combines several observable properties into one, ignoring the values.\r\n * Created by joseph on 12/2/16.\r\n */\r\n@Suppress(\"UNCHECKED_CAST\")\r\nclass CombineObservablePropertyBlind<T>(\r\n        val observables: Collection<ObservableProperty<*>>,\r\n        val combine: () -> T\r\n) : EnablingMutableCollection<(T) -> Unit>(), ObservableProperty<T> {\r\n\r\n    constructor(vararg observables: ObservableProperty<*>, combine: () -> T) : this(observables.toList(), combine)\r\n\r\n    override var value = combine()\r\n\r\n    fun update() {\r\n        value = combine()\r\n        forEach { it.invoke(value) }\r\n    }\r\n\r\n    val callbacks = HashMap<ObservableProperty<Any?>, (Any?) -> Unit>()\r\n\r\n    override fun enable() {\r\n        combine()\r\n        callbacks += observables.map {\r\n            val newListener = { _: Any? -> update() }\r\n            val itFake = it as ObservableProperty<Any?>\r\n            itFake.add(newListener)\r\n            itFake to newListener\r\n        }\r\n    }\r\n\r\n    override fun disable() {\r\n        callbacks.forEach { (key, value) -> key.remove(value) }\r\n        callbacks.clear()\r\n    }\r\n}\r\n\r\nfun <T> List<ObservableProperty<*>>.combine(combine: () -> T) = CombineObservablePropertyBlind(this, combine)","package com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.NoOpMutableCollection\r\n\r\n\r\n/**\r\n * A constant observable property - the value never changes.\r\n * Created by joseph on 12/2/16.\r\n */\r\nclass ConstantObservableProperty<T>(override val value: T) : ObservableProperty<T>, MutableCollection<(T)->Unit> by NoOpMutableCollection.type() {\r\n\r\n}","package com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.Event\r\n\r\n\r\n/**\r\n * An observable that doesn't have to be set at its creation.\r\n * Created by jivie on 2/11/16.\r\n */\r\nopen class LateInitObservableProperty<T : Any> : MutableObservableProperty<T>, Event<T> by ArrayList() {\r\n\r\n    var internalValue: T? = null\r\n    override var value: T\r\n        get() = internalValue ?: throw IllegalStateException(\"Value not set.\")\r\n        set(value) {\r\n            internalValue = value\r\n            for(callback in this){\r\n                callback.invoke(value)\r\n            }\r\n        }\r\n}","package com.lightningkite.reacktive.property.lifecycle\r\n\r\nimport com.lightningkite.reacktive.Lifecycle\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\n\r\n/**\r\n * Runs a lambda when the\r\n */\r\ninline fun Lifecycle.openCloseBinding(\r\n        crossinline onOpen:()->Unit,\r\n        crossinline onClose:()->Unit\r\n): (Boolean) -> Unit {\r\n    var state:Boolean = false\r\n    val lambda = { newState:Boolean ->\r\n        if(state != newState){\r\n            if(newState){\r\n                onOpen()\r\n            } else {\r\n                onClose()\r\n            }\r\n            state = newState\r\n        }\r\n    }\r\n    lambda(value)\r\n    add(lambda)\r\n    return lambda\r\n}","package com.lightningkite.reacktive.property.lifecycle\r\n\r\nimport com.lightningkite.reacktive.Event\r\nimport com.lightningkite.reacktive.Event0\r\nimport com.lightningkite.reacktive.Lifecycle\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\n\r\n\r\nfun Lifecycle.bind(\r\n        event: Event0,\r\n        listener:()->Unit\r\n) = openCloseBinding(\r\n        onOpen = { event.add(listener); listener.invoke() },\r\n        onClose = { event.remove(listener) }\r\n)\r\n\r\nfun <T> Lifecycle.bind(\r\n        event: Event<T>,\r\n        initialValue:T,\r\n        listener:(T)->Unit\r\n) = openCloseBinding(\r\n        onOpen = { event.add(listener); listener.invoke(initialValue) },\r\n        onClose = { event.remove(listener) }\r\n)\r\n\r\nfun <T> Lifecycle.bind(\r\n        property: ObservableProperty<T>,\r\n        listener: (T)->Unit\r\n) = openCloseBinding(\r\n        onOpen = { property.add(listener); listener.invoke(property.value) },\r\n        onClose = { property.remove(listener) }\r\n)\r\n\r\ninline fun <A, B> Lifecycle.bind(\r\n        propertyA: ObservableProperty<A>,\r\n        propertyB: ObservableProperty<B>,\r\n        crossinline listener: (A, B)->Unit\r\n): (Boolean)->Unit {\r\n    val a =  { it:A -> listener.invoke(it, propertyB.value) }\r\n    val b =  { it:B -> listener.invoke(propertyA.value, it) }\r\n    return openCloseBinding(\r\n            onOpen = {\r\n                propertyA.add(a)\r\n                propertyB.add(b)\r\n                listener.invoke(propertyA.value, propertyB.value)\r\n            },\r\n            onClose = {\r\n                propertyA.remove(a)\r\n                propertyB.remove(b)\r\n            }\r\n    )\r\n}\r\n\r\ninline fun <A, B, C> Lifecycle.bind(\r\n        propertyA: ObservableProperty<A>,\r\n        propertyB: ObservableProperty<B>,\r\n        propertyC: ObservableProperty<C>,\r\n        crossinline listener: (A, B, C)->Unit\r\n): (Boolean)->Unit {\r\n    val a =  { it:A -> listener.invoke(it, propertyB.value, propertyC.value) }\r\n    val b =  { it:B -> listener.invoke(propertyA.value, it, propertyC.value) }\r\n    val c =  { it:C -> listener.invoke(propertyA.value, propertyB.value, it) }\r\n    return openCloseBinding(\r\n            onOpen = {\r\n                propertyA.add(a)\r\n                propertyB.add(b)\r\n                propertyC.add(c)\r\n                listener.invoke(propertyA.value, propertyB.value, propertyC.value)\r\n            },\r\n            onClose = {\r\n                propertyA.remove(a)\r\n                propertyB.remove(b)\r\n                propertyC.remove(c)\r\n            }\r\n    )\r\n}\r\n\r\ninline fun Lifecycle.bind(\r\n        properties: List<ObservableProperty<out Any?>>,\r\n        crossinline listener: ()->Unit\r\n): (Boolean)->Unit {\r\n    val ignoreListener = {it:Any? -> listener() }\r\n    return openCloseBinding(\r\n            onOpen = {\r\n                for(prop in properties){\r\n                    prop.add(ignoreListener)\r\n                }\r\n            },\r\n            onClose = {\r\n                for(prop in properties){\r\n                    prop.remove(ignoreListener)\r\n                }\r\n            }\r\n    )\r\n}","package com.lightningkite.reacktive.property.lifecycle\r\n\r\nimport com.lightningkite.reacktive.Lifecycle\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\n\r\nfun <T> Lifecycle.listen(collection: MutableCollection<T>, item: T) = openCloseBinding(\r\n        onOpen = { collection.add(item) },\r\n        onClose = { collection.remove(item) }\r\n)\r\n\r\nfun <T> Lifecycle.listen(\r\n        property: ObservableProperty<T>,\r\n        item: (T)->Unit\r\n) = openCloseBinding(\r\n        onOpen = { property.add(item) },\r\n        onClose = { property.remove(item) }\r\n)","package com.lightningkite.reacktive.property\r\n\r\n\r\n\r\nclass MutableListFromProperty<E>(\r\n        val property: MutableObservableProperty<List<E>>\r\n) : MutableList<E> {\r\n    fun move(fromIndex: Int, toIndex: Int) {\r\n        property.value = property.value.toMutableList().also {\r\n            it.add(toIndex, it.removeAt(fromIndex))\r\n        }\r\n    }\r\n\r\n    override fun add(element: E): Boolean {\r\n        property.value = property.value + element\r\n        return true\r\n    }\r\n\r\n    override fun add(index: Int, element: E) {\r\n        property.value = property.value.toMutableList().also {\r\n            it.add(index, element)\r\n        }\r\n    }\r\n\r\n    override fun addAll(index: Int, elements: Collection<E>): Boolean {\r\n        property.value = property.value.toMutableList().also {\r\n            it.addAll(index, elements)\r\n        }\r\n        return true\r\n    }\r\n\r\n    override fun addAll(elements: Collection<E>): Boolean {\r\n        property.value = property.value + elements\r\n        return true\r\n    }\r\n\r\n    override fun clear() {\r\n        property.value = listOf()\r\n    }\r\n\r\n    override fun remove(element: E): Boolean {\r\n        var result = false\r\n        property.value = property.value.toMutableList().also {\r\n            result = it.remove(element)\r\n        }\r\n        return result\r\n    }\r\n\r\n    override fun removeAll(elements: Collection<E>): Boolean {\r\n        var result = false\r\n        property.value = property.value.toMutableList().also {\r\n            result = it.removeAll(elements)\r\n        }\r\n        return result\r\n    }\r\n\r\n    override fun removeAt(index: Int): E {\r\n        var result: E\r\n        property.value = property.value.toMutableList().also {\r\n            result = it.removeAt(index)\r\n        }\r\n        return result\r\n    }\r\n\r\n    override fun retainAll(elements: Collection<E>): Boolean {\r\n        var result = false\r\n        property.value = property.value.toMutableList().also {\r\n            result = it.retainAll(elements)\r\n        }\r\n        return result\r\n    }\r\n\r\n    override fun set(index: Int, element: E): E {\r\n        var result:E\r\n        property.value = property.value.toMutableList().also {\r\n            result = it.set(index, element)\r\n        }\r\n        return result\r\n    }\r\n\r\n    fun replace(collection: Collection<E>) {\r\n        property.value = collection.toList()\r\n    }\r\n\r\n    override val size: Int\r\n        get() = property.value.size\r\n\r\n    override fun contains(element: E): Boolean = property.value.contains(element)\r\n\r\n    override fun containsAll(elements: Collection<E>): Boolean = property.value.containsAll(elements)\r\n\r\n    override fun get(index: Int): E = property.value.get(index)\r\n\r\n    override fun indexOf(element: E): Int = property.value.indexOf(element)\r\n\r\n    override fun isEmpty(): Boolean = property.value.isEmpty()\r\n\r\n    override fun iterator(): MutableIterator<E> = listIterator()\r\n\r\n    override fun lastIndexOf(element: E): Int = property.value.lastIndexOf(element)\r\n\r\n    override fun listIterator(): MutableListIterator<E> = listIterator(0)\r\n\r\n    override fun listIterator(index: Int): MutableListIterator<E> = object : MutableListIterator<E> {\r\n        var currentIndex = index - 1\r\n        override fun hasNext(): Boolean = (currentIndex + 1) < property.value.size\r\n\r\n        override fun next(): E = property.value[++currentIndex]\r\n\r\n        override fun remove() {\r\n            property.value = property.value.toMutableList().also { it.removeAt(currentIndex) }\r\n            currentIndex--\r\n        }\r\n\r\n        override fun add(element: E) {\r\n            property.value = property.value.toMutableList().also { it.add(currentIndex, element) }\r\n            currentIndex++\r\n        }\r\n\r\n        override fun hasPrevious(): Boolean = currentIndex > 0\r\n\r\n        override fun nextIndex(): Int = currentIndex\r\n\r\n        override fun previous(): E = property.value[currentIndex--]\r\n\r\n        override fun previousIndex(): Int = currentIndex - 1\r\n\r\n        override fun set(element: E) {\r\n            property.value = property.value.toMutableList().also { it[currentIndex] = element }\r\n        }\r\n\r\n    }\r\n\r\n    class Partial<E>(\r\n            val property: MutableObservableProperty<List<E>>,\r\n            var startIndex: Int = 0,\r\n            var endIndexExclusive: Int = 0\r\n    ) : MutableList<E> {\r\n\r\n        inline fun Int.localToGlobal() = this + startIndex\r\n        inline fun Int.globalToLocal() = this - startIndex\r\n\r\n        fun move(fromIndex: Int, toIndex: Int) {\r\n            property.value = property.value.toMutableList().also {\r\n                it.add(toIndex.localToGlobal(), it.removeAt(fromIndex.localToGlobal()))\r\n            }\r\n        }\r\n\r\n        override fun add(element: E): Boolean {\r\n            property.value = property.value.toMutableList().also {\r\n                it.add(endIndexExclusive, element)\r\n            }\r\n            endIndexExclusive++\r\n            return true\r\n        }\r\n\r\n        override fun add(index: Int, element: E) {\r\n            property.value = property.value.toMutableList().also {\r\n                it.add(index.localToGlobal(), element)\r\n            }\r\n            endIndexExclusive++\r\n        }\r\n\r\n        override fun addAll(index: Int, elements: Collection<E>): Boolean {\r\n            property.value = property.value.toMutableList().also {\r\n                it.addAll(index.localToGlobal(), elements)\r\n            }\r\n            endIndexExclusive += elements.size\r\n            return true\r\n        }\r\n\r\n        override fun addAll(elements: Collection<E>): Boolean {\r\n            property.value = property.value.toMutableList().also {\r\n                it.addAll(endIndexExclusive, elements)\r\n            }\r\n            endIndexExclusive += elements.size\r\n            return true\r\n        }\r\n\r\n        override fun clear() {\r\n            property.value = listOf()\r\n        }\r\n\r\n        override fun remove(element: E): Boolean {\r\n            var result = false\r\n            property.value = property.value.toMutableList().also {\r\n                result = it.remove(element)\r\n            }\r\n            if(result) endIndexExclusive--\r\n            return result\r\n        }\r\n\r\n        override fun removeAll(elements: Collection<E>): Boolean {\r\n            var result = false\r\n            property.value = property.value.toMutableList().also {\r\n                result = it.removeAll(elements)\r\n            }\r\n            return result\r\n        }\r\n\r\n        override fun removeAt(index: Int): E {\r\n            var result: E\r\n            property.value = property.value.toMutableList().also {\r\n                result = it.removeAt(index.localToGlobal())\r\n            }\r\n            endIndexExclusive--\r\n            return result\r\n        }\r\n\r\n        override fun retainAll(elements: Collection<E>): Boolean {\r\n            var result = false\r\n            property.value = property.value.toMutableList().also {\r\n                result = it.retainAll(elements)\r\n            }\r\n            return result\r\n        }\r\n\r\n        override fun set(index: Int, element: E): E {\r\n            var result: E\r\n            property.value = property.value.toMutableList().also {\r\n                result = it.set(index.localToGlobal(), element)\r\n            }\r\n            return result\r\n        }\r\n\r\n        fun replace(collection: Collection<E>) = UnsupportedOperationException()\r\n\r\n        override val size: Int\r\n            get() = endIndexExclusive - startIndex\r\n\r\n        override fun contains(element: E): Boolean = any { it == element }\r\n\r\n        override fun containsAll(elements: Collection<E>): Boolean = elements.all { element -> any { it == element } }\r\n\r\n        override fun get(index: Int): E = property.value.get(index.localToGlobal())\r\n\r\n        override fun indexOf(element: E): Int = property.value.indexOf(element).globalToLocal()\r\n\r\n        override fun isEmpty(): Boolean = startIndex == endIndexExclusive\r\n\r\n        override fun iterator(): MutableIterator<E> = listIterator()\r\n\r\n        override fun lastIndexOf(element: E): Int = property.value.lastIndexOf(element).globalToLocal()\r\n\r\n        override fun listIterator(): MutableListIterator<E> = listIterator(0)\r\n\r\n        override fun listIterator(index: Int): MutableListIterator<E> = object : MutableListIterator<E> {\r\n            var currentIndex = index.localToGlobal() - 1\r\n            override fun hasNext(): Boolean = (currentIndex + 1) < endIndexExclusive\r\n\r\n            override fun next(): E = property.value[++currentIndex]\r\n\r\n            override fun remove() {\r\n                property.value = property.value.toMutableList().also { it.removeAt(currentIndex) }\r\n                currentIndex--\r\n            }\r\n\r\n            override fun add(element: E) {\r\n                property.value = property.value.toMutableList().also { it.add(currentIndex, element) }\r\n                currentIndex++\r\n            }\r\n\r\n            override fun hasPrevious(): Boolean = currentIndex >= startIndex\r\n\r\n            override fun nextIndex(): Int = currentIndex\r\n\r\n            override fun previous(): E = property.value[currentIndex--]\r\n\r\n            override fun previousIndex(): Int = currentIndex - 1\r\n\r\n            override fun set(element: E) {\r\n                property.value = property.value.toMutableList().also { it[currentIndex] = element }\r\n            }\r\n\r\n        }\r\n        override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = Partial(property, fromIndex.localToGlobal(), toIndex.localToGlobal())\r\n    }\r\n\r\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = Partial(property, fromIndex, toIndex)\r\n}","package com.lightningkite.reacktive.property\r\n\r\n\r\nimport com.lightningkite.reacktive.Event\r\nimport kotlin.reflect.KMutableProperty0\r\nimport kotlin.reflect.KMutableProperty1\r\n\r\n/**\r\n * Creates an observable property out of a reference to a property.\r\n * Note that for the observable to update, you *must* modify the reference through this observable.\r\n * Created by jivie on 2/22/16.\r\n */\r\nclass ReferenceObservableProperty<T>(\r\n    val getterFun: () -> T,\r\n    val setterFun: (T) -> Unit\r\n) : MutableObservableProperty<T>, Event<T> by ArrayList() {\r\n\r\n    override var value: T\r\n        get() = getterFun()\r\n        set(value) {\r\n            setterFun(value)\r\n            for(callback in this){\r\n                callback.invoke(value)\r\n            }\r\n        }\r\n}","package com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.Event\r\n\r\n\r\n/**\r\n * A standard observable property.\r\n * Simply is a box for a value that can be read or set.\r\n * Upon being set, it will call every listener it is given.\r\n *\r\n * Created by jivie on 1/19/16.\r\n */\r\nopen class StandardObservableProperty<T>(\r\n        initValue: T\r\n) : MutableObservableProperty<T>, Event<T> by ArrayList() {\r\n\r\n    override var value: T = initValue\r\n        set(value) {\r\n            field = value\r\n            for(callback in this){\r\n                callback.invoke(value)\r\n            }\r\n        }\r\n}","\r\n\r\n\r\npackage com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\n\r\n\r\n/**\r\n * Transforms an observable to observe another observable.\r\n * Created by jivie on 2/22/16.\r\n */\r\nclass SubObservableProperty<A, B>(\r\n        val owningObservable: ObservableProperty<A>,\r\n        val getter: (A) -> ObservableProperty<B>\r\n) : EnablingMutableCollection<(B) -> Unit>(), MutableObservableProperty<B> {\r\n\r\n    var currentSub: ObservableProperty<B>? = null\r\n\r\n    override var value: B\r\n        get() = owningObservable.value.let(getter).value\r\n        set(value) {\r\n            val currentSub = owningObservable.value.let(getter)\r\n            if (currentSub is MutableObservableProperty<B>) {\r\n                currentSub.value = value\r\n            } else throw IllegalStateException(\"ObservableProperty is not mutable\")\r\n        }\r\n\r\n    val outerCallback = { a: A ->\r\n        val wrapped = value\r\n        forEach { it.invoke(wrapped) }\r\n        resub()\r\n    }\r\n    val innerCallback = { b: B ->\r\n        val wrapped = value\r\n        forEach { it.invoke(wrapped) }\r\n    }\r\n\r\n    override fun enable() {\r\n        owningObservable.add(outerCallback)\r\n        resub()\r\n    }\r\n\r\n    override fun disable() {\r\n        owningObservable.remove(outerCallback)\r\n        unsub()\r\n    }\r\n\r\n    private fun resub() {\r\n        unsub()\r\n        val sub = owningObservable.value.let(getter)\r\n        sub.add(innerCallback)\r\n        currentSub = sub\r\n    }\r\n\r\n    private fun unsub() {\r\n        currentSub?.remove(innerCallback)\r\n        currentSub = null\r\n    }\r\n}\r\n\r\n/**\r\n * Transforms an observable to observe an observable within the observable.\r\n * Trippy, right?\r\n */\r\nfun <A, B> ObservableProperty<A>.sub(getterFun: (A) -> ObservableProperty<B>) = SubObservableProperty(this, getterFun)","\r\n\r\n\r\npackage com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\n\r\n\r\n/**\r\n * Transforms an observable property from one type to another.\r\n * Created by jivie on 2/22/16.\r\n */\r\nclass TransformMutableObservableProperty<S, T>(\r\n        val observable: MutableObservableProperty<S>,\r\n        val transformer: (S) -> T,\r\n        val reverseTransformer: (T) -> S\r\n) : EnablingMutableCollection<(T) -> Unit>(), MutableObservableProperty<T> {\r\n    override var value: T\r\n        get() = transformer(observable.value)\r\n        set(value) {\r\n            observable.value = reverseTransformer(value)\r\n        }\r\n\r\n    val callback = { a: S ->\r\n        val wrapped = transformer(a)\r\n        forEach { it.invoke(wrapped) }\r\n    }\r\n\r\n    override fun enable() {\r\n        observable.add(callback)\r\n    }\r\n\r\n    override fun disable() {\r\n        observable.remove(callback)\r\n    }\r\n}\r\n\r\nfun <S, T> MutableObservableProperty<S>.transform(mapper: (S) -> T, reverseMapper: (T) -> S): TransformMutableObservableProperty<S, T> {\r\n    return TransformMutableObservableProperty(this, mapper, reverseMapper)\r\n}","package com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\n\r\n\r\n/**\r\n * Transforms an observable property from one type to another.\r\n * Created by jivie on 2/22/16.\r\n */\r\nclass TransformObservableProperty<S, T>(\r\n        val observable: ObservableProperty<S>,\r\n        val transformer: (S) -> T\r\n) : EnablingMutableCollection<(T) -> Unit>(), ObservableProperty<T> {\r\n    override val value: T\r\n        get() = transformer(observable.value)\r\n\r\n    val callback = { a: S ->\r\n        val wrapped = transformer(a)\r\n        forEach { it.invoke(wrapped) }\r\n    }\r\n\r\n    override fun enable() {\r\n        observable.add(callback)\r\n    }\r\n\r\n    override fun disable() {\r\n        observable.remove(callback)\r\n    }\r\n}\r\n\r\nfun <S, T> ObservableProperty<S>.transform(mapper: (S) -> T): TransformObservableProperty<S, T> {\r\n    return TransformObservableProperty(this, mapper)\r\n}\r\n\r\n@Deprecated(\"This is the same as using 'mapUnfailing'.\", ReplaceWith(\"this.mapUnfailing(getterFun)\", \"com.lightningkite.kotlin.observable.property.mapUnfailing\"))\r\nfun <A, B> ObservableProperty<A>.sub(getterFun: (A) -> B) = TransformObservableProperty(this, getterFun)\r\n","package com.lightningkite.reacktive.property\r\n\r\nfun <T> ObservableProperty<T>.update(){\r\n    val cached = value\r\n    for(callback in this){\r\n        callback.invoke(cached)\r\n    }\r\n}","package com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\n\r\n\r\n/**\r\n *\r\n * Created by josep on 8/19/2017.\r\n */\r\nclass VirtualMutableObservableProperty<T>(\r\n    val getterFun: () -> T,\r\n    val setterFun: (T) -> Unit,\r\n    val event: MutableCollection<(T) -> Unit>\r\n) : MutableObservableProperty<T>, MutableCollection<(T) -> Unit> by event {\r\n\r\n    override var value: T\r\n        get() = getterFun()\r\n        set(value) {\r\n            setterFun(value)\r\n        }\r\n}\r\n","package com.lightningkite.reacktive.property\r\n\r\nimport com.lightningkite.reacktive.EnablingMutableCollection\r\n\r\n\r\nclass VirtualObservableProperty<T>(\r\n        val getterFun: () -> T,\r\n        val event: MutableCollection<(T) -> Unit> = ArrayList()\r\n) : ObservableProperty<T>, MutableCollection<(T)->Unit> by event {\r\n\r\n    override val value: T\r\n        get() = getterFun()\r\n}","package com.lightningkite.reacktive.set\r\n\r\nimport com.lightningkite.reacktive.mapping.mappingMutable\r\nimport com.lightningkite.reacktive.mapping.mappingWriteOnly\r\nimport com.lightningkite.reacktive.collection.MutableObservableCollection\r\nimport com.lightningkite.reacktive.collection.ObservableCollection\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\nimport com.lightningkite.reacktive.property.transform\r\n\r\nclass MappingMutableObservableSet<A, B>(\r\n        val mutableSource: MutableObservableSet<A>,\r\n        transform: (A)->B,\r\n        reverse: (B)->A\r\n) : MappingObservableSet<A, B>(mutableSource, transform, reverse), MutableObservableSet<B> {\r\n    override fun replace(collection: Collection<B>) = mutableSource.replace(collection.map(reverse))\r\n    override fun add(element: B): Boolean = mutableSource.add(element.let(reverse))\r\n    override fun addAll(elements: Collection<B>): Boolean = mutableSource.addAll(elements.map(reverse))\r\n    override fun clear() = mutableSource.clear()\r\n    override fun iterator(): MutableIterator<B> = mutableSource.iterator().mappingMutable(transform)\r\n    override fun remove(element: B): Boolean = mutableSource.remove(element.let(reverse))\r\n    override fun removeAll(elements: Collection<B>): Boolean = mutableSource.removeAll(elements.map(reverse))\r\n    override fun retainAll(elements: Collection<B>): Boolean = mutableSource.retainAll(elements.map(reverse))\r\n}\r\n\r\nfun <A, B> MutableObservableSet<A>.mapping(transform: (A) -> B, reverse: (B) -> A): MappingMutableObservableSet<A, B> = MappingMutableObservableSet(this, transform, reverse)\r\n","package com.lightningkite.reacktive.set\r\n\r\nimport com.lightningkite.reacktive.mapping.mapping\r\nimport com.lightningkite.reacktive.mapping.mappingMutable\r\nimport com.lightningkite.reacktive.mapping.mappingWriteOnly\r\nimport com.lightningkite.reacktive.collection.MutableObservableCollection\r\nimport com.lightningkite.reacktive.collection.ObservableCollection\r\nimport com.lightningkite.reacktive.property.ObservableProperty\r\nimport com.lightningkite.reacktive.property.transform\r\n\r\nopen class MappingObservableSet<A, B>(\r\n        val source: ObservableSet<A>,\r\n        val transform: (A)->B,\r\n        val reverse: (B)->A\r\n) : ObservableSet<B> {\r\n    override val size: Int get() = source.size\r\n    override fun contains(element: B): Boolean = source.contains(element.let(reverse))\r\n    override fun containsAll(elements: Collection<B>): Boolean = source.containsAll(elements.map(reverse))\r\n    override fun isEmpty(): Boolean = source.isEmpty()\r\n    override fun iterator(): Iterator<B> = source.iterator().mapping(transform)\r\n\r\n    override val onCollectionAdd: MutableCollection<(value: B) -> Unit> = source.onCollectionAdd.mappingWriteOnly { myCallback ->\r\n        { value -> myCallback.invoke(value.let(transform)) }\r\n    }\r\n    override val onCollectionChange: MutableCollection<(old: B, new: B) -> Unit> = source.onCollectionChange.mappingWriteOnly { myCallback ->\r\n        { old, new -> myCallback.invoke(old.let(transform), new.let(transform)) }\r\n    }\r\n    override val onCollectionRemove: MutableCollection<(value: B) -> Unit> = source.onCollectionRemove.mappingWriteOnly { myCallback ->\r\n        { value -> myCallback.invoke(value.let(transform)) }\r\n    }\r\n    override val onCollectionUpdate: ObservableProperty<ObservableCollection<B>> = source.onCollectionUpdate.transform { this }\r\n    override val onCollectionReplace: MutableCollection<(ObservableCollection<B>) -> Unit> = source.onCollectionReplace.mappingWriteOnly { myCallback ->\r\n        { value -> myCallback.invoke(this) }\r\n    }\r\n}\r\n\r\nfun <A, B> ObservableSet<A>.mapping(transform: (A) -> B, reverse: (B) -> A): MappingObservableSet<A, B> = MappingObservableSet(this, transform, reverse)\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;mBAs7CA,oC;;gCA/JA,yD;uBAAA,gD;;;;;;;;qBCzrCA,mB;mBCjFA,wB;;;;;;;;;;;;;;;;;;;eFqrCA,wC;;;;;2BAWA,oD;oCAxgCA,oC;;;;oBA00BA,6C;sBAAA,0C;6BAAA,mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IG3gCQ,IAAG,CAAC,kBAAO,GAAP,CAAJ,C;MAAiB,MAAM,gCAA2B,GAAF,uCAAzB,C;IACvB,eAAI,KAAJ,C;EACJ,C;;;;;;ICCwC,qB;MAAA,QAA2B,kB;IAA3B,kB;IAKxC,cAAa,K;EAL0B,C;;IAOnC,IAAI,CAAC,WAAL,C;MACI,cAAS,I;MACT,a;;EAER,C;;IAGI,IAAI,UAAM,UAAN,IAAmB,WAAvB,C;MACI,cAAS,K;MACT,c;;EAER,C;;IAGI,c;IACA,aAAa,UAAM,WAAI,OAAJ,C;IACnB,OAAO,M;EACX,C;;IAGI,c;IACA,aAAa,UAAM,gBAAO,QAAP,C;IACnB,OAAO,M;EACX,C;;IAGI,UAAM,Q;IACN,gB;EACJ,C;;IAGI,aAAa,UAAM,cAAO,OAAP,C;IACnB,gB;IACA,OAAO,M;EACX,C;;IAGI,aAAa,UAAM,mBAAU,QAAV,C;IACnB,gB;IACA,OAAO,M;EACX,C;;IAGI,aAAa,UAAM,mBAAU,QAAV,C;IACnB,gB;IACA,OAAO,M;EACX,C;;IArDkF,sB;EAAA,C;;IAAA,6C;EAAA,C;;IAAA,iD;EAAA,C;;IAAA,yC;EAAA,C;;IAAA,+C;EAAA,C;;IAAA,oC;EAAA,C;;IAAA,wC;EAAA,C;;IAAA,2B;EAAA,C;;IAAA,4B;EAAA,C;;IAAA,4C;EAAA,C;;IAAA,gC;EAAA,C;;IAAA,6C;EAAA,C;;IAAA,yC;EAAA,C;;IAAA,6C;EAAA,C;;IAAA,qD;EAAA,C;;;ICOlF,4BAA2B,C;EAV/B,C;;IAMQ,IAAG,oBAAc,CAAjB,C;MAAoB,c;EACxB,C;;IAE6B,yBAAa,C;EAAb,C;;IAC7B,gC;EAAA,C;IAEQ,eAAe,yB;IACf,4BAAQ,K;IACR,IAAI,UAAS,CAAT,IAAc,aAAY,CAA9B,C;MACI,c;;IAEJ,IAAI,UAAS,CAAT,IAAc,aAAY,CAA9B,C;MACI,c;MACA,a;;EAER,C;;IAEJ,oB;IAA4C,oC;EAA5C,C;;IAEQ,Q;IAAA,6B;IAAA,qC;EACJ,C;;IAEI,Q;IAAA,6B;IAAA,qC;EACJ,C;;;IAGJ,oB;IAA+E,oC;EAA/E,C;;IAGQ,Q;IAAA,6B;IAAA,qC;EACJ,C;;IAGI,Q;IAAA,6B;IAAA,qC;EACJ,C;;IAGgB,Q;IAAA,sB;IAAZ,OAAY,cAAZ,C;MAAY,sB;MACR,IAAK,CAAO,UAAP,C;;EAEb,C;;;;ICvBS,Q;IAAA,2B;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,KAAK,CAAL,C;;EAER,C;;IAOiB,Q;IAAA,2B;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,KAAK,CAAL,EAAQ,CAAR,C;;EAER,C;;IAOiB,Q;IAAA,2B;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,KAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,C;;EAER,C;;IC5CgC,gC;EAAD,C;;IACyC,OAAA,mCAAsB,c;EAAtB,C;;IACM,OAAA,mCAAsB,c;EAAtB,C;;IACA,OAAA,mCAAsB,c;EAAtB,C;;IACH,OAAA,mCAAsB,c;EAAtB,C;;IACY,OAAA,mCAAsB,c;EAAtB,C;;IACV,sCAA2B,IAA3B,C;EAAA,C;;IANE,6B;EAAA,C;;IAAA,gD;EAAA,C;;IAAA,sD;EAAA,C;;IAAA,2C;EAAA,C;;IAAA,+C;EAAA,C;;IAAA,kC;EAAA,C;;IAAA,mC;EAAA,C;;IAAA,mD;EAAA,C;;IAAA,uC;EAAA,C;;IAAA,oD;EAAA,C;;IAAA,4D;EAAA,C;;;ICFjB,yB;IAE1D,2BAA8D,8C;IAC9D,8BAAoE,8C;IACpE,4BAAoE,8C;IACpE,yF;IAGA,+BAA6E,8C;IAC7E,8BAAiE,8C;EATrE,C;;IAEI,+B;EAAA,C;;IACA,kC;EAAA,C;;IACA,gC;EAAA,C;;IACA,kC;EAAA,C;;IAGA,mC;EAAA,C;;IACA,kC;EAAA,C;;IAJ4B,8D;IAAS,oF;EAAT,C;;IACsB,uC;EAAA,C;;;;ICLjB,kCAAuB,SAAvB,C;EAAA,C;;IAEoB,sCAA2B,SAA3B,C;EAAA,C;;IAGV,kCAAgC,OAAT,QAAS,CAAhC,C;EAAA,C;;ICAvC,sB;MAAA,SAAyB,mC;IAC7B,+BAAuB,aAAvB,C;IAFI,kC;IAyCJ,wBAA6B,M;IAOzB,c;EAjDwB,C;;IAMxB,yB;IACA,+BAAc,yBAAY,KAAZ,CAAd,EAAoC,OAApC,C;IACA,OAAO,O;EACX,C;;IAEI,yB;IACA,kBAAc,aAAI,yBAAY,KAAZ,CAAJ,EAAwB,OAAxB,C;EAClB,C;;IAEI,yB;IACA,OAAO,kBAAc,gBAAO,yBAAY,KAAZ,CAAP,EAA2B,QAA3B,C;EACzB,C;;IAEI,yB;IACA,kBAAc,cAAK,yBAAY,SAAZ,CAAL,EAA6B,yBAAY,OAAZ,CAA7B,C;EAClB,C;;IAEI,yB;IACA,OAAO,kBAAc,kBAAS,yBAAY,KAAZ,CAAT,C;EACzB,C;;IACkD,kBAAc,iBAAQ,UAAR,C;EAAd,C;;IACV,IAAG,YAAO,OAAP,CAAH,C;MACpC,kBAAc,WAAI,OAAJ,C;MADsB,OAEpC,I;;;MAFoC,OAGjC,K;EAHiC,C;;IAIgB,6B;IAA8B,gBAAO,W;IVunBtF,kBAAS,kB;IAyEA,U;IAAA,SUhsB6D,QVgsB7D,W;IAAhB,OAAgB,gBAAhB,C;MAAgB,2B;MAAM,IAzEU,SAyEN,CAAU,OAAV,CAAJ,C;QAAwB,WAAY,WAAI,OAAJ,C;;IUhsBF,OAAc,oBVisB/D,WUjsB+D,C;EAAd,C;;IACjC,kBAAc,Q;EAAd,C;;IACoB,OAAA,kBAAc,cAAO,OAAP,C;EAAd,C;;IACgB,OAAA,kBAAc,mBAAU,QAAV,C;EAAd,C;;IACA,OAAA,kBAAc,mBAAU,QAAV,C;EAAd,C;;IAI7B,gBAAR,YAAP,WAAO,C;IV+mBf,kBAAS,kB;IAyEA,Q;IAAA,2B;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MAAM,IUxrBiB,YAAO,wBVwrBV,OUxrBU,CAAP,CVwrBjB,C;QAAwB,WAAY,WAAI,OAAJ,C;;IUxrBtD,wBVyrBG,WUzrBH,C;EACJ,C;;IAEA,4B;EAAA,C;IAEQ,wBAAQ,K;IACR,c;EACJ,C;;IAOA,IAAI,YAAO,OAAP,CAAJ,C;MACI,sBAAS,8CAAiC,WAAjC,CAAT,EAAwD,WAAxD,C;;EAER,C;;IAGI,gBAA+B,cAAf,4B;IAChB,aAAa,YAAO,OAAP,C;IACb,IAAI,aAAa,CAAC,MAAlB,C;MACI,yBAAY,uCAA0B,WAA1B,EAAuC,EAAvC,CAAZ,C;;IAEJ,IAAI,UAAU,CAAC,SAAf,C;MACI,sBAAS,8CAAiC,WAAjC,CAAT,EAAwD,WAAxD,C;;EAER,C;;IAGI,Q;IAAA,0CAAiB,WAAjB,W;MCqBG,YDlBS,0D;MAFR,6BAGe,YAAH,GAAa,QAAM,CAAN,IAAb,GACK,KAJjB,C;;EAQR,C;;EAIA,C;;IAjF+B,W;EAAK,C;;;IAoFmC,mCAAwB,SAAxB,C;EAAA,C;;IElF7C,iC;IAFtB,oB;IACA,oB;IAGJ,uBAAsB,kB;IAyLtB,oBAAmB,c;IACnB,0BAAuD,8BAC/B,yDAD+B,EAS5B,2DAT4B,EAuB5B,2DAvB4B,EAkB9B,2DAlB8B,EA4B3B,2DA5B2B,C;IAwEvD,iBAAgB,K;EAvQiB,C;;ICCjC,iC;IADI,oB;IAEJ,iBAAgB,kB;IAoEhB,yBAA0C,kD;IAI1C,4BAAgD,qD;IAOhD,0BAAgD,mD;IAShD,6BAAyD,sD;IAGzD,4BAA6C,qD;EA9FZ,C;;IAMnB,Q;IAAA,qB;IAAV,qC;MAEQ,U;MADJ,IAAI,2BAAU,CAAV,IAAe,KAAnB,C;QACI,uB;QAAA,mBAAU,CAAV,qBAAU,CAAV,IAAgB,EAAhB,K;;;EAEZ,C;;IAGc,Q;IAAA,qB;IAAV,qC;MAEQ,U;MADJ,IAAI,2BAAU,CAAV,KAAgB,KAApB,C;QACI,uB;QAAA,mBAAU,CAAV,qBAAU,CAAV,IAAgB,EAAhB,K;;;EAEZ,C;;IAGI,OAAO,2BAAU,gBAAV,C;EACX,C;;IAG0C,gBAA/B,cAAU,eAAQ,WAAR,C;IAAjB,OF2FO,EAAW,SE3FiC,KAAM,EF2FlD,CAAJ,GAAsB,SAAtB,GAAgC,I;EE1FvC,C;;IAEgD,yB;MAAA,YAAe,E;IFgExD,SE/DI,cAAU,eAAQ,WAAR,C;IAAjB,OACQ,OAAM,EAAV,eACK,E;EAEb,C;;IAGuD,Q;IAAlC,gBAAV,c;IAAU,uB;;Mb+PR,U;MADb,YAAY,C;MACC,6B;MAAb,OAAa,gBAAb,C;QAAa,wB;QACT,IAAc,IahQkB,cbgQhC,C;UACI,sBAAO,K;UAAP,wB;;QACJ,qB;;MAEJ,sBAAO,E;;;IapQgD,qC;IAAnD,OAAO,CAA4C,OFgF5C,EAAW,WEhF8C,KAAM,EFgF/D,CAAJ,GAAsB,WAAtB,GAAgC,IEhF5B,mBAAiF,cAAV,cAAU,CAAV,GAAoB,CAApB,I;EAClF,C;;IAGI,cAAU,aAAI,gBAAJ,EAAsB,WAAtB,C;IACA,YAAV,cAAU,EAAU,iBAAI,gBAAJ,CAAV,EAAiC,gBAAjC,C;IACV,iBAAa,S;EACjB,C;;IAGI,UAAU,iBAAI,gBAAJ,C;IACV,cAAU,kBAAS,gBAAT,C;IACG,YAAb,iBAAa,EAAU,GAAV,EAAe,gBAAf,C;IACb,iBAAa,S;EACjB,C;;IAGI,cAAU,aAAI,gBAAJ,EAAsB,cAAU,kBAAS,mBAAT,CAAhC,C;IACC,YAAX,eAAW,EAAU,iBAAI,gBAAJ,CAAV,EAAiC,mBAAjC,EAAsD,gBAAtD,C;IACX,iBAAa,S;EACjB,C;;IAGI,cAAU,Q;IACV,cAAU,gBAAO,WAAP,C;IACI,YAAd,kBAAc,EAAU,IAAV,C;IACd,iBAAa,S;EACjB,C;;IA+CI,WAAO,UAAU,WAAI,sBAAJ,C;IACjB,WAAO,aAAa,WAAI,yBAAJ,C;IACpB,WAAO,WAAW,WAAI,uBAAJ,C;IAClB,WAAO,cAAc,WAAI,0BAAJ,C;IACrB,WAAO,aAAa,WAAI,yBAAJ,C;EACxB,C;;IAGI,WAAO,UAAU,cAAO,sBAAP,C;IACjB,WAAO,aAAa,cAAO,yBAAP,C;IACpB,WAAO,WAAW,cAAO,uBAAP,C;IAClB,WAAO,cAAc,cAAO,0BAAP,C;IACrB,WAAO,aAAa,cAAO,yBAAP,C;EACxB,C;;IA+BI,yB;IACA,OAAO,cAAU,U;EACrB,C;;IAGI,yB;IACA,OAAO,cAAU,gBAAS,WAAO,eAAQ,OAAR,CAAhB,C;EACrB,C;;IAGI,yB;IACO,yB;IbgnCJ,kBAAM,eAAa,wBahnCO,QbgnCP,EAAwB,EAAxB,CAAb,C;IAqEA,U;IAAA,SarrCoB,QbqrCpB,W;IAAb,OAAa,gBAAb,C;MAAa,wB;MACT,WAAY,WatrCgC,WAAO,ebsrCzB,IatrCyB,CbsrCvC,C;;IatrCZ,OAAiB,yBburCd,WavrCc,C;EACrB,C;;IAEgE,wD;IAExD,6C;IAGJ,aAAY,kCAAU,sBAAa,aAAb,C;EALsC,C;;IAMtB,OAAA,UAAM,c;EAAN,C;;IACN,OAAA,UAAM,Y;EAAN,C;;IACH,wDAAO,UAAM,WAAb,C;EAAA,C;;IACO,OAAA,UAAM,gB;EAAN,C;;IACF,OAAA,UAAM,U;EAAN,C;;IACT,wDAAO,UAAM,OAAb,C;EAAA,C;;IAEM,MAAM,sC;EAAN,C;;IACP,UAAM,S;EAAN,C;;IACO,MAAM,sC;EAAN,C;;;IAf6B,sE;EAAA,C;;IAkBV,iCAAa,CAAb,C;EAAA,C;;IACR,iCAAa,CAAb,C;EAAA,C;;IAEuB,MAAM,sC;EAAN,C;;IAEjE,yB;IACA,OAAO,wBAAO,yBAAY,KAAZ,CAAP,C;EACX,C;;IAGI,yB;IACA,OAAO,cAAU,eAAQ,WAAO,eAAQ,OAAR,CAAf,C;EACrB,C;;IAGI,yB;IACA,OAAO,cAAU,mBAAY,WAAO,mBAAY,OAAZ,CAAnB,C;EACrB,C;;IAIQ,yB;IACA,OAAO,cAAU,K;EACrB,C;;IAzIsC,iC;MACtC,gDAAe,KAAf,EAAsB,CAAtB,C;MACA,iDAAgB,OAAhB,EAAyB,KAAzB,C;MACJ,W;IAH0C,C;EAAA,C;;IAIM,sC;MAC5C,Q;MAAA,8DAAiB,KAAjB,W;QAA6B,yD;QACZ,YAAb,uCAAa,qB;QACb,uCAAa,S;;MAEjB,oDAAmB,GAAnB,EAAwB,OAAxB,EAAiC,KAAjC,C;MACJ,W;IANgD,C;EAAA,C;;IAOA,2C;MAC5C,0BAA0B,kDAAiB,QAAjB,C;MAC1B,uCAAM,QAAN,EAAgB,EAAhB,C;MACA,gDAAe,KAAf,EAAsB,CAAtB,C;MACA,gC;QACI,+CADJ,mBACI,Q;;MAEJ,kDAAiB,OAAjB,EAA0B,QAA1B,EAAoC,KAApC,C;MACJ,W;IARgD,C;EAAA,C;;IASS,qB;MACrD,kC;MACJ,W;IAFyD,C;EAAA,C;;IAGZ,iC;MACzC,kBAAkB,kDAAiB,KAAjB,C;MAClB,IAAI,mBAAJ,C;QACI,kCAAU,kBAAS,WAAT,C;;MAEd,uCAAM,KAAN,EAAa,EAAb,C;MACA,IAAI,mBAAJ,C;QACiB,YAAb,qCAAa,EAAU,OAAV,EAAmB,WAAnB,C;QACb,qCAAa,S;;MAEjB,oDAAmB,OAAnB,EAA4B,KAA5B,C;MACJ,W;IAX6C,C;EAAA,C;;;IC3F7C,0B;MAAA,aAAsB,C;IACE,oC;IAFxB,gB;IACA,4B;IAIA,iBAAgB,8C;IAKhB,oBAAmB,iD;IAKnB,kBAAiB,+C;IAKjB,oBAAmB,iD;IAKnB,qBAAoB,kD;EA1BQ,C;;ICHmB,kCAAuB,SAAvB,C;EAAA,C;;IAIvB,oC;IADxB,gB;IAIA,iBAAgB,6C;IAKhB,oBAAmB,gD;IAKnB,kBAAiB,8C;IAQjB,oBAAmB,gD;IAKnB,qBAAoB,iD;EA5BO,C;;IAGI,OAAK,WAAL,SAAK,C;EAAL,C;;IA8B3B,SAAK,UAAU,WAAI,cAAJ,C;IACf,SAAK,aAAa,WAAI,iBAAJ,C;IAClB,SAAK,WAAW,WAAI,eAAJ,C;IAChB,SAAK,aAAa,WAAI,iBAAJ,C;IAClB,SAAK,cAAc,WAAI,kBAAJ,C;EACvB,C;;IAGI,SAAK,UAAU,cAAO,cAAP,C;IACf,SAAK,aAAa,cAAO,iBAAP,C;IAClB,SAAK,WAAW,cAAO,eAAP,C;IAChB,SAAK,aAAa,cAAO,iBAAP,C;IAClB,SAAK,cAAc,cAAO,kBAAP,C;EACvB,C;;IAzCgB,iC;MACZ,IAAI,UAAc,cAAL,gCAAK,CAAlB,C;QACI,mC;;MAER,W;IAJgB,C;EAAA,C;;IAKG,iC;MACf,IAAI,SAAc,cAAL,gCAAK,CAAlB,C;QACI,mC;;MAER,W;IAJmB,C;EAAA,C;;IAKF,8C;MACb,IAAI,aAAiB,cAAL,gCAAK,CAArB,C;QACI,mC;;MAEJ,IAAI,aAAiB,cAAL,gCAAK,CAArB,C;QACI,mC;;MAER,W;IAPiB,C;EAAA,C;;IAQE,6C;MACf,IAAI,UAAc,cAAL,gCAAK,CAAlB,C;QACI,mC;;MAER,W;IAJmB,C;EAAA,C;;IAKC,uB;MAChB,mC;MACJ,W;IAFoB,C;EAAA,C;;;ICnBpB,iCAA4B,aAA5B,EAA2C,SAA3C,EAAsD,OAAtD,C;IAHI,kC;EADgC,C;;ICDD,oB;IAA+B,0B;IAAyB,sB;IAe3F,sBAAqB,iD;IAKrB,2BAA+E,iBAAjB,WAAO,UAAU,EAAiB,mBAAjB,C;IAC/E,8BAAqF,iBAApB,WAAO,aAAa,EAAiB,mBAAjB,C;IACrF,4BAAsF,iBAAlB,WAAO,WAAW,EAAiB,6CAAjB,C;IAKtF,8BAAwF,iBAApB,WAAO,aAAa,EAAiB,+CAAjB,C;IAMxF,8BAAgD,YAApB,WAAO,aAAa,EAAgD,+CAAhD,C;IAChD,+BAAkG,iBAArB,WAAO,cAAc,EAAiB,gDAAjB,C;EAlChE,C;;IACH,OAAA,WAAO,K;EAAP,C;;IAEc,OAAA,WAAO,gBAAS,aAAQ,OAAR,CAAT,C;EAAP,C;;IACgB,sB;IAA4B,gBAAI,Y;IjB4wCtF,kBAAM,eAAa,wBiB5wCsD,QjB4wCtD,EAAwB,EAAxB,CAAb,C;IAqEA,U;IAAA,SiBj1CmE,QjBi1CnE,W;IAAb,OAAa,gBAAb,C;MAAa,wB;MACT,WAAY,WAtEwC,SAsEpC,CAAU,IAAV,CAAJ,C;;IiBl1C6C,OAAO,yBjBm1C7D,WiBn1C6D,C;EAAP,C;;IAC3B,sBAAU,WAAO,aAAI,KAAJ,CAAjB,C;EAAA,C;;IACM,OAAA,WAAO,eAAQ,aAAQ,OAAR,CAAR,C;EAAP,C;;IACN,OAAA,WAAO,U;EAAP,C;;IACU,OAAA,WAAO,mBAAY,aAAQ,OAAR,CAAZ,C;EAAP,C;;IACqD,gBAAnC,WAAO,iBAAQ,SAAR,EAAmB,OAAnB,C;IAA4B,gBAAI,c;IjBuwC9F,kBAAM,eAAa,mCAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,2B;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WAtEwC,SAsEpC,CAAU,IAAV,CAAJ,C;;IiB70C8C,OAAkD,cjB80CzG,WiB90CyG,C;EAAlD,C;;IAEf,OAAsB,UAAtB,WAAO,eAAe,EAAQ,cAAR,C;EAAtB,C;;IACU,OAA2B,UAA3B,WAAO,sBAAa,KAAb,CAAoB,EAAQ,cAAR,C;EAA3B,C;;IAClB,OAAkB,UAAlB,WAAO,WAAW,EAAQ,cAAR,C;EAAlB,C;;IAOvC,+B;EAAA,C;;IACA,kC;EAAA,C;;IACA,gC;EAAA,C;;IAKA,kC;EAAA,C;;IAMA,kC;EAAA,C;;IACA,mC;EAAA,C;;;;ICjCI,iBAAI,mBAAQ,GAAR,CAAJ,EAAkB,KAAlB,C;EACJ,C;;IAII,iBAAK,KAAL,EAAc,iBAAK,KAAL,CAAd,C;EACJ,C;;IAGI,YAAY,mBAAQ,OAAR,C;IACZ,IAAI,UAAS,EAAb,C;MACI,sBAAS,KAAT,C;IACJ,OAAO,UAAS,E;EACpB,C;;;ICrB2F,iC;IAApD,wB;IAEvC,kBAAiB,4BAA2B,aAA3B,C;IACjB,oBAAmB,K;IAuLnB,gBAAe,uD;EA1LuB,C;;IAMlC,UAAU,4BAAW,KAAX,C;IACV,oBAAe,I;IACf,4BAAW,KAAX,EAAoB,OAApB,C;IACa,YAAb,iBAAa,EAAU,GAAV,EAAe,OAAf,EAAwB,KAAxB,C;IACb,iBAAa,S;IACb,OAAO,O;EACX,C;;IAGI,oBAAe,I;IACf,aAAa,eAAW,WAAI,OAAJ,C;IACxB,YAAY,eAAW,KAAX,GAAkB,CAAlB,I;IACZ,IAAI,MAAJ,C;MACc,YAAV,cAAU,EAAU,OAAV,EAAmB,KAAnB,C;MACV,iBAAa,S;;IAEjB,OAAO,M;EACX,C;;IAGI,oBAAe,I;IACf,eAAW,aAAI,KAAJ,EAAW,OAAX,C;IACD,YAAV,cAAU,EAAU,OAAV,EAAmB,KAAnB,C;IACV,iBAAa,S;EACjB,C;;IAIc,Q;IADV,YAAY,eAAW,K;IACb,0B;IAAV,OAAU,cAAV,C;MAAU,mB;MACN,oBAAe,I;MACf,eAAW,WAAI,CAAJ,C;MACD,YAAV,cAAU,EAAU,CAAV,EAAa,KAAb,C;MACV,qB;;IAEJ,iBAAa,S;IACb,OAAO,I;EACX,C;;IAIc,Q;IADV,mBAAmB,K;IACT,0B;IAAV,OAAU,cAAV,C;MAAU,mB;MACN,oBAAe,I;MACf,eAAW,aAAI,YAAJ,EAAkB,CAAlB,C;MACD,YAAV,cAAU,EAAU,CAAV,EAAa,YAAb,C;MACV,mC;;IAEJ,iBAAa,S;IACb,OAAO,I;EACX,C;;IAII,YAAY,mBAAQ,OAAR,C;IACZ,IAAI,UAAS,EAAb,C;MAAiB,OAAO,K;IACxB,oBAAe,I;IACf,eAAW,kBAAS,KAAT,C;IACE,YAAb,iBAAa,EAAU,OAAV,EAAmB,KAAnB,C;IACb,iBAAa,S;IACb,OAAO,I;EACX,C;;IAGI,oBAAe,I;IACf,cAAc,eAAW,kBAAS,KAAT,C;IACZ,YAAb,iBAAa,EAAU,OAAV,EAAmB,KAAnB,C;IACb,iBAAa,S;IACb,OAAO,O;EACX,C;;IAIoB,Q;IAAA,0B;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MACZ,YAAY,mBAAQ,OAAR,C;MACZ,IAAI,UAAS,EAAb,C;QAAiB,OAAO,K;MACxB,oBAAe,I;MACf,eAAW,kBAAS,KAAT,C;MACE,YAAb,iBAAa,EAAU,OAAV,EAAmB,KAAnB,C;;IAEjB,iBAAa,S;IACb,OAAO,I;EACX,C;;IAGI,MAAM,sC;EACV,C;;IAGI,oBAAe,I;IACf,eAAW,Q;IACG,YAAd,kBAAc,EAAU,IAAV,C;IACd,iBAAa,S;EACjB,C;;IAEkC,OAAA,eAAW,U;EAAX,C;;IACW,OAAA,eAAW,gBAAS,OAAT,C;EAAX,C;;IACgB,OAAA,eAAW,qBAAY,QAAZ,C;EAAX,C;;IACP,iCAAa,CAAb,C;EAAA,C;;IACU,oF;IAE5D,aAAY,iDAAW,sBAAa,aAAb,C;IACvB,cAAkB,a;IAClB,iBAAqB,E;IACrB,mBAAsB,I;EALsC,C;;IAQxD,2DAAe,I;IACf,UAAM,WAAI,OAAJ,C;IACO,YAAb,wDAAa,EAAU,+BAAV,EAAyB,WAAzB,C;IACb,iC;IACA,iBAAY,E;IACZ,wDAAa,S;EACjB,C;;IAEsC,OAAA,UAAM,c;EAAN,C;;IAEN,kB;EAAA,C;;IAG5B,cAAc,UAAM,W;IACpB,mBAAc,O;IACd,iBAAY,W;IACZ,iC;IACA,OAAO,O;EACX,C;;IAEoC,qBAAS,CAAT,I;EAAA,C;;IAGhC,2DAAe,I;IACf,UAAM,WAAI,OAAJ,C;IACO,YAAb,wDAAa,EAAU,+BAAV,EAAyB,OAAzB,EAAkC,cAAlC,C;IACb,wDAAa,S;EACjB,C;;IACkC,OAAA,UAAM,U;EAAN,C;;IAE9B,cAAc,UAAM,O;IACpB,mBAAc,O;IACd,iBAAY,W;IACZ,iC;IACA,OAAO,O;EACX,C;;IAGI,IAAI,mBAAa,EAAjB,C;MAAqB,MAAM,8B;IAC3B,2DAAe,I;IACf,UAAM,S;IACO,YAAb,wDAAa,EAAU,+BAAV,EAAyB,cAAzB,C;IACb,wDAAa,S;IACb,cAAS,c;IACT,iBAAY,E;EAChB,C;;;IArD4D,oF;EAAA,C;;IAyDlB,iCAAa,CAAb,C;EAAA,C;;IAEuB,OAAA,eAAW,iBAAQ,SAAR,EAAmB,OAAnB,C;EAAX,C;;IACnC,mCAAW,KAAX,C;EAAA,C;;IACM,OAAA,eAAW,eAAQ,OAAR,C;EAAX,C;;IACI,OAAA,eAAW,mBAAY,OAAZ,C;EAAX,C;;IACb,OAAA,eAAW,K;EAAX,C;;IAG3B,oBAAe,I;IACf,IAAK,WAAW,Q;IAChB,oBAAe,I;IACf,IAAK,WAAW,gBAAO,UAAP,C;IACF,YAAd,kBAAc,EAAU,IAAV,C;IACd,iBAAa,S;EACjB,C;;IAGI,oBAAe,I;IACf,WAAW,eAAW,kBAAS,SAAT,C;IACtB,oBAAe,I;IACf,eAAW,aAAI,OAAJ,EAAa,IAAb,C;IACA,YAAX,eAAW,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,C;IACX,iBAAa,S;EACjB,C;;IAYI,aAAS,WAAI,aAAJ,C;EACb,C;;IAGI,aAAS,cAAO,aAAP,C;EACb,C;;IAGI,cAAS,aAAS,MAAlB,C;EACJ,C;;IAnBqB,uB;MACjB,IAAG,mDAAH,C;QACI,sDAAe,K;QACf,M;;MAEU,YAAd,oDAAc,EAAU,sCAAV,C;MACd,mDAAa,S;MACjB,W;IAPqB,C;EAAA,C;;;;;IC1KjB,8B;MAAiB,gBAAS,CAAO,IAAP,C;MAAa,W;IAAvC,C;EAAA,C;;IAAA,gF;EACJ,C;;IAF4E,OAAU,iBAAV,cAAU,EAAiB,wDAAjB,C;EAAV,C;;IAIxE,mC;MAAsB,gBAAS,CAAO,GAAP,EAAY,IAAZ,C;MAAkB,W;IAAjD,C;EAAA,C;;IAAA,mF;EACJ,C;;IAFqF,OAAa,iBAAb,iBAAa,EAAiB,2DAAjB,C;EAAb,C;;IAIjF,8B;MAAiB,gBAAS,CAAO,IAAP,C;MAAa,W;IAAvC,C;EAAA,C;;IAAA,mF;EACJ,C;;IAF+E,OAAa,iBAAb,iBAAa,EAAiB,2DAAjB,C;EAAb,C;;IAG6B,qB;MAAE,0B;IAAF,C;EAAA,C;;IAAvB,OAAa,YAAb,iBAAa,EAAU,iEAAV,C;EAAb,C;;IAEjF,uB;MAAU,gBAAS,CAAO,mBAAP,C;MAAa,W;IAAhC,C;EAAA,C;;IAD0H,2B;MAC1H,yG;IAD0H,C;EAAA,C;;IAA/B,OAAc,iBAAd,kBAAc,EAAiB,kEAAjB,C;EAAd,C;;;ICtBlE,oB;EAAD,C;;ICDiD,iC;IAA7C,wB;IAwBhC,gBAAe,gD;EAxBgB,C;;IAEnB,OAAA,aAAS,MAAM,K;EAAf,C;;IAEiC,OAAA,aAAS,MAAM,gBAAS,OAAT,C;EAAf,C;;IAEgB,OAAA,aAAS,MAAM,qBAAY,QAAZ,C;EAAf,C;;IAE3B,OAAA,aAAS,MAAM,aAAI,KAAJ,C;EAAf,C;;IAEM,OAAA,aAAS,MAAM,eAAQ,OAAR,C;EAAf,C;;IAEN,OAAA,aAAS,MAAM,U;EAAf,C;;IAEK,OAAA,aAAS,MAAM,W;EAAf,C;;IAEK,OAAA,aAAS,MAAM,mBAAY,OAAZ,C;EAAf,C;;IAEG,OAAA,aAAS,MAAM,e;EAAf,C;;IAEU,OAAA,aAAS,MAAM,sBAAa,KAAb,C;EAAf,C;;IAEK,OAAA,aAAS,MAAM,iBAAQ,SAAR,EAAmB,OAAnB,C;EAAf,C;;IAQ1D,aAAS,WAAI,aAAJ,C;EACb,C;;IAGI,aAAS,cAAO,aAAP,C;EACb,C;;IAGI,cAAS,aAAS,MAAlB,C;EACJ,C;;IAfe,uB;MACG,YAAd,6CAAc,EAAU,+BAAV,C;MACd,4CAAa,S;MACjB,W;IAHe,C;EAAA,C;;;ICnBX,0B;MAAA,aC6EgD,kB;;ID7EhD,4B;IAGJ,2BAAyB,c;IACzB,8BAA4B,c;IAC5B,4BAA0B,c;IAC1B,8BAA4B,gCAA+C,+CAA/C,EAA+E,iDAA/E,C;IAC5B,+BAA6B,c;IAC7B,8BAA4B,c;EATF,C;;IAI1B,+B;EAAA,C;;IACA,kC;EAAA,C;;IACA,gC;EAAA,C;;IACA,kC;EAAA,C;;IACA,mC;EAAA,C;;IACA,kC;EAAA,C;;IAGI,UAAU,4BAAW,KAAX,C;IACV,4BAAW,KAAX,EAAoB,OAApB,C;IACa,YAAb,iBAAa,EAAU,GAAV,EAAe,OAAf,EAAwB,KAAxB,C;IACA,OAAb,iBAAa,C;IACb,OAAO,O;EACX,C;;IAGI,aAAa,eAAW,WAAI,OAAJ,C;IACxB,YAAY,eAAW,KAAX,GAAkB,CAAlB,I;IACZ,IAAI,MAAJ,C;MACc,YAAV,cAAU,EAAU,OAAV,EAAmB,KAAnB,C;MACG,OAAb,iBAAa,C;;IAEjB,OAAO,M;EACX,C;;IAGI,eAAW,aAAI,KAAJ,EAAW,OAAX,C;IACD,YAAV,cAAU,EAAU,OAAV,EAAmB,KAAnB,C;IACG,OAAb,iBAAa,C;EACjB,C;;IAIc,Q;IADV,YAAY,eAAW,K;IACb,0B;IAAV,OAAU,cAAV,C;MAAU,mB;MACN,eAAW,WAAI,CAAJ,C;MACD,YAAV,cAAU,EAAU,CAAV,EAAa,KAAb,C;MACV,qB;;IAES,OAAb,iBAAa,C;IACb,OAAO,I;EACX,C;;IAIc,Q;IADV,mBAAmB,K;IACT,0B;IAAV,OAAU,cAAV,C;MAAU,mB;MACN,eAAW,aAAI,YAAJ,EAAkB,CAAlB,C;MACD,YAAV,cAAU,EAAU,CAAV,EAAa,YAAb,C;MACV,mC;;IAES,OAAb,iBAAa,C;IACb,OAAO,I;EACX,C;;IAII,YAAY,mBAAQ,OAAR,C;IACZ,IAAI,UAAS,EAAb,C;MAAiB,OAAO,K;IACxB,eAAW,kBAAS,KAAT,C;IACE,YAAb,iBAAa,EAAU,OAAV,EAAmB,KAAnB,C;IACA,OAAb,iBAAa,C;IACb,OAAO,I;EACX,C;;IAGI,cAAc,eAAW,kBAAS,KAAT,C;IACZ,YAAb,iBAAa,EAAU,OAAV,EAAmB,KAAnB,C;IACA,OAAb,iBAAa,C;IACb,OAAO,O;EACX,C;;IAIoB,Q;IAAA,0B;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MACZ,YAAY,mBAAQ,OAAR,C;MACZ,IAAI,UAAS,EAAb,C;QAAiB,OAAO,K;MACxB,eAAW,kBAAS,KAAT,C;MACE,YAAb,iBAAa,EAAU,OAAV,EAAmB,KAAnB,C;;IAEJ,OAAb,iBAAa,C;IACb,OAAO,I;EACX,C;;IAGI,MAAM,sC;EACV,C;;IAGI,eAAW,Q;IACG,YAAd,kBAAc,EAAU,IAAV,C;IACD,OAAb,iBAAa,C;EACjB,C;;IAEkC,OAAA,eAAW,U;EAAX,C;;IACW,OAAA,eAAW,gBAAS,OAAT,C;EAAX,C;;IACgB,OAAA,eAAW,qBAAY,QAAZ,C;EAAX,C;;IACP,iCAAa,CAAb,C;EAAA,C;;IACU,4D;IAE5D,aAAY,qCAAW,sBAAa,aAAb,C;IACvB,cAAkB,a;IAClB,iBAAqB,E;IACrB,mBAAsB,I;EALsC,C;;IAQxD,UAAM,WAAI,OAAJ,C;IACO,YAAb,4CAAa,EAAU,+BAAV,EAAyB,WAAzB,C;IACb,iC;IACA,iBAAY,E;IACC,OAAb,4CAAa,C;EACjB,C;;IAEsC,OAAA,UAAM,c;EAAN,C;;IAEN,kB;EAAA,C;;IAG5B,cAAc,UAAM,W;IACpB,mBAAc,O;IACd,iBAAY,W;IACZ,iC;IACA,OAAO,O;EACX,C;;IAEoC,qBAAS,CAAT,I;EAAA,C;;IAGhC,UAAM,WAAI,OAAJ,C;IACO,YAAb,4CAAa,EAAU,+BAAV,EAAyB,OAAzB,EAAkC,cAAlC,C;IACA,OAAb,4CAAa,C;EACjB,C;;IACkC,OAAA,UAAM,U;EAAN,C;;IAE9B,cAAc,UAAM,O;IACpB,mBAAc,O;IACd,iBAAY,W;IACZ,iC;IACA,OAAO,O;EACX,C;;IAGI,IAAI,mBAAa,EAAjB,C;MAAqB,MAAM,8B;IAC3B,UAAM,S;IACO,YAAb,4CAAa,EAAU,+BAAV,EAAyB,cAAzB,C;IACA,OAAb,4CAAa,C;IACb,cAAS,c;IACT,iBAAY,E;EAChB,C;;;IAlD4D,wE;EAAA,C;;IAsDlB,iCAAa,CAAb,C;EAAA,C;;IAEuB,OAAA,eAAW,iBAAQ,SAAR,EAAmB,OAAnB,C;EAAX,C;;IACnC,mCAAW,KAAX,C;EAAA,C;;IACM,OAAA,eAAW,eAAQ,OAAR,C;EAAX,C;;IACI,OAAA,eAAW,mBAAY,OAAZ,C;EAAX,C;;IACb,OAAA,eAAW,K;EAAX,C;;IAG3B,IAAK,WAAW,Q;IAChB,IAAK,WAAW,gBAAO,UAAP,C;IACF,YAAd,kBAAc,EAAU,IAAV,C;IACD,OAAb,iBAAa,C;EACjB,C;;IAGI,WAAW,eAAW,kBAAS,SAAT,C;IACtB,eAAW,aAAI,OAAJ,EAAa,IAAb,C;IACA,YAAX,eAAW,EAAU,IAAV,EAAgB,SAAhB,EAA2B,OAA3B,C;IACE,OAAb,iBAAa,C;EACjB,C;;IAvK2E,mB;MAAE,iC;IAAF,C;EAAA,C;;IAAgC,qB;MAAE,2CAAQ,EAAR,C;MAAY,W;IAAd,C;EAAA,C;;;IELrE,yB;IAFlC,oB;IACA,oB;IAcJ,0BAAgJ,yCAAL,IAAK,C;IAChJ,6BAAgG,yCAAL,IAAK,C;IAChG,6BAA0C,6C;IAC1C,8BAAoG,yCAAL,IAAK,C;IAEpG,yBAAuB,uBACN,IADM,EAEc,0CAFd,C;IAIvB,sBAAoB,qBACH,IADG,EAEiB,uCAFjB,C;IAIpB,wBAAsB,uBACL,IADK,EAEe,yCAFf,C;IAKtB,kBAAiB,c;IAqCjB,+BAAkD,0D;IAGlD,kCAA2D,6D;IAe3D,kCAAqD,6D;IAWrD,mCAAqE,wD;EApGxC,C;;IAK7B,oB;IAAsF,2BAA0E,yCAAL,WAAK,C;EAAhK,C;;ICII,oB;IACA,4D;IAcJ,iCAAkH,iBAAhB,WAAO,SAAS,EAAiB,sDAAjB,C;IAGlH,oCAAuJ,iBAAhB,WAAO,SAAS,EAAiB,yDAAjB,C;IAGvJ,oCAAwH,iBAAnB,WAAO,YAAY,EAAiB,yDAAjB,C;IAGxH,oCAA8H,YAAnB,WAAO,YAAY,EAAU,yDAAV,C;IAC9H,qCAAyI,iBAApB,WAAO,aAAa,EAAiB,0DAAjB,C;EA1BxG,C;;IAyF7B,oB;IACA,4D;IAgEJ,iCAAsF,iBAAhB,WAAO,SAAS,EAAiB,8CAAjB,C;IAGtF,oCAA+E,kB;IAC/E,oCAA4F,iBAAnB,WAAO,YAAY,EAAiB,iDAAjB,C;IAG5F,oCAAkG,YAAnB,WAAO,YAAY,EAAU,uDAAV,C;IAClG,qCAA6G,iBAApB,WAAO,aAAa,EAAiB,wDAAjB,C;EA1E9E,C;;IAiF3B,oB;IACA,4D;IAiEJ,iCAAsF,iBAAhB,WAAO,SAAS,EAAiB,gDAAjB,C;IAGtF,oCAC+F,iBAAhB,WAAO,SAAS,EAAiB,mDAAjB,C;IAG/F,wG;IA+CA,oCAAkG,YAAnB,WAAO,YAAY,EAAU,yDAAV,C;IAClG,qCAA6G,iBAApB,WAAO,aAAa,EAAiB,0DAAjB,C;EA1H5E,C;;IC9KE,oB;IAAkC,8B;IACrE,WC2DwD,oB;ED5DtB,C;;IAGH,OAAA,WAAO,K;EAAP,C;;IAG3B,aAAa,iBAAY,OAAZ,C;IACb,QCkLJ,aDlLQ,OCkLR,EDlLmB,MCkLnB,C;IDjLI,OAAO,WAAO,WAAI,MAAJ,C;EAClB,C;;IAG0B,gBAAI,gB;I3BowCvB,kBAAM,eAAa,wB2BpwCT,Q3BowCS,EAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,O2Bz0CI,Q3By0CJ,W;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WAtEwC,SAsEpC,CAAU,IAAV,CAAJ,C;;I2B10CZ,a3B20CG,W;I2B10CC,OAAJ,QAAI,EAAgB,IAAT,QAAS,EAAI,MAAJ,CAAhB,C;IACJ,OAAO,WAAO,gBAAO,MAAP,C;EAClB,C;;IAEkD,gBAAP,W;IAAO,gBAAO,QAAI,cAAO,OAAP,C;IEPhC,Q;IFOc,OEPgB,CAA9B,sEAA8B,eAAO,SAAP,C;EFOhB,C;;IACgB,sB;I3B8vCpD,kBAAM,eAAa,wB2B9vCkD,Q3B8vClD,EAAwB,EAAxB,CAAb,C;IAqEA,U;IAAA,S2Bn0C+D,Q3Bm0C/D,W;IAAb,OAAa,gBAAb,C;MAAa,wB;MACT,WAAY,W2Bp0C2E,mB3Bo0C7D,I2Bp0C6D,C3Bo0C3E,C;;I6Bj0Ca,U;IFH8B,OEGA,CAA9B,qEAA8B,oB7Bk0CpD,W6Bl0CoD,C;EFHA,C;;IACA,sB;I3B6vCpD,kBAAM,eAAa,wB2B7vCkD,Q3B6vClD,EAAwB,EAAxB,CAAb,C;IAqEA,U;IAAA,S2Bl0C+D,Q3Bk0C/D,W;IAAb,OAAa,gBAAb,C;MAAa,wB;MACT,WAAY,W2Bn0C2E,mB3Bm0C7D,I2Bn0C6D,C3Bm0C3E,C;;I6BtzCa,U;IFb8B,OEaA,CAA9B,qEAA8B,oB7BuzCpD,W6BvzCoD,C;EFbA,C;;IAEd,MAAM,2BAAsB,cAAtB,C;EAAN,C;;IACgB,MAAM,2BAAsB,cAAtB,C;EAAN,C;;IAC3B,MAAM,2BAAsB,cAAtB,C;EAAN,C;;IACX,MAAM,2BAAsB,cAAtB,C;EAAN,C;;IACuB,MAAM,2BAAsB,cAAtB,C;EAAN,C;;;IAGwB,sCAA2B,SAA3B,EAAiC,WAAjC,C;EAAA,C;;IGN/D,gC;IAAA,gC;EAAA,C;;IAC+B,OAAA,iBAAa,U;EAAb,C;;IACT,yBAAK,iBAAa,OAAlB,C;EAAA,C;;;IAF7B,mD;EAIJ,C;;IAeW,gC;IAAA,gC;EAAA,C;;IACmC,OAAA,iBAAa,c;EAAb,C;;IACN,OAAA,iBAAa,Y;EAAb,C;;IACH,yBAAK,iBAAa,WAAlB,C;EAAA,C;;IACO,OAAA,iBAAa,gB;EAAb,C;;IACF,OAAA,iBAAa,U;EAAb,C;;IACT,yBAAK,iBAAa,OAAlB,C;EAAA,C;;;IAN7B,mD;EAQJ,C;;IC3DA,qC;EAAA,C;;IAG0C,Q;IAAA,wE;EAAA,C;;IAG1B,Q;EAAA,C;;IAEoC,Y;EAAA,C;;IACgB,Y;EAAA,C;;IAC9B,W;EAAA,C;;IACS,Y;EAAA,C;;IACgB,Y;EAAA,C;;EAE3D,C;;EACiD,C;;IACX,Y;EAAA,C;;IACL,MAAM,sC;EAAN,C;;EACN,C;;;IAHsB,yD;EAAA,C;;IAKH,Y;EAAA,C;;IACgB,Y;EAAA,C;;IACA,Y;EAAA,C;;;;IAtBlE,4C;MAAA,2B;;IAAA,qC;EAAA,C;;ICWI,oC;IAHI,8B;IACA,8B;IACA,sB;IAGJ,uBAAqB,aAAQ,gBAAY,MAApB,EAA2B,gBAAY,MAAvC,C;IAOrB,iBAAgB,iD;IAGhB,iBAAgB,iD;EAhBqB,C;;IAMrC,2B;EAAA,C;IAAA,4B;EAAA,C;;IAGI,aAAQ,aAAQ,gBAAY,MAApB,EAA2B,gBAAY,MAAvC,C;IhC2hDI,Q;IAAA,sB;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MAAa,OgC1hDZ,CAAO,UAAP,C;;EACjB,C;;IAUI,aAAQ,aAAQ,gBAAY,MAApB,EAA2B,gBAAY,MAAvC,C;IACR,gBAAY,WAAI,cAAJ,C;IACZ,gBAAY,WAAI,cAAJ,C;EAChB,C;;IAGI,gBAAY,cAAO,cAAP,C;IACZ,gBAAY,cAAO,cAAP,C;EAChB,C;;IAhBgB,uB;MACZ,wC;MACJ,W;IAFgB,C;EAAA,C;;IAGA,uB;MACZ,wC;MACJ,W;IAFgB,C;EAAA,C;;;ICXhB,oC;IAJI,8B;IACA,8B;IACA,8B;IACA,sB;IAGJ,uBAAqB,aAAQ,gBAAY,MAApB,EAA2B,gBAAY,MAAvC,EAA8C,gBAAY,MAA1D,C;IAOrB,iBAAgB,iD;IAGhB,iBAAgB,iD;IAGhB,iBAAgB,iD;EApBwB,C;;ICIxC,oC;IAFI,8B;IACA,sB;IAKJ,uBAAqB,c;IAOrB,iBAAgB,c;EAdmB,C;;ICDH,4B;IAAgD,2BAAgC,mCAAsB,c;EAAvG,C;;IAAC,2B;EAAA,C;;IAAgD,oC;EAAA,C;;IAAA,kD;EAAA,C;;IAAA,wD;EAAA,C;;IAAA,uC;EAAA,C;;IAAA,uD;EAAA,C;;IAAA,6D;EAAA,C;;IAAA,yC;EAAA,C;;IAAA,0C;EAAA,C;;IAAA,qD;EAAA,C;;IAAA,2D;EAAA,C;;IAAA,2D;EAAA,C;;;ICAL,2BAAY,kB;IAEvF,qBAAwB,I;EAN5B,C;;ICQiB,2B;MACT,IAAG,oBAAS,QAAZ,C;QACI,IAAG,QAAH,C;UACI,gB;;;UAEA,iB;;QAEJ,kBAAQ,Q;;MAEhB,W;IATa,C;EAAA,C;;ICgBA,mB;MAAE,gBAAS,WAAI,gBAAJ,C;MAAe,gBAAS,CAAO,gBAAS,MAAhB,C;MAAuB,W;IAA1D,C;EAAA,C;;IACC,mB;MAAE,gBAAS,cAAO,gBAAP,C;MAAiB,W;IAA5B,C;EAAA,C;;IDlBd,gBAAoB,KAApB,C;IACA,aAAa,iCCgBA,iCDhBA,ECiBC,iCDjBD,C;IAUb,OAAO,eAAP,C;IACA,oBAAI,MAAJ,C;ICIA,ODHO,M;ECGP,C;;IDfa,2B;MACT,IAAG,oBAAS,QAAZ,C;QACI,IAAG,QAAH,C;UACI,gB;;;UAEA,iB;;QAEJ,kBAAQ,Q;;MAEhB,W;IATa,C;EAAA,C;;IECA,mB;MAAE,gBAAS,WAAI,YAAJ,C;MAAU,W;IAArB,C;EAAA,C;;IACC,mB;MAAE,gBAAS,cAAO,YAAP,C;MAAa,W;IAAxB,C;EAAA,C;;IFHd,gBAAoB,KAApB,C;IACA,aAAa,iCECA,+BFDA,EEEC,+BFFD,C;IAUb,OAAO,eAAP,C;IACA,oBAAI,MAAJ,C;IEXA,OFYO,M;EEZP,C;;ICRI,wB;EADwB,C;;IAIxB,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;I7B+E9B,S6B9EK,sB7B8EL,S6B9EqB,4BAAhB,C;IADP,a7BgFG,S;E6B7EP,C;;IAGI,sBAAiB,KAAA,aAAS,MAAT,EAAiB,OAAjB,C;IACjB,OAAO,I;EACX,C;;IAGI,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;I7BoE9B,S6BnEK,4B;IADP,a7BqEG,S;E6BlEP,C;;IAGI,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;I7B8D9B,S6B7DK,gC;IADP,a7B+DG,S;I6B5DH,OAAO,I;EACX,C;;IAGI,sBAAiB,OAAA,aAAS,MAAT,EAAiB,QAAjB,C;IACjB,OAAO,I;EACX,C;;IAGI,sBhB4CkC,W;EgB3CtC,C;;IAGI,iBAAa,KAAb,C;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7B4CF,S6B5Cc,sB;IADhB,a7B8CG,S;I6B3CH,OAAO,Q;EACX,C;;IAGI,iBAAa,KAAb,C;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7BoCF,S6BpCc,4B;IADhB,a7BsCG,S;I6BnCH,OAAO,Q;EACX,C;;IAGI,sB;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7B4BF,S6B5Bc,wB;IADhB,a7B8BG,S;I6B3BH,OAAO,Q;EACX,C;;IAGI,iBAAa,KAAb,C;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7BoBF,S6BpBc,4B;IADhB,a7BsBG,S;I6BnBH,OAAO,Q;EACX,C;;IAGI,sB;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7BYF,S6BZc,4B;IADhB,a7BcG,S;I6BXH,OAAO,Q;EACX,C;;IAGI,sBAA4B,SAAX,UAAW,C;EAChC,C;;IAGY,OAAA,aAAS,MAAM,K;EAAf,C;;IAEiC,OAAA,aAAS,MAAM,gBAAS,OAAT,C;EAAf,C;;IAEgB,OAAA,aAAS,MAAM,qBAAY,QAAZ,C;EAAf,C;;IAE3B,OAAA,aAAS,MAAM,aAAI,KAAJ,C;EAAf,C;;IAEM,OAAA,aAAS,MAAM,eAAQ,OAAR,C;EAAf,C;;IAEN,OAAA,aAAS,MAAM,U;EAAf,C;;IAEY,0B;EAAA,C;;IAEF,OAAA,aAAS,MAAM,mBAAY,OAAZ,C;EAAf,C;;IAEU,iCAAa,CAAb,C;EAAA,C;;IAEU,gE;IAC5D,oBAAmB,gBAAQ,CAAR,I;EADyC,C;;IAE1B,QAAC,oBAAe,CAAf,IAAD,IAAqB,0CAAS,MAAM,K;EAApC,C;;IAET,OAAA,0CAAS,MAAT,cAAe,6CAAf,EAAe,iBAAf,E;EAAA,C;;IAGrB,qD;IAAgD,gBAAhB,cAAf,0CAAS,MAAM,C;I7BvBlC,S6BuB4D,kBAAS,iBAAT,C;IAA1D,a7BtBD,S;I6BuBC,6C;EACJ,C;;IAGI,qD;IAAgD,gBAAhB,cAAf,0CAAS,MAAM,C;I7B5BlC,S6B4B4D,aAAI,iBAAJ,U;IAA1D,a7B3BD,S;I6B4BC,6C;EACJ,C;;IAEsC,2BAAe,C;EAAf,C;;IAEN,wB;EAAA,C;;IAEY,Q;IAAf,OAAA,0CAAS,MAAT,cAAe,wBAAf,EAAe,gCAAf,Q;EAAA,C;;IAEO,2BAAe,CAAf,I;EAAA,C;;IAGhC,qD;IAAgD,gBAAhB,cAAf,0CAAS,MAAM,C;I7BzClC,S6ByCyD,aAAG,iBAAH,U;IAAvD,a7BxCD,S;E6ByCH,C;;;IA1B4D,0E;EAAA,C;;IAgCxD,0B;MAAA,aAAsB,C;IACtB,iC;MAAA,oBAA6B,C;IAF7B,wB;IACA,4B;IACA,0C;EAHQ,C;;IAMqB,mBAAO,eAAP,I;EAAA,C;;IACA,mBAAO,eAAP,I;EAAA,C;;IAG7B,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;I7BxDlC,S6ByDS,aALsB,UAAO,eAAP,IAKtB,E7BzDT,S6ByDyC,kBALV,YAAO,eAAP,IAKU,CAAhC,C;IADP,a7BvDD,S;E6B0DH,C;;IAGI,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;I7B9DlC,S6B+DS,aAAI,sBAAJ,U;IADP,a7B7DD,S;I6BgEC,uD;IACA,OAAO,I;EACX,C;;IAGI,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;I7BtElC,S6BuES,aAnBsB,QAAO,eAAP,IAmBtB,U;IADP,a7BrED,S;I6BwEC,uD;EACJ,C;;IAGI,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;I7B7ElC,S6B8ES,gBA1BsB,QAAO,eAAP,IA0BtB,W;IADP,a7B5ED,S;I6B+EC,kDAAqB,QAAS,KAA9B,I;IACA,OAAO,I;EACX,C;;IAGI,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;I7BrFlC,S6BsFS,gBAAO,sBAAP,W;IADP,a7BpFD,S;I6BuFC,kDAAqB,QAAS,KAA9B,I;IACA,OAAO,I;EACX,C;;IAGI,sBhBnG8B,W;EgBoGlC,C;;IAGI,iBAAa,KAAb,C;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7BnGN,S6BmGkB,sB;IADhB,a7BjGD,S;I6BoGC,IAAG,QAAH,C;MAAW,uD;;IACX,OAAO,Q;EACX,C;;IAGI,iBAAa,KAAb,C;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7B5GN,S6B4GkB,4B;IADhB,a7B1GD,S;I6B6GC,OAAO,Q;EACX,C;;IAGI,sB;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7BpHN,S6BoHkB,kBAhEa,QAAO,eAAP,IAgEb,C;IADhB,a7BlHD,S;I6BqHC,uD;IACA,OAAO,Q;EACX,C;;IAGI,iBAAa,KAAb,C;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7B7HN,S6B6HkB,4B;IADhB,a7B3HD,S;I6B8HC,OAAO,Q;EACX,C;;IAGI,sB;IACA,wB;IAAgD,gBAAhB,cAAf,aAAS,MAAM,C;IAC5B,W7BrIN,S6BqIkB,aAjFa,QAAO,eAAP,IAiFb,U;IADhB,a7BnID,S;I6BsIC,OAAO,Q;EACX,C;;IAEyC,6C;EAAA,C;;IAG7B,gCAAoB,eAApB,I;EAAA,C;;IAEiC,c;;MxC4uCjC,Q;MADhB,IAAI,mCAAsB,cAA1B,C;QAAqC,aAAO,K;QAAP,e;;MACrB,sB;MAAhB,OAAgB,cAAhB,C;QAAgB,2B;QAAM,IwC5uCiC,OxC4uCnB,SwC5uCmB,UxC4uCjC,C;UAAwB,aAAO,I;UAAP,e;;;MAC9C,aAAO,K;;;IwC7uC0C,iB;EAAA,C;;IAEyB,c;;MxCqtC1D,Q;MADhB,IAAI,cwCptC6D,QxCotC7D,iBwCptC6D,QxCotCvC,UAA1B,C;QAAqC,aAAO,I;QAAP,e;;MACrB,OwCrtCiD,QxCqtCjD,W;kBAAhB,OAAgB,cAAhB,C;QAAgB,yB;QwCrtC2E,c;;UxC0uC3E,U;UADhB,IAAI,mCAAsB,cAA1B,C;YAAqC,aAAO,K;YAAP,e;;UACrB,wB;UAAhB,OAAgB,gBAAhB,C;YAAgB,6B;YAAM,IwC1uC2E,OxC0uC7D,SwC1uC6D,ExCqtC5D,OwCrtC4D,CxC0uC3E,C;cAAwB,aAAO,I;cAAP,e;;;UAC9C,aAAO,K;;;QAtBe,IAAI,WAAJ,C;UAAyB,aAAO,K;UAAP,e;;;MAC/C,aAAO,I;;;IwCttC0D,iB;EAAA,C;;IAE3B,OAAA,aAAS,MAAM,aAAI,KA/FpB,GAAO,eAAP,IA+FgB,C;EAAf,C;;IAEM,OAAA,aAAS,MAAM,eAAQ,OAAR,CAhGtB,GAAO,eAAP,I;EAgGO,C;;IAEN,2BAAc,sB;EAAd,C;;IAEY,0B;EAAA,C;;IAEF,OAAA,aAAS,MAAM,mBAAY,OAAZ,CAtG1B,GAAO,eAAP,I;EAsGW,C;;IAEU,iCAAa,CAAb,C;EAAA,C;;IAEU,gC;IAC5D,oBAAmB,CAAA,aA5GU,GAAO,uBAAP,IA4GV,IAAwB,CAAxB,I;EADyC,C;;IAE1B,QAAC,oBAAe,CAAf,IAAD,IAAqB,mC;EAArB,C;;IAET,OAAA,0BAAS,MAAT,cAAe,6CAAf,EAAe,iBAAf,E;EAAA,C;;IAGrB,qC;IAAgD,gBAAhB,cAAf,0BAAS,MAAM,C;I7BtKtC,S6BsKgE,kBAAS,iBAAT,C;IAA1D,a7BrKL,S;I6BsKK,6C;EACJ,C;;IAGI,qC;IAAgD,gBAAhB,cAAf,0BAAS,MAAM,C;I7B3KtC,S6B2KgE,aAAI,iBAAJ,U;IAA1D,a7B1KL,S;I6B2KK,6C;EACJ,C;;IAEsC,4BAAgB,4B;EAAhB,C;;IAEN,wB;EAAA,C;;IAEY,Q;IAAf,OAAA,0BAAS,MAAT,cAAe,wBAAf,EAAe,gCAAf,Q;EAAA,C;;IAEO,2BAAe,CAAf,I;EAAA,C;;IAGhC,qC;IAAgD,gBAAhB,cAAf,0BAAS,MAAM,C;I7BxLtC,S6BwL6D,aAAG,iBAAH,U;IAAvD,a7BvLL,S;E6BwLC,C;;;IA1B4D,kF;EAAA,C;;IA6BK,2CAAQ,aAAR,EAAkB,SAxItD,GAAO,eAAP,IAwIoC,EAA6C,OAxIjF,GAAO,eAAP,IAwIoC,C;EAAA,C;;;IAGJ,2CAAQ,aAAR,EAAkB,SAAlB,EAA6B,OAA7B,C;EAAA,C;;;;;;;;;ICzQrE,0B;IACA,0B;IAC8B,2BAAY,kB;EAHV,C;;IAMpB,uB;EAAA,C;IAGY,Q;IADhB,eAAU,KAAV,C;IACgB,sB;IAAhB,OAAgB,cAAhB,C;MAAgB,0B;MACZ,QAAS,CAAO,KAAP,C;;EAEjB,C;;IAT0B,oC;EAAA,C;;IAAA,kD;EAAA,C;;IAAA,wD;EAAA,C;;IAAA,uC;EAAA,C;;IAAA,uD;EAAA,C;;IAAA,6D;EAAA,C;;IAAA,yC;EAAA,C;;IAAA,0C;EAAA,C;;IAAA,qD;EAAA,C;;IAAA,2D;EAAA,C;;IAAA,2D;EAAA,C;;;ICDA,2BAAY,kB;IAE1C,uBAAwB,S;EAJY,C;;IAIpC,2B;EAAA,C;IAGwB,Q;IADhB,uBAAQ,K;IACQ,sB;IAAhB,OAAgB,cAAhB,C;MAAgB,0B;MACZ,QAAS,CAAO,KAAP,C;;EAEjB,C;;IAR0B,oC;EAAA,C;;IAAA,kD;EAAA,C;;IAAA,wD;EAAA,C;;IAAA,uC;EAAA,C;;IAAA,uD;EAAA,C;;IAAA,6D;EAAA,C;;IAAA,yC;EAAA,C;;IAAA,0C;EAAA,C;;IAAA,qD;EAAA,C;;IAAA,2D;EAAA,C;;IAAA,2D;EAAA,C;;;ICC9B,oC;IAFI,wC;IACA,oB;IAGJ,kBAAyC,I;IAWzC,qBAAoB,gD;IAKpB,qBAAoB,gD;EArBS,C;;ICI7B,oC;IAHI,4B;IACA,8B;IACA,4C;IAQJ,gBAAe,wD;EAX2B,C;;IAM9B,wBAAY,eAAW,MAAvB,C;EAAA,C;IAEJ,wBAAmB,wBAAmB,KAAnB,C;EACvB,C;;IAQA,eAAW,WAAI,aAAJ,C;EACf,C;;IAGI,eAAW,cAAO,aAAP,C;EACf,C;;IAXe,oB;MACX,cAAc,oDAAY,CAAZ,C;M5CqhDF,Q;MAAA,yD;MAAhB,OAAgB,cAAhB,C;QAAgB,yB;QAAa,O4CphDZ,S;;MACjB,W;IAHe,C;EAAA,C;;;IAef,OAAO,uCAAmC,SAAnC,EAAyC,MAAzC,EAAiD,aAAjD,C;EACX,C;;IC3BI,oC;IAFI,4B;IACA,8B;IAKJ,gBAAe,iD;EAPoB,C;;IAKvB,wBAAY,eAAW,MAAvB,C;EAAA,C;;IAQR,eAAW,WAAI,aAAJ,C;EACf,C;;IAGI,eAAW,cAAO,aAAP,C;EACf,C;;IAXe,oB;MACX,cAAc,6CAAY,CAAZ,C;M7C4hDF,Q;MAAA,kD;MAAhB,OAAgB,cAAhB,C;QAAgB,yB;QAAa,O6C3hDZ,S;;MACjB,W;IAHe,C;EAAA,C;;;IAef,OAAO,gCAA4B,SAA5B,EAAkC,MAAlC,C;EACX,C;;IC5BoB,Q;IADhB,aAAa,e;IACG,2B;IAAhB,OAAgB,cAAhB,C;MAAgB,0B;MACZ,QAAS,CAAO,MAAP,C;;EAEjB,C;;ICGI,0B;IACA,0B;IACA,kB;EAHqC,C;;IAOzB,uB;EAAA,C;IAEJ,eAAU,KAAV,C;EACJ,C;;IAN0B,sB;EAAA,C;;IAAA,oC;EAAA,C;;IAAA,0C;EAAA,C;;IAAA,yB;EAAA,C;;IAAA,yC;EAAA,C;;IAAA,+C;EAAA,C;;IAAA,2B;EAAA,C;;IAAA,4B;EAAA,C;;IAAA,uC;EAAA,C;;IAAA,6C;EAAA,C;;IAAA,6C;EAAA,C;;;ICN1B,qB;MAAA,QAA4C,kB;IAD5C,0B;IACA,kB;EAF0B,C;;ICQ9B,gCAA2B,aAA3B,EAA0C,SAA1C,EAAqD,OAArD,C;IAHI,kC;EAD+B,C;;ICE/B,oB;IACA,0B;IACA,sB;IAQJ,iCAA6F,iBAAvB,WAAO,gBAAgB,EAAiB,iDAAjB,C;IAG7F,oCAAyG,iBAA1B,WAAO,mBAAmB,EAAiB,oDAAjB,C;IAGzG,oCAAmG,iBAA1B,WAAO,mBAAmB,EAAiB,oDAAjB,C;IAGnG,oCAAyG,YAA1B,WAAO,mBAAmB,EAAU,oDAAV,C;IACzG,qCAAoH,iBAA3B,WAAO,oBAAoB,EAAiB,qDAAjB,C;EArBnF,C;;IAKF,OAAA,WAAO,K;EAAP,C;;IACc,OAAA,WAAO,gBAAqB,YvCmFlE,CuCnFsD,OvCmFtD,CuCnF6C,C;EAAP,C;;IACgB,sB;IAA4B,gBAAI,Y;IlD2wCtF,kBAAM,eAAa,wBkD3wCsD,QlD2wCtD,EAAwB,EAAxB,CAAb,C;IAqEA,U;IAAA,SkDh1CmE,QlDg1CnE,W;IAAb,OAAa,gBAAb,C;MAAa,wB;MACT,WAAY,WAtEwC,SAsEpC,CAAU,IAAV,CAAJ,C;;IkDj1C6C,OAAO,yBlDk1C7D,WkDl1C6D,C;EAAP,C;;IAC3B,OAAA,WAAO,U;EAAP,C;;IACK,OAAkB,UAAlB,WAAO,WAAW,EAAQ,cAAR,C;EAAlB,C;;IAEvC,qC;EAAA,C;;IAGA,wC;EAAA,C;;IAGA,wC;EAAA,C;;IAGA,wC;EAAA,C;;IACA,yC;EAAA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}