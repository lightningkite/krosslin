{"version":3,"file":"kotlinx-io.js","sources":["kotlin/UShort.kt","kotlin/UInt.kt","kotlin/ULong.kt","../../../../../common/src/kotlinx/io/charsets/Encoding.kt","text/StringBuilder.kt","util/Preconditions.kt","../../../../../common/src/kotlinx/io/core/Buffers.kt","generated/_ComparisonsJs.kt","../../../../../common/src/kotlinx/io/core/Input.kt","../../../../../common/src/kotlinx/io/core/Packet.kt","../../../../../js/src/kotlinx/io/bits/ByteOrderJS.kt","../../../../../common/src/kotlinx/io/core/Builder.kt","util/Standard.kt","../../../../../common/src/kotlinx/io/core/Output.kt","../../../../../common/src/kotlinx/io/core/internal/Require.kt","../../../../../common/src/kotlinx/io/core/Copy.kt","../../../../../common/src/kotlinx/io/core/InputLittleEndian.kt","../../../../../common/src/kotlinx/io/core/OutputLittleEndian.kt","../../../../../common/src/kotlinx/io/core/internal/UTF8.kt","../../../../../common/src/kotlinx/io/core/Strings.kt","kotlin/UByte.kt","../../../../../common/src/kotlinx/io/core/UnsignedTypes.kt","generated/_UArrays.kt","../../../../../common/src/kotlinx/io/core/internal/Unsafe.kt","../../../../../common/src/kotlinx/io/pool/Pool.kt","../../../../../src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","kotlin/numbers.kt","../../../../../js/src/kotlinx/io/charsets/CharsetJS.kt","text/Strings.kt","../../../../../js/src/kotlinx/io/js/TextDecoders.kt","../../../../../js/src/kotlinx/io/core/IoBufferJS.kt","../../../../../js/src/kotlinx/io/charsets/ISO88591.kt","org.w3c/org.khronos.webgl.kt","../../../../../js/src/kotlinx/io/core/ByteOrderJS.kt","../../../../../js/src/kotlinx/io/core/ByteReadPacket.kt","../../../../../js/src/kotlinx/io/core/Input.kt","../../../../../js/src/kotlinx/io/core/ScannerJS.kt","../../../../../js/src/kotlinx/io/core/StringsJS.kt","../../../../../js/src/kotlinx/io/errors/IOException.kt","../../../../../js/src/kotlinx/io/js/TextEncoders.kt","../../../../../js/src/kotlinx/io/js/TypedArrays.kt","../../../../../js/src/kotlinx/io/js/WebSockets.kt","../../../../../js/src/kotlinx/io/js/XMLHttpRequest.kt","org.w3c/org.w3c.xhr.kt","../../../../../js/src/kotlinx/io/pool/DefaultPool.kt"],"sourcesContent":["/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","package kotlinx.io.charsets\n\nimport kotlinx.io.core.*\n\nexpect abstract class Charset {\n    @ExperimentalIoApi\n    abstract fun newEncoder(): CharsetEncoder\n\n    @ExperimentalIoApi\n    abstract fun newDecoder(): CharsetDecoder\n\n    companion object {\n        fun forName(name: String): Charset\n    }\n}\n\nexpect val Charset.name: String\n\n// ----------------------------- ENCODER -------------------------------------------------------------------------------\n@ExperimentalIoApi\nexpect abstract class CharsetEncoder\n\nexpect val CharsetEncoder.charset: Charset\n\n@Deprecated(\n    \"Use writeText on Output instead.\",\n    ReplaceWith(\"dst.writeText(input, fromIndex, toIndex, charset)\", \"kotlinx.io.core.writeText\")\n)\nfun CharsetEncoder.encode(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Output) {\n     encodeToImpl(dst, input, fromIndex, toIndex)\n}\n\nprivate val EmptyByteArray = ByteArray(0)\n\n@ExperimentalIoApi\nexpect fun CharsetEncoder.encodeToByteArray(input: CharSequence,\n                                            fromIndex: Int = 0,\n                                            toIndex: Int = input.length): ByteArray\n\n@Deprecated(\n    \"Internal API. Will be hidden in future releases. Use encodeToByteArray instead.\",\n    replaceWith = ReplaceWith(\"encodeToByteArray(input, fromIndex, toIndex)\")\n)\nfun CharsetEncoder.encodeToByteArrayImpl(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    return encodeToByteArray(input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\nexpect fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output)\n\n@ExperimentalIoApi\nfun CharsetEncoder.encode(input: CharSequence, fromIndex: Int = 0, toIndex: Int = input.length) = buildPacket {\n    encodeToImpl(this, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\nfun CharsetEncoder.encodeUTF8(input: ByteReadPacket) = buildPacket {\n    encodeUTF8(input, this)\n}\n\n// ----------------------------- DECODER -------------------------------------------------------------------------------\n\n@ExperimentalIoApi\nexpect abstract class CharsetDecoder\n\n/**\n * Decoder's charset it is created for.\n */\nexpect val CharsetDecoder.charset: Charset\n\n@ExperimentalIoApi\nfun CharsetDecoder.decode(input: Input, max: Int = Int.MAX_VALUE): String = buildString(minOf(max.toLong(), input.sizeEstimate()).toInt()) {\n    decode(input, this, max)\n}\n\n@ExperimentalIoApi\nexpect fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int\n\n@ExperimentalIoApi\nexpect fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String\n\n// ----------------------------- REGISTRY ------------------------------------------------------------------------------\nexpect object Charsets {\n    val UTF_8: Charset\n    val ISO_8859_1: Charset\n}\n\nexpect class MalformedInputException(message: String) : Throwable\n\n\n\n\n\n\n\n// ----------------------------- INTERNALS -----------------------------------------------------------------------------\n\n\ninternal expect fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: IoBuffer): Int\n\ninternal expect fun CharsetEncoder.encodeComplete(dst: IoBuffer): Boolean\n\ninternal fun CharsetEncoder.encodeToByteArrayImpl1(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    var start = fromIndex\n    if (start >= toIndex) return EmptyByteArray\n    val single = IoBuffer.Pool.borrow()\n\n    try {\n        IoBuffer.NoPool\n        val rc = encodeImpl(input, start, toIndex, single)\n        start += rc\n        if (start == toIndex) {\n            val result = ByteArray(single.readRemaining)\n            single.readFully(result)\n            return result\n        }\n\n        val builder = BytePacketBuilder(0, IoBuffer.Pool)\n        builder.last(single.makeView())\n        encodeToImpl(builder, input, start, toIndex)\n        return builder.build().readBytes()\n    } finally {\n        single.release(IoBuffer.Pool)\n    }\n}\n\ninternal fun Input.sizeEstimate(): Long = when (this) {\n    is ByteReadPacket -> remaining\n    is ByteReadPacketBase -> maxOf(remaining, 16)\n    else -> 16\n}\n\n\nprivate fun CharsetEncoder.encodeCompleteImpl(dst: Output): Int {\n    var size = 1\n    var bytesWritten = 0\n\n    dst.writeWhile { view ->\n        val before = view.writeRemaining\n        if (encodeComplete(view)) {\n            size = 0\n        } else {\n            size++\n        }\n        bytesWritten += before - view.writeRemaining\n        size > 0\n    }\n\n    return bytesWritten\n}\n\n\ninternal fun CharsetEncoder.encodeToImpl(\n    destination: Output,\n    input: CharSequence,\n    fromIndex: Int,\n    toIndex: Int\n): Int {\n    var start = fromIndex\n    if (start >= toIndex) return 0\n\n    var bytesWritten = 0\n\n    destination.writeWhileSize(1) { view: IoBuffer ->\n        val before = view.writeRemaining\n        val rc = encodeImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n        bytesWritten += before - view.writeRemaining\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    bytesWritten += encodeCompleteImpl(destination)\n    return bytesWritten\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String =\n    StringBuilder().apply(builderAction).toString()\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String =\n    StringBuilder(capacity).apply(builderAction).toString()\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.pool.*\n\n@Deprecated(\n    \"Use IoBuffer instead\",\n    replaceWith = ReplaceWith(\"IoBuffer\", \"kotlinx.io.core.IoBuffer\"),\n    level = DeprecationLevel.ERROR\n)\ntypealias BufferView = IoBuffer\n\n/**\n * A read-write facade to actual buffer of fixed size. Multiple views could share the same actual buffer.\n * Concurrent unsafe. The only concurrent-safe operation is [release].\n * In most cases [ByteReadPacket] and [BytePacketBuilder] should be used instead.\n */\nexpect class IoBuffer : Input, Output {\n    @Deprecated(\"Suppress warning.\", level = DeprecationLevel.HIDDEN)\n    final override val doNotImplementInputButExtendAbstractInputInstead: Nothing\n\n    @Deprecated(\"Suppress warning.\", level = DeprecationLevel.HIDDEN)\n    final override val doNotImplementOutputButExtendAbstractOutputInstead: Nothing\n\n    /**\n     * Reference to an origin buffer view this was copied from\n     */\n    internal val origin: IoBuffer?\n\n    /**\n     * Mutable reference to next buffer view. Useful to chain multiple views\n     */\n    var next: IoBuffer?\n\n    /**\n     * User data: could be a session, connection or anything useful\n     */\n    @ExperimentalIoApi\n    var attachment: Any?\n\n    /**\n     * Backing buffer capacity. Value for released buffer is unspecified\n     */\n    val capacity: Int\n\n    /**\n     * Amount of reserved bytes at the beginning\n     */\n    val startGap: Int\n\n    /**\n     * Amount of reserved bytes at the end\n     */\n    val endGap: Int\n\n    /**\n     * @return `true` if there are available bytes to be read\n     */\n    fun canRead(): Boolean\n\n    /**\n     * @return `true` if there is free room to for write\n     */\n    fun canWrite(): Boolean\n\n    /**\n     * Number of bytes available for read\n     */\n    val readRemaining: Int\n\n    /**\n     * Number of free bytes useful for writing. Doesn't include gaps.\n     */\n    val writeRemaining: Int\n\n    /**\n     * Reserves [n] bytes at the beginning. Could be invoked only once and only before writing.\n     */\n    fun reserveStartGap(n: Int)\n\n    /**\n     * Reserves [n] bytes at the end of buffer. Could be invoked only once and only if there are at least [n] bytes free\n     */\n    fun reserveEndGap(n: Int)\n\n    /**\n     * read and write operations byte-order (endianness)\n     */\n    @Deprecated(\"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n        \"do readXXX/writeXXX with X.reverseByteOrder() instead.\")\n    final override var byteOrder: ByteOrder\n\n    final override fun readByte(): Byte\n    final override fun readShort(): Short\n    final override fun readInt(): Int\n    final override fun readLong(): Long\n    final override fun readFloat(): Float\n    final override fun readDouble(): Double\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    fun read(dst: ByteArray, offset: Int, length: Int)\n\n    final override fun readFully(dst: ByteArray, offset: Int, length: Int)\n    final override fun readFully(dst: ShortArray, offset: Int, length: Int)\n    final override fun readFully(dst: IntArray, offset: Int, length: Int)\n    final override fun readFully(dst: LongArray, offset: Int, length: Int)\n    final override fun readFully(dst: FloatArray, offset: Int, length: Int)\n    final override fun readFully(dst: DoubleArray, offset: Int, length: Int)\n    final override fun readFully(dst: IoBuffer, length: Int)\n\n    final override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int\n    final override fun readAvailable(dst: IoBuffer, length: Int): Int\n\n    final override fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * If the underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun peekTo(buffer: IoBuffer): Int\n\n    @Deprecated(\"Use discardExact instead.\")\n    final override fun discard(n: Long): Long\n\n    /**\n     * Discards [n] bytes or fails if there is not enough bytes available for read.\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun discardExact(n: Int)\n\n    final override fun writeByte(v: Byte)\n    final override fun writeShort(v: Short)\n    final override fun writeInt(v: Int)\n    final override fun writeLong(v: Long)\n    final override fun writeFloat(v: Float)\n    final override fun writeDouble(v: Double)\n\n    final override fun writeFully(src: ByteArray, offset: Int, length: Int)\n    final override fun writeFully(src: ShortArray, offset: Int, length: Int)\n    final override fun writeFully(src: IntArray, offset: Int, length: Int)\n    final override fun writeFully(src: LongArray, offset: Int, length: Int)\n    final override fun writeFully(src: FloatArray, offset: Int, length: Int)\n    final override fun writeFully(src: DoubleArray, offset: Int, length: Int)\n    final override fun writeFully(src: IoBuffer, length: Int)\n\n    fun appendChars(csq: CharArray, start: Int, end: Int): Int\n    fun appendChars(csq: CharSequence, start: Int, end: Int): Int\n\n    final override fun append(c: Char): Appendable\n    final override fun append(csq: CharSequence?): Appendable\n    final override fun append(csq: CharSequence?, start: Int, end: Int): Appendable\n    final override fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    final override fun fill(n: Long, v: Byte)\n\n    override fun close()\n\n    /**\n     * Writes exactly [length] bytes of [array] starting from [offset] position or fails if not enough free space\n     */\n    @Deprecated(\"Use writeFully instead\", level = DeprecationLevel.ERROR)\n    fun write(array: ByteArray, offset: Int, length: Int)\n\n    /**\n     * Writes [length] bytes of [src] buffer or fails if not enough free space available\n     */\n    @Deprecated(\"Use writeFully instead\", ReplaceWith(\"writeFully(src, length)\"), level = DeprecationLevel.ERROR)\n    fun writeBuffer(src: IoBuffer, length: Int): Int\n\n    internal fun restoreStartGap(n: Int)\n    internal fun restoreEndGap(n: Int)\n\n    internal fun writeBufferPrepend(other: IoBuffer)\n    internal fun writeBufferAppend(other: IoBuffer, maxSize: Int)\n\n    /**\n     * Push back [n] bytes: only possible if there were at least [n] bytes read before this operation.\n     */\n    fun pushBack(n: Int)\n\n    /**\n     * Marks the whole buffer available for write and no bytes for read.\n     */\n    fun resetForWrite()\n\n    /**\n     * Marks up to [limit] bytes of the buffer available for write and no bytes for read\n     */\n    fun resetForWrite(limit: Int)\n\n    /**\n     * Marks the whole buffer available for read and no for write\n     */\n    fun resetForRead()\n\n    /**\n     * @return `true` if and only if the are no buffer views that share the same actual buffer. This actually does\n     * refcount and only work guaranteed if other views created/not created via [makeView] function.\n     * One can instantiate multiple buffers with the same buffer and this function will return `true` in spite of\n     * the fact that the buffer is actually shared.\n     */\n    @ExperimentalIoApi\n    fun isExclusivelyOwned(): Boolean\n\n    /**\n     * Creates a new view to the same actual buffer with independent read and write positions and gaps\n     */\n    fun makeView(): IoBuffer\n\n    /**\n     * releases buffer view and returns it to the [pool] if there are no more usages. Based on simple ref-couting so\n     * it is very fragile.\n     */\n    fun release(pool: ObjectPool<IoBuffer>)\n\n    final override fun flush()\n\n    companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [IoBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @Deprecated(\"This implementation detail is going to become internal.\")\n        val ReservedSize: Int\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        val Empty: IoBuffer\n\n        /**\n         * The default buffer pool\n         */\n        val Pool: ObjectPool<IoBuffer>\n\n        /**\n         * Pool that always instantiates new buffers instead of reusing it\n         */\n        val NoPool: ObjectPool<IoBuffer>\n\n        /**\n         * A pool that always returns [IoBuffer.Empty]\n         */\n        val EmptyPool: ObjectPool<IoBuffer>\n    }\n}\n\n@Deprecated(\n    \"Use IoBuffer.EmptyPool instead.\",\n    replaceWith = ReplaceWith(\"IoBuffer.EmptyPool\", \"kotlinx.io.core.IoBuffer\"),\n    level = DeprecationLevel.ERROR\n)\nval EmptyBufferViewPool get() = IoBuffer.EmptyPool\n\ninternal object EmptyBufferPoolImpl : NoPoolImpl<IoBuffer>() {\n    override fun borrow() = IoBuffer.Empty\n}\n\ninternal tailrec fun IoBuffer?.releaseAll(pool: ObjectPool<IoBuffer>) {\n    if (this == null) return\n    val next = next\n    this.next = null\n    release(pool)\n    next.releaseAll(pool)\n}\n\n/**\n * Copy every element of the chain starting from this and setup next links.\n */\ninternal fun IoBuffer.copyAll(): IoBuffer {\n    val copied = makeView()\n    val next = this.next ?: return copied\n\n    return next.copyAll(copied, copied)\n}\n\nprivate tailrec fun IoBuffer.copyAll(head: IoBuffer, prev: IoBuffer): IoBuffer {\n    val copied = makeView()\n    prev.next = copied\n\n    val next = this.next ?: return head\n\n    return next.copyAll(head, copied)\n}\n\ninternal tailrec fun IoBuffer.findTail(): IoBuffer {\n    val next = this.next ?: return this\n    return next.findTail()\n}\n\n/**\n * Summarize remainings of all elements of the chain\n */\n@DangerousInternalIoApi\nfun IoBuffer.remainingAll(): Long = remainingAll(0L)\n\nprivate tailrec fun IoBuffer.remainingAll(n: Long): Long {\n    val rem = readRemaining.toLong() + n\n    val next = this.next ?: return rem\n\n    return next.remainingAll(rem)\n}\n\ninternal tailrec fun IoBuffer.isEmpty(): Boolean {\n    if (readRemaining > 0) return false\n    val next = this.next ?: return true\n    return next.isEmpty()\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxInt(): Int = minOf(this, Int.MAX_VALUE.toLong()).toInt()\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxIntOrFail(message: String): Int {\n    if (this > Int.MAX_VALUE.toLong()) throw IllegalArgumentException(message)\n    return this.toInt()\n}\n\nclass BufferLimitExceededException(message: String) : Exception(message)\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the smaller of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\n\n/**\n * Shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\nexpect interface Input : Closeable {\n    @Deprecated(\n        \"Implementing this interface is highly experimental. Extend AbstractInput instead.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    val doNotImplementInputButExtendAbstractInputInstead: Nothing\n\n    @Deprecated(\"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\")\n    var byteOrder: ByteOrder\n    val endOfInput: Boolean\n\n    fun readByte(): Byte\n    fun readShort(): Short\n    fun readInt(): Int\n    fun readLong(): Long\n    fun readFloat(): Float\n    fun readDouble(): Double\n\n    fun readFully(dst: ByteArray, offset: Int, length: Int)\n    fun readFully(dst: ShortArray, offset: Int, length: Int)\n    fun readFully(dst: IntArray, offset: Int, length: Int)\n    fun readFully(dst: LongArray, offset: Int, length: Int)\n    fun readFully(dst: FloatArray, offset: Int, length: Int)\n    fun readFully(dst: DoubleArray, offset: Int, length: Int)\n    fun readFully(dst: IoBuffer, length: Int = dst.writeRemaining)\n\n    fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: IntArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: LongArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int\n    fun readAvailable(dst: IoBuffer, length: Int): Int\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * The underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available.\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun peekTo(buffer: IoBuffer): Int\n\n    /**\n     * Discard at most [n] bytes\n     */\n    @Deprecated(\"Use discardExact instead.\")\n    fun discard(n: Long): Long\n\n    override fun close()\n}\n\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    return readFully(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readFully(dst: IoBuffer, length: Int = dst.writeRemaining) {\n    return readFully(dst, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Input.readAvailable(dst: IoBuffer, length: Int = dst.writeRemaining): Int {\n    return readAvailable(dst, length)\n}\n\n/**\n * Discard all remaining bytes.\n *\n * @return number of bytes were discarded\n */\nfun Input.discard(): Long {\n    @Suppress(\"DEPRECATION\")\n    return discard(Long.MAX_VALUE)\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes available.\n *\n * @throws EOFException when not enough bytes available to discard the specified number of bytes.\n */\nfun Input.discardExact(n: Long) {\n    @Suppress(\"DEPRECATION\")\n    val discarded = discard(n)\n    if (discarded != n) {\n        throw EOFException(\"Only $discarded bytes were discarded of $n requested\")\n    }\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes available.\n *\n * @throws EOFException when not enough bytes available to discard the specified number of bytes.\n */\nfun Input.discardExact(n: Int) {\n    discardExact(n.toLong())\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return `false`\n * [block] function returns `true` to request more chunks or `false` to stop loop\n *\n * It is not guaranteed that every chunk will have fixed size but it will be never empty.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@Deprecated(\"This is going to become internal. Use peekTo instead.\")\ninline fun Input.takeWhile(block: (IoBuffer) -> Boolean) {\n    var release = true\n    var current = prepareReadFirstHead(1) ?: return\n\n    try {\n        do {\n            if (!block(current)) {\n                break\n            }\n            release = false\n            val next = prepareReadNextHead(current) ?: break\n            current = next\n            release = true\n        } while (true)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return zero\n * [block] function returns number of bytes required to read next primitive and shouldn't require too many bytes at once\n * otherwise it could fail with an exception.\n * It is not guaranteed that every chunk will have fixed size but it will be always at least requested bytes length.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@Deprecated(\"This is going to become internal. Use peekTo instead.\")\ninline fun Input.takeWhileSize(initialSize: Int = 1, block: (IoBuffer) -> Int) {\n    var release = true\n    var current = prepareReadFirstHead(initialSize) ?: return\n    var size = initialSize\n\n    try {\n        do {\n            val before = current.readRemaining\n            val after: Int\n\n            if (before >= size) {\n                try {\n                    size = block(current)\n                } finally {\n                    after = current.readRemaining\n                }\n            } else {\n                after = before\n            }\n\n            release = false\n\n            val next = when {\n                after == 0 -> prepareReadNextHead(current)\n                after < size || current.endGap < IoBuffer.ReservedSize -> {\n                    completeReadHead(current)\n                    prepareReadFirstHead(size)\n                }\n                else -> current\n            }\n\n            if (next == null) {\n                release = false\n                break\n            }\n\n            current = next\n            release = true\n        } while (size > 0)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n@ExperimentalIoApi\nfun Input.peekCharUtf8(): Char {\n    val rc = tryPeek()\n    if (rc and 0x80 == 0) return rc.toChar()\n    if (rc == -1) throw EOFException(\"Failed to peek a char: end of input\")\n\n    return peekCharUtf8Impl(rc)\n}\n\nprivate fun Input.peekCharUtf8Impl(first: Int): Char {\n    var rc = '?'\n    var found = false\n\n    takeWhileSize(byteCountUtf8(first)) {\n        it.decodeUTF8 { ch ->\n            found = true\n            rc = ch\n            false\n        }\n    }\n\n    if (!found) {\n        throw MalformedUTF8InputException(\"No UTF-8 character found\")\n    }\n\n    return rc\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.errors.IOException\nimport kotlinx.io.pool.*\n\n/**\n * Read-only immutable byte packet. Could be consumed only once however it does support [copy] that doesn't copy every byte\n * but creates a new view instead. Once packet created it should be either completely read (consumed) or released\n * via [release].\n */\n@DangerousInternalIoApi\nabstract class ByteReadPacketBase(@PublishedApi internal var head: IoBuffer,\n                                  remaining: Long = head.remainingAll(),\n                                  val pool: ObjectPool<IoBuffer>) : Input {\n\n    init {\n        head.setByteOrderForNonEmpty(ByteOrder.BIG_ENDIAN)\n    }\n\n    @Deprecated(\n        \"Suppress warning.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    @Suppress(\"unused\")\n    final override val doNotImplementInputButExtendAbstractInputInstead: Nothing\n        get() = error(\"Should be never accessed.\")\n\n    @Deprecated(\"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\")\n    final override var byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            field = newOrder\n            head.setByteOrderForNonEmpty(newOrder)\n        }\n\n    /**\n     * Number of bytes available for read\n     */\n    val remaining: Long get() = headRemaining.toLong() + tailRemaining\n\n    @Deprecated(\"For compatibility purpose\", level = DeprecationLevel.HIDDEN)\n    fun getRemaining(): Int = remaining.coerceAtMostMaxInt()\n\n    /**\n     * @return `true` if there is at least one byte to read\n     */\n    fun canRead() = tailRemaining != 0L || head.canRead()\n\n    /**\n     * @return `true` if there are at least [n] bytes to read\n     */\n    fun hasBytes(n: Int) = headRemaining + tailRemaining >= n\n\n    @PublishedApi\n    internal var headRemaining = head.readRemaining\n\n    private var tailRemaining: Long = remaining - headRemaining\n\n    /**\n     * `true` if no bytes available for read\n     */\n    val isEmpty: Boolean\n        get() = headRemaining == 0 && tailRemaining == 0L && noMoreChunksAvailable\n\n    val isNotEmpty: Boolean\n        get() = headRemaining > 0 || tailRemaining > 0L || !noMoreChunksAvailable\n\n    private var noMoreChunksAvailable = false\n    override val endOfInput: Boolean\n        get() = isEmpty && (noMoreChunksAvailable || doFill() == null)\n\n    /**\n     * Returns a copy of the packet. The original packet and the copy could be used concurrently. Both need to be\n     * either completely consumed or released via [release]\n     */\n    fun copy(): ByteReadPacket = ByteReadPacket(head.copyAll(), remaining, pool)\n\n    /**\n     * Release packet. After this function invocation the packet becomes empty. If it has been copied via [copy]\n     * then the copy should be released as well.\n     */\n    fun release() {\n        val head = head\n        val empty = IoBuffer.Empty\n\n        if (head !== empty) {\n            this.head = empty\n            headRemaining = 0\n            tailRemaining = 0\n            head.releaseAll(pool)\n        }\n    }\n\n    override fun close() {\n        release()\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n        closeSource()\n    }\n\n    internal fun stealAll(): IoBuffer? {\n        val head = head\n        val empty = IoBuffer.Empty\n\n        if (head === empty) return null\n        this.head = empty\n        headRemaining = 0\n        tailRemaining = 0\n        return head\n    }\n\n    internal fun steal(): IoBuffer? {\n        val head = head\n        val next = head.next\n        val empty = IoBuffer.Empty\n        if (head === empty) return null\n\n        val nextRemaining = next?.readRemaining ?: 0\n\n        this.head = next ?: empty\n        this.headRemaining = nextRemaining\n        this.tailRemaining -= nextRemaining\n        head.next = null\n\n        return head\n    }\n\n    internal fun append(chain: IoBuffer) {\n        if (chain === IoBuffer.Empty) return\n\n        val size = chain.remainingAll()\n        if (head === IoBuffer.Empty) {\n            head = chain\n            headRemaining = chain.readRemaining\n            tailRemaining = size - headRemaining\n        } else {\n            head.findTail().next = chain\n            tailRemaining += size\n        }\n        @Suppress(\"DEPRECATION\")\n        chain.byteOrder = byteOrder\n    }\n\n    internal fun tryWriteAppend(chain: IoBuffer): Boolean {\n        val tail = head.findTail()\n        val size = chain.readRemaining\n\n        if (size == 0 || tail.writeRemaining < size) return false\n        tail.writeBufferAppend(chain, size)\n\n        if (head === tail) {\n            headRemaining += size\n        } else {\n            tailRemaining += size\n        }\n\n        return true\n    }\n\n    final override fun readByte(): Byte {\n        val headRemaining = headRemaining\n        if (headRemaining > 1) {\n            this.headRemaining = headRemaining - 1\n            return head.readByte()\n        }\n\n        return readByteSlow2()\n    }\n\n    private fun readByteSlow2(): Byte {\n        val head = head\n        val headRemaining = headRemaining\n\n        if (headRemaining == 1) {\n            this.headRemaining = headRemaining - 1\n            return head.readByte().also { ensureNext(head) }\n        } else {\n            return readByteSlow(head)\n        }\n    }\n\n    private fun readByteSlow(head: IoBuffer): Byte {\n        ensureNext(head) ?: throw EOFException(\"One more byte required but reached end of input\")\n        return readByte()\n    }\n\n    final override fun readShort() = readN(2) { readShort() }\n    final override fun readFloat() = readN(4) { readFloat() }\n    final override fun readDouble() = readN(8) { readDouble() }\n\n    final override fun readInt(): Int {\n        val headRemaining = headRemaining\n        if (headRemaining > 4) {\n            this.headRemaining = headRemaining - 4\n            return head.readInt()\n        }\n\n        return readIntSlow()\n    }\n\n    private fun readIntSlow(): Int = readN(4) { readInt() }\n\n    final override fun readLong(): Long {\n        val headRemaining = headRemaining\n        if (headRemaining > 8) {\n            this.headRemaining = headRemaining - 8\n            return head.readLong()\n        }\n\n        return readLongSlow()\n    }\n\n    private fun readLongSlow(): Long = readN(8) { readLong() }\n\n    /**\n     * Read as much bytes as possible to [dst] array\n     * @return number of bytes copied\n     */\n    fun readAvailable(dst: ByteArray): Int = readAvailable(dst, 0, dst.size)\n\n    /**\n     * Read at most [length] bytes to [dst] array and write them at [offset]\n     * @return number of bytes copied to the array\n     */\n    final override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length <= dst.size) { \"offset ($offset) + length ($length) > dst.size (${dst.size})\" }\n\n        return readAsMuchAsPossible(dst, offset, length, 0)\n    }\n\n    /**\n     * Read exactly [length] bytes to [dst] array at specified [offset]\n     */\n    final override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc != length) throw EOFException(\"Not enough data in packet to fill buffer: ${length - rc} more bytes required\")\n    }\n\n    /**\n     * Discards at most [n] bytes\n     * @return number of bytes has been discarded\n     */\n    @Deprecated(\"Use discardExact instead.\")\n    final fun discard(n: Int) = discardAsMuchAsPossible(n, 0)\n\n    /**\n     * Discards exactly [n] bytes or fails with [EOFException]\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final fun discardExact(n: Int) {\n        if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes due to end of packet\")\n    }\n\n    @PublishedApi\n    internal inline fun read(block: (IoBuffer) -> Unit) {\n        read(1, block)\n    }\n\n    @PublishedApi\n    internal inline fun read(n: Int, block: (IoBuffer) -> Unit) {\n        val head = head\n        var before = head.readRemaining\n        val buffer = if (before < n) {\n            prepareRead(n, head).also { before = it?.readRemaining ?: 0 }\n        } else {\n            head\n        }\n\n        if (buffer != null) {\n            block(buffer)\n            val after = buffer.readRemaining\n            val delta = before - after\n            if (delta > 0) {\n                headRemaining -= delta\n            }\n            if (after == 0) {\n                ensureNext(buffer)\n            }\n        }\n    }\n\n    final override fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while reading $length bytes\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length short integers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: IntArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while read $length short integers\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length integers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: LongArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while reading $length long integers\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length long integers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while read $length float number\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length float numbers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc == -1) throw EOFException(\"Unexpected EOF while reading $length double float numbers\")\n            copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length double numbers, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, offset, length)\n        }\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    final override fun readFully(dst: IoBuffer, length: Int) {\n        require(length <= dst.writeRemaining) { \"Not enough free space in destination buffer to write $length bytes\" }\n\n        var copied = 0\n        takeWhile { buffer ->\n            val rc = buffer.readAvailable(dst, length - copied)\n            if (rc > 0) copied += rc\n            copied < length\n        }\n\n        if (copied != length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes, $copied were copied\")\n        }\n    }\n\n    final override fun readAvailable(dst: IoBuffer, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) {\n            if (doFill() == null) return -1\n            return readAvailable(dst, length)\n        }\n        val size = minOf(remaining, length.toLong(), dst.writeRemaining.toLong()).toInt()\n        readFully(dst, size)\n        return size\n    }\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    final override fun tryPeek(): Int {\n        val head = head\n        if (headRemaining > 0) {\n            return head.tryPeek()\n        }\n\n        if (tailRemaining == 0L && noMoreChunksAvailable) return -1\n\n        return prepareRead(1, head)?.tryPeek() ?: -1\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    @Deprecated(\"Use discardExact instead.\")\n    final override fun discard(n: Long): Long {\n        return discardAsMuchAsPossible(minOf(Int.MAX_VALUE.toLong(), n).toInt(), 0).toLong()\n    }\n\n    internal fun readCbuf(cbuf: CharArray, off: Int, len: Int): Int {\n        if (isEmpty) return -1\n\n        val out = object : Appendable {\n            private var idx = off\n\n            override fun append(c: Char): Appendable {\n                cbuf[idx++] = c\n                return this\n            }\n\n            override fun append(csq: CharSequence?): Appendable {\n                if (csq is String) {\n                    csq.getCharsInternal(cbuf, idx)\n                    idx += csq.length\n                }\n                else if (csq != null) {\n                    for (i in 0 until csq.length) {\n                        cbuf[idx++] = csq[i]\n                    }\n                }\n\n                return this\n            }\n\n            override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n                throw UnsupportedOperationException()\n            }\n        }\n\n        return readText(out, 0, len)\n    }\n\n    /**\n     * Read at least [min] and at most [max] characters and append them to [out]\n     * @return number of characters appended\n     */\n    fun readText(out: Appendable, min: Int = 0, max: Int = Int.MAX_VALUE): Int {\n        if (max.toLong() >= remaining) {\n            val s = readTextExactBytes(bytesCount = remaining.toInt())\n            out.append(s)\n            return s.length\n        }\n        return readASCII(out, min, max)\n    }\n\n    /**\n     * Read exactly [exactCharacters] characters and append them to [out]\n     */\n    fun readTextExact(out: Appendable, exactCharacters: Int) {\n        readText(out, exactCharacters, exactCharacters)\n    }\n\n    /**\n     * Read a string at last [min] and at most [max] characters length\n     */\n    fun readText(min: Int = 0, max: Int = Int.MAX_VALUE): String {\n        if (min == 0 && (max == 0 || isEmpty)) return \"\"\n        val remaining = remaining\n        if (remaining > 0 && max.toLong() >= remaining) return readTextExactBytes(bytesCount = remaining.toInt())\n\n        return buildString(min.coerceAtLeast(16).coerceAtMost(max)) {\n            readASCII(this, min, max)\n        }\n    }\n\n    /**\n     * Read a string exactly [exactCharacters] length\n     */\n    fun readTextExact(exactCharacters: Int): String {\n        return readText(exactCharacters, exactCharacters)\n    }\n\n    private fun readASCII(out: Appendable, min: Int, max: Int): Int {\n        when {\n            max == 0 && min == 0 -> return 0\n            isEmpty -> if (min == 0) return 0 else atLeastMinCharactersRequire(min)\n            max < min -> minShouldBeLess(min, max)\n        }\n\n        var copied = 0\n        var utf8 = false\n\n        takeWhile { buffer ->\n            val rc = buffer.decodeASCII {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                rc -> true\n                copied == max -> false\n                else -> {\n                    utf8 = true\n                    false\n                }\n            }\n        }\n\n        if (utf8) {\n            return copied + readUtf8(out, min - copied, max - copied)\n        }\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n        return copied\n    }\n\n    internal final fun peekToImpl(destination: IoBuffer, offset: Int, min: Int, max: Int): Int {\n        var current: IoBuffer = head\n        var copied = 0\n        var skip = offset\n\n        while (copied < min) {\n            val chunkSize = current.readRemaining\n            if (chunkSize > skip) {\n                val size = minOf(chunkSize - skip, max - copied)\n                current.readFully(destination, size)\n                skip = 0\n                copied += size\n            } else {\n                skip -= chunkSize\n            }\n\n            current = current.next ?: break\n        }\n\n        return copied\n    }\n\n    private fun atLeastMinCharactersRequire(min: Int): Nothing =\n        throw EOFException(\"at least $min characters required but no bytes available\")\n\n    private fun minShouldBeLess(min: Int, max: Int): Nothing =\n        throw IllegalArgumentException(\"min should be less or equal to max but min = $min, max = $max\")\n\n    private fun prematureEndOfStreamChars(min: Int, copied: Int): Nothing = throw MalformedUTF8InputException(\n        \"Premature end of stream: expected at least $min chars but had only $copied\"\n    )\n\n    private fun prematureEndOfStream(size: Int): Nothing =\n        throw MalformedUTF8InputException(\"Premature end of stream: expected $size bytes\")\n\n    private fun readUtf8(out: Appendable, min: Int, max: Int): Int {\n        var copied = 0\n\n        takeWhileSize { buffer ->\n            val size = buffer.decodeUTF8 {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                size == 0 -> 1\n                size > 0 -> size\n                else -> 0\n            }\n        }\n\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n\n        return copied\n    }\n\n    private tailrec fun discardAsMuchAsPossible(n: Int, skipped: Int): Int {\n        if (n == 0) return skipped\n        val current = prepareRead(1) ?: return skipped\n        val size = minOf(current.readRemaining, n)\n        current.discardExact(size)\n        headRemaining -= size\n        afterRead()\n\n        return discardAsMuchAsPossible(n - size, skipped + size)\n    }\n\n    private tailrec fun readAsMuchAsPossible(array: ByteArray, offset: Int, length: Int, copied: Int): Int {\n        if (length == 0) return copied\n        val current = prepareRead(1) ?: return copied\n        val size = minOf(length, current.readRemaining)\n\n        current.readFully(array, offset, size)\n        headRemaining -= size\n\n        return if (size != length || current.readRemaining == 0) {\n            afterRead()\n            readAsMuchAsPossible(array, offset + size, length - size, copied + size)\n        } else {\n            copied + size\n        }\n    }\n\n    private inline fun <R> readN(n: Int, block: IoBuffer.() -> R): R {\n        val bb = prepareRead(n) ?: notEnoughBytesAvailable(n)\n        val rc = block(bb)\n\n        val after = bb.readRemaining\n        if (after == 0) {\n            ensureNext(bb)\n        } else {\n            headRemaining = after\n        }\n\n        return rc\n    }\n\n    private fun notEnoughBytesAvailable(n: Int): Nothing {\n        throw EOFException(\"Not enough data in packet ($remaining) to read $n byte(s)\")\n    }\n\n    @DangerousInternalIoApi\n    fun updateHeadRemaining(remaining: Int) {\n        headRemaining = remaining\n    }\n\n    @DangerousInternalIoApi\n    fun prepareReadHead(minSize: Int): IoBuffer? = prepareRead(minSize, head)\n\n    @DangerousInternalIoApi\n    fun ensureNextHead(current: IoBuffer): IoBuffer? = ensureNext(current)\n\n    @PublishedApi\n    internal fun ensureNext(current: IoBuffer) = ensureNext(current, IoBuffer.Empty)\n\n    @DangerousInternalIoApi\n    fun fixGapAfterRead(current: IoBuffer) {\n        val next = current.next ?: return fixGapAfterReadFallback(current)\n\n        val remaining = current.readRemaining\n        val overrunSize = minOf(remaining, IoBuffer.ReservedSize - current.endGap)\n        if (next.startGap < overrunSize) return fixGapAfterReadFallback(current)\n\n        next.restoreStartGap(overrunSize)\n\n        if (remaining > overrunSize) {\n            current.restoreEndGap(overrunSize)\n\n            this.headRemaining = remaining - overrunSize\n            this.tailRemaining += overrunSize\n        } else {\n            this.head = next\n            val nextSize = next.readRemaining\n            this.headRemaining = nextSize\n            this.tailRemaining -= nextSize - overrunSize\n\n            current.release(pool)\n        }\n    }\n\n    private fun fixGapAfterReadFallback(current: IoBuffer) {\n        if (noMoreChunksAvailable) {\n            this.headRemaining = current.readRemaining\n            this.tailRemaining = 0\n            return\n        }\n\n        val size = current.readRemaining\n        val overrun = minOf(size, IoBuffer.ReservedSize - current.endGap)\n\n        if (size > overrun) {\n            fixGapAfterReadFallbackUnreserved(current, size, overrun)\n        } else {\n            val new = pool.borrow()\n            new.reserveEndGap(IoBuffer.ReservedSize)\n            new.next = current.next\n\n            new.writeBufferAppend(current, size)\n            this.head = new\n            this.headRemaining = size\n            this.tailRemaining = 0L\n        }\n\n        current.release(pool)\n    }\n\n    private fun fixGapAfterReadFallbackUnreserved(current: IoBuffer, size: Int, overrun: Int) {\n        // if we have a chunk with no end reservation\n        // we can split it into two to fix it\n\n        val chunk1 = pool.borrow()\n        val chunk2 = pool.borrow()\n\n        chunk1.reserveEndGap(IoBuffer.ReservedSize)\n        chunk2.reserveEndGap(IoBuffer.ReservedSize)\n        chunk1.next = chunk2\n        chunk2.next = current.next\n\n        chunk1.writeBufferAppend(current, size - overrun)\n        chunk2.writeBufferAppend(current, overrun)\n\n        this.head = chunk1\n        this.headRemaining = chunk1.readRemaining\n        this.tailRemaining = chunk2.readRemaining.toLong()\n    }\n\n    private tailrec fun ensureNext(current: IoBuffer, empty: IoBuffer): IoBuffer? {\n        if (current === empty) {\n            return doFill()\n        }\n\n        val next = current.next\n        current.release(pool)\n\n        return when {\n            next == null -> {\n                this.headRemaining = 0\n                this.tailRemaining = 0L\n                this.head = empty\n                ensureNext(empty, empty)\n            }\n            next.canRead() -> {\n                head = next\n                @Suppress(\"DEPRECATION\")\n                next.byteOrder = byteOrder\n                val nextRemaining = next.readRemaining\n                headRemaining = nextRemaining\n                tailRemaining -= nextRemaining\n                next\n            }\n            else -> ensureNext(next, empty)\n        }\n    }\n\n    /**\n     * Reads the next chunk suitable for reading or `null` if no more chunks available. It is also allowed\n     * to return a chain of chunks linked through [IoBuffer.next]. The last chunk should have `null` next reference.\n     * Could rethrow exceptions from the underlying source.\n     */\n    protected abstract fun fill(): IoBuffer?\n\n    /**\n     * Should close the underlying bytes source. Could do nothing or throw exceptions.\n     */\n    protected abstract fun closeSource()\n\n    internal fun markNoMoreChunksAvailable() {\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n    }\n\n    private fun doFill(): IoBuffer? {\n        if (noMoreChunksAvailable) return null\n        val chunk = fill()\n        if (chunk == null) {\n            noMoreChunksAvailable = true\n            return null\n        }\n        appendView(chunk)\n        return chunk\n    }\n\n    private fun appendView(chunk: IoBuffer) {\n        val tail = head.findTail()\n        if (tail === IoBuffer.Empty) {\n            head = chunk\n            @Suppress(\"DEPRECATION\")\n            chunk.byteOrder = byteOrder\n            require(tailRemaining == 0L) { throw IllegalStateException(\"It should be no tail remaining bytes if current tail is EmptyBuffer\") }\n            headRemaining = chunk.readRemaining\n            tailRemaining = chunk.next?.remainingAll() ?: 0L\n        } else {\n            tail.next = chunk\n            tailRemaining += chunk.remainingAll()\n        }\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    internal inline fun prepareRead(minSize: Int): IoBuffer? = prepareRead(minSize, head)\n\n    @PublishedApi\n    internal tailrec fun prepareRead(minSize: Int, head: IoBuffer): IoBuffer? {\n        val headSize = headRemaining\n        if (headSize >= minSize) return head\n\n        val next = head.next ?: doFill() ?: return null\n        @Suppress(\"DEPRECATION\")\n        next.byteOrder = byteOrder\n\n        if (headSize == 0) {\n            if (head !== IoBuffer.Empty) {\n                releaseHead(head)\n            }\n\n            return prepareRead(minSize, next)\n        } else {\n            val before = next.readRemaining\n            head.writeBufferAppend(next, minSize - headSize)\n            val after = next.readRemaining\n            headRemaining = head.readRemaining\n            tailRemaining -= before - after\n            if (after == 0) {\n                head.next = next.next\n                next.release(pool)\n            }\n        }\n\n        if (head.readRemaining >= minSize) return head\n        if (minSize > IoBuffer.ReservedSize) minSizeIsTooBig(minSize)\n\n        return prepareRead(minSize, head)\n    }\n\n    internal fun prefetch(size: Int) {\n        if (headRemaining >= size) return\n        val head = head\n\n        val currentSize = head.remainingAll()\n        if (currentSize >= size || noMoreChunksAvailable) return\n\n        if (head === IoBuffer.Empty) {\n            doFill()\n            return prefetch(size)\n        }\n\n        prefetchLoop(size, currentSize, head)\n    }\n\n    private fun prefetchLoop(size: Int, currentSize0: Long, head: IoBuffer) {\n        var tail = head.findTail()\n        var currentSize = currentSize0\n        var tailRemaining = tailRemaining\n\n        do {\n            val chunk = fill()\n            if (chunk == null) {\n                noMoreChunksAvailable = true\n                break\n            }\n            val chunkSize = chunk.readRemaining\n            tail.next = chunk\n            tailRemaining += chunkSize\n            currentSize += chunkSize\n            tail = chunk\n        } while (currentSize < size)\n\n        this.tailRemaining = tailRemaining\n    }\n\n    private fun minSizeIsTooBig(minSize: Int): Nothing {\n        throw IllegalStateException(\"minSize of $minSize is too big (should be less than ${IoBuffer.ReservedSize}\")\n    }\n\n    private fun afterRead() {\n        val head = head\n        if (head.readRemaining == 0) {\n            releaseHead(head)\n        }\n    }\n\n    internal fun releaseHead(head: IoBuffer): IoBuffer {\n        val next = head.next ?: IoBuffer.Empty\n        this.head = next\n        val nextRemaining = next.readRemaining\n        this.headRemaining = nextRemaining\n        this.tailRemaining -= nextRemaining\n        head.release(pool)\n\n        return next\n    }\n\n    companion object {\n        @Deprecated(\n            \"Use ByteReadPacket.Empty instead\",\n            ReplaceWith(\"ByteReadPacket.Empty\"),\n            level = DeprecationLevel.ERROR\n        )\n        val Empty: ByteReadPacket\n            get() = ByteReadPacket.Empty\n\n        @Deprecated(\"This implementation detail is going to become internal.\", level = DeprecationLevel.ERROR)\n        val ReservedSize: Int = IoBuffer.ReservedSize\n    }\n}\n\nexpect class EOFException(message: String) : IOException\n\nprivate fun IoBuffer.setByteOrderForNonEmpty(newByteOrder: ByteOrder) {\n    if (canRead()) {\n        @Suppress(\"DEPRECATION\")\n        byteOrder = newByteOrder\n    }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage kotlinx.io.bits\n\n/**\n * Reverse number's byte order\n */\nactual fun Short.reverseByteOrder(): Short = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Int.reverseByteOrder(): Int = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Long.reverseByteOrder(): Long = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Float.reverseByteOrder(): Float = swap(this)\n\n/**\n * Reverse number's byte order\n */\nactual fun Double.reverseByteOrder(): Double = swap(this)\n\n\nprivate inline fun swap(s: Short): Short = (((s.toInt() and 0xff) shl 8) or ((s.toInt() and 0xffff) ushr 8)).toShort()\n\nprivate inline fun swap(s: Int): Int =\n    (swap((s and 0xffff).toShort()).toInt() shl 16) or (swap((s ushr 16).toShort()).toInt() and 0xffff)\n\nprivate inline fun swap(s: Long): Long =\n    (swap((s and 0xffffffff).toInt()).toLong() shl 32) or (swap((s ushr 32).toInt()).toLong() and 0xffffffff)\n\nprivate inline fun swap(s: Float): Float = Float.fromBits(swap(s.toRawBits()))\n\nprivate inline fun swap(s: Double): Double = Double.fromBits(swap(s.toRawBits()))\n\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.pool.*\n\nexpect val PACKET_MAX_COPY_SIZE: Int\n\n/**\n * Build a byte packet in [block] lambda. Creates a temporary builder and releases it in case of failure\n */\ninline fun buildPacket(headerSizeHint: Int = 0, block: BytePacketBuilder.() -> Unit): ByteReadPacket {\n    val builder = BytePacketBuilder(headerSizeHint)\n    try {\n        block(builder)\n        return builder.build()\n    } catch (t: Throwable) {\n        builder.release()\n        throw t\n    }\n}\n\nexpect fun BytePacketBuilder(headerSizeHint: Int = 0): BytePacketBuilder\n\n/**\n * A builder that provides ability to build byte packets with no knowledge of it's size.\n * Unlike Java's ByteArrayOutputStream it doesn't copy the whole content every time it's internal buffer overflows\n * but chunks buffers instead. Packet building via [build] function is O(1) operation and only does instantiate\n * a new [ByteReadPacket]. Once a byte packet has been built via [build] function call, the builder could be\n * reused again. You also can discard all written bytes via [reset] or [release]. Please note that an instance of\n * builder need to be terminated either via [build] function invocation or via [release] call otherwise it will\n * cause byte buffer leak so that may have performance impact.\n *\n * Byte packet builder is also an [Appendable] so it does append UTF-8 characters to a packet\n *\n * ```\n * buildPacket {\n *     listOf(1,2,3).joinTo(this, separator = \",\")\n * }\n * ```\n */\nclass BytePacketBuilder(private var headerSizeHint: Int, pool: ObjectPool<IoBuffer>) :\n    @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderPlatformBase(pool) {\n    init {\n        require(headerSizeHint >= 0) { \"shouldn't be negative: headerSizeHint = $headerSizeHint\" }\n    }\n\n    /**\n     * Number of bytes written to the builder\n     */\n    val size: Int get() {\n        val size = _size\n        if (size == -1) {\n            _size = head.remainingAll().toInt()\n            return _size\n        }\n        return size\n    }\n\n    val isEmpty: Boolean get() {\n        val _size = _size\n        return when {\n            _size > 0 -> false\n            _size == 0 -> true\n            head.canRead() -> false\n            size == 0 -> true\n            else -> false\n        }\n    }\n\n    val isNotEmpty: Boolean get() {\n        val _size = _size\n        return when {\n            _size > 0 -> true\n            _size == 0 -> false\n            head.canRead() -> true\n            size > 0 -> true\n            else -> false\n        }\n    }\n\n    @PublishedApi\n    internal var head: IoBuffer = IoBuffer.Empty\n\n    override fun append(c: Char): BytePacketBuilder {\n        return super.append(c) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?): BytePacketBuilder {\n        return super.append(csq) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): BytePacketBuilder {\n        return super.append(csq, start, end) as BytePacketBuilder\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    override fun release() {\n        val head = this.head\n        val empty = IoBuffer.Empty\n\n        if (head !== empty) {\n            this.head = empty\n            this.tail = empty\n            head.releaseAll(pool)\n            _size = 0\n        }\n    }\n\n    override fun flush() {\n    }\n\n    override fun close() {\n        release()\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Suppress(\"OverridingDeprecatedMember\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun reset() {\n        release()\n    }\n\n    /**\n     * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n     * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n     * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n     * otherwise an unexpected behaviour may occur.\n     */\n    fun <R> preview(block: (tmp: ByteReadPacket) -> R): R {\n        val packet = preview()\n\n        return try {\n            block(packet)\n        } finally {\n            packet.release()\n        }\n    }\n\n    @PublishedApi\n    internal final fun preview(): ByteReadPacket {\n        val head = head\n        return when {\n            head === IoBuffer.Empty -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head.copyAll(), pool)\n        }\n    }\n\n    /**\n     * Builds byte packet instance and resets builder's state to be able to build another one packet if needed\n     */\n    fun build(): ByteReadPacket {\n        val size = size\n        val head = stealAll()\n\n        return when (head) {\n            null -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head, size.toLong(), pool)\n        }\n    }\n\n    /**\n     * Detach all chunks and cleanup all internal state so builder could be reusable again\n     * @return a chain of buffer views or `null` of it is empty\n     */\n    internal fun stealAll(): IoBuffer? {\n        val head = this.head\n        val empty = IoBuffer.Empty\n\n        this.head = empty\n        this.tail = empty\n        this._size = 0\n\n        return if (head === empty) null else head\n    }\n\n    internal fun afterBytesStolen() {\n        val head = head\n        check(head.next == null)\n        _size = 0\n        head.resetForWrite()\n        head.reserveStartGap(headerSizeHint)\n        head.reserveEndGap(IoBuffer.ReservedSize)\n    }\n\n    /**\n     * Writes another packet to the end. Please note that the instance [p] gets consumed so you don't need to release it\n     */\n    override fun writePacket(p: ByteReadPacket) {\n        val foreignStolen = p.stealAll()\n        if (foreignStolen == null) {\n            p.release()\n            return\n        }\n\n        val tail = tail\n        if (tail === IoBuffer.Empty) {\n            head = foreignStolen\n            this.tail = foreignStolen.findTail()\n            _size = foreignStolen.remainingAll().toInt()\n            return\n        }\n\n        writePacketSlow(tail, foreignStolen, p)\n    }\n\n    private fun writePacketSlow(tail: IoBuffer, foreignStolen: IoBuffer, p: ByteReadPacket) {\n        val lastSize = tail.readRemaining\n        val nextSize = foreignStolen.readRemaining\n\n        val maxCopySize = PACKET_MAX_COPY_SIZE\n        val appendSize = if (nextSize < maxCopySize && nextSize <= (tail.endGap + tail.writeRemaining)) {\n            nextSize\n        } else -1\n\n        val prependSize = if (lastSize < maxCopySize && lastSize <= foreignStolen.startGap && foreignStolen.isExclusivelyOwned()) {\n            lastSize\n        } else -1\n\n        if (appendSize == -1 && prependSize == -1) {\n            // simply enqueue\n            tail.next = foreignStolen\n            this.tail = foreignStolen.findTail()\n            _size = head.remainingAll().toInt()\n        } else if (prependSize == -1 || appendSize <= prependSize) {\n            // do append\n            tail.writeBufferAppend(foreignStolen, tail.writeRemaining + tail.endGap)\n            tail.next = foreignStolen.next\n            this.tail = foreignStolen.findTail().takeUnless { it === foreignStolen } ?: tail\n            foreignStolen.release(p.pool)\n            _size = head.remainingAll().toInt()\n        } else if (appendSize == -1 || prependSize < appendSize) {\n            writePacketSlowPrepend(foreignStolen, tail)\n        } else {\n            throw IllegalStateException(\"prep = $prependSize, app = $appendSize\")\n        }\n    }\n\n    private fun writePacketSlowPrepend(foreignStolen: IoBuffer, tail: IoBuffer) {\n        // do prepend\n        foreignStolen.writeBufferPrepend(tail)\n\n        if (head === tail) {\n            head = foreignStolen\n        } else {\n            var pre = head\n            while (true) {\n                val next = pre.next!!\n                if (next === tail) break\n                pre = next\n            }\n\n            pre.next = foreignStolen\n        }\n        tail.release(pool)\n\n        this.tail = foreignStolen.findTail()\n        _size = head.remainingAll().toInt()\n    }\n\n    override fun last(buffer: IoBuffer) {\n        if (head === IoBuffer.Empty) {\n            if (buffer.isEmpty()) { // headerSize is just a hint so we shouldn't force to reserve space\n                buffer.reserveStartGap(headerSizeHint) // it will always fail for non-empty buffer\n            }\n            tail = buffer\n            head = buffer\n            _size = buffer.remainingAll().toInt()\n        } else {\n            tail.next = buffer\n            tail = buffer\n            _size = -1\n        }\n    }\n}\n\n/**\n * Discard all written bytes and prepare to build another packet.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun BytePacketBuilder.reset() {\n    release()\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\nexpect abstract class BytePacketBuilderPlatformBase\ninternal constructor(pool: ObjectPool<IoBuffer>) : BytePacketBuilderBase\n\n/**\n * This is the default [Output] implementation\n */\n@ExperimentalIoApi\nabstract class AbstractOutput(pool: ObjectPool<IoBuffer> = IoBuffer.Pool) :\n    @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderPlatformBase(pool) {\n    @Deprecated(\"Will be removed. Override flush(buffer) properly.\", level = DeprecationLevel.ERROR)\n    protected var currentTail: IoBuffer\n        get() = this.tail\n        set(newValue) {\n            this.tail = newValue\n        }\n\n    /**\n     * An implementation should write the whole [buffer] to the destination. It should never capture the [buffer] instance\n     * longer than this method execution since it will be disposed after return.\n     * There is no need to follow [buffer]'s next chunk: this function is invoked for every chunk.\n     */\n    protected abstract fun flush(buffer: IoBuffer)\n\n    /**\n     * An implementation should only close the destination.\n     */\n    protected abstract fun closeDestination()\n\n    @Deprecated(\"This makes no sense for anything except BytePacketBuilder.\")\n    final override fun reset() {\n    }\n\n    /**\n     * Invoked when a new [buffer] is appended for writing (usually it's empty)\n     */\n    final override fun last(buffer: IoBuffer) {\n        var current = tail\n        tail = buffer\n\n        if (current === IoBuffer.Empty) return\n\n        do {\n            val next = current.next\n            current.next = null\n\n            try {\n                flush(current)\n            } catch (t: Throwable) {\n                next?.releaseAll(pool)\n                throw t\n            } finally {\n                current.release(pool)\n            }\n\n            if (next == null) break\n            current = next\n        } while (true)\n    }\n\n    final override fun release() {\n        val tail = tail\n        this.tail = IoBuffer.Empty\n        if (tail !== IoBuffer.Empty) {\n            tail.release(pool)\n        }\n        closeDestination()\n    }\n\n    final override fun flush() {\n        last(IoBuffer.Empty)\n    }\n\n    /**\n     * Should flush and close the destination\n     */\n    final override fun close() {\n        try {\n            flush()\n        } finally {\n            release()\n        }\n    }\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION\")\nabstract class BytePacketBuilderBase internal constructor(protected val pool: ObjectPool<IoBuffer>) : Appendable, Output {\n    @Deprecated(\n        \"Suppress warning.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    final override val doNotImplementOutputButExtendAbstractOutputInstead: Nothing\n        get() = error(\"Should be never accessed.\")\n\n    /**\n     * Number of bytes currently buffered or -1 if not known (need to be recomputed)\n     */\n    protected var _size: Int = 0\n\n    /**\n     * Byte order (Endianness) to be used by future write functions calls on this builder instance. Doesn't affect any\n     * previously written values. Note that [reset] doesn't change this value back to the default byte order.\n     * @default [ByteOrder.BIG_ENDIAN]\n     */\n    @Deprecated(\"Write with writeXXXLittleEndian or do X.reverseByteOrder() and then writeXXX instead.\")\n    final override var byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n        set(value) {\n            field = value\n            val tail = tail\n            if (tail.canWrite()) {\n                // it is important to not set byte order for IoBuffer.Empty as it will crash on native\n                tail.byteOrder = value\n            }\n        }\n\n    @PublishedApi\n    internal var tail: IoBuffer = IoBuffer.Empty\n\n    final override fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        if (length == 0) return\n\n        var copied = 0\n\n        writeLoop(1, { copied < length }) { buffer, bufferRemaining ->\n            val size = minOf(bufferRemaining, length - copied)\n            buffer.writeFully(src, offset + copied, size)\n            copied += size\n            size\n        }\n    }\n\n    final override fun writeLong(v: Long) {\n        write(8) { it.writeLong(v); 8 }\n    }\n\n    final override fun writeInt(v: Int) {\n        write(4) { it.writeInt(v); 4 }\n    }\n\n    final override fun writeShort(v: Short) {\n        write(2) { it.writeShort(v); 2 }\n    }\n\n    final override fun writeByte(v: Byte) {\n        write(1) { it.writeByte(v); 1 }\n    }\n\n    final override fun writeDouble(v: Double) {\n        write(8) { it.writeDouble(v); 8 }\n    }\n\n    final override fun writeFloat(v: Float) {\n        write(4) { it.writeFloat(v); 4 }\n    }\n\n    override fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        if (length == 0) return\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(2, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 1, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 2\n        }\n    }\n\n    override fun writeFully(src: IntArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(4, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 2, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 4\n        }\n    }\n\n    override fun writeFully(src: LongArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(8, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 3, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 8\n        }\n    }\n\n    override fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(4, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 2, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 4\n        }\n    }\n\n    override fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(offset + length < src.lastIndex) { \"offset ($offset) + length ($length) >= src.lastIndex (${src.lastIndex})\" }\n\n        var start = offset\n        var remaining = length\n\n        writeLoop(8, { remaining > 0 }) { buffer, chunkRemaining ->\n            val qty = minOf(chunkRemaining shr 3, remaining)\n            buffer.writeFully(src, start, qty)\n            start += qty\n            remaining -= qty\n            qty * 8\n        }\n    }\n\n    override fun writeFully(src: IoBuffer, length: Int) {\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        require(length <= src.readRemaining) { \"Not enough bytes available in src buffer to read $length bytes\" }\n\n        val totalSize = minOf(src.readRemaining, length)\n        if (totalSize == 0) return\n        var remaining = totalSize\n\n        var tail = tail\n        if (!tail.canWrite()) {\n            tail = appendNewBuffer()\n        }\n\n        do {\n            val size = minOf(tail.writeRemaining, remaining)\n            tail.writeFully(src, size)\n            remaining -= size\n\n            if (remaining == 0) break\n            tail = appendNewBuffer()\n        } while (true)\n\n        addSize(totalSize)\n    }\n\n    override fun fill(n: Long, v: Byte) {\n        require(n >= 0L) { \"n shouldn't be negative: $n\" }\n\n        var rem = n\n        writeLoop(1, { rem > 0L }) { buffer, chunkRemaining ->\n            val size = minOf(chunkRemaining.toLong(), n).toInt()\n            buffer.fill(size.toLong(), v)\n            rem -= size\n            size\n        }\n    }\n\n    /**\n     * Append single UTF-8 character\n     */\n    override fun append(c: Char): @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderBase {\n        write(3) {\n            it.putUtf8Char(c.toInt())\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?): @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderBase {\n        if (csq == null) {\n            appendChars(\"null\", 0, 4)\n        } else {\n            appendChars(csq, 0, csq.length)\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): @Suppress(\"DEPRECATION_ERROR\") BytePacketBuilderBase {\n        if (csq == null) {\n            return append(\"null\", start, end)\n        }\n\n        appendChars(csq, start, end)\n\n        return this\n    }\n\n    open fun writePacket(p: ByteReadPacket) {\n        while (true) {\n            val buffer = p.steal() ?: break\n            last(buffer)\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    fun writePacket(p: ByteReadPacket, n: Int) {\n        var remaining = n\n\n        while (remaining > 0) {\n            val headRemaining = p.headRemaining\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                last(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining)\n                }\n                break\n            }\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    fun writePacket(p: ByteReadPacket, n: Long) {\n        var remaining = n\n\n        while (remaining > 0L) {\n            val headRemaining = p.headRemaining.toLong()\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                last(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining.toInt())\n                }\n                break\n            }\n        }\n    }\n\n    override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        appendChars(csq, start, end)\n        return this\n    }\n\n    private fun appendChars(csq: CharSequence, start: Int, end: Int): Int {\n        var idx = start\n        if (idx >= end) return idx\n        val tail = tail\n        if (tail.canWrite()) {\n            idx = tail.appendChars(csq, idx, end)\n        }\n\n        while (idx < end) {\n            idx = appendNewBuffer().appendChars(csq, idx, end)\n        }\n\n        this._size = -1\n        return idx\n    }\n\n    private fun appendChars(csq: CharArray, start: Int, end: Int): Int {\n        var idx = start\n        if (idx >= end) return idx\n        val tail = tail\n        if (tail.canWrite()) {\n            idx = tail.appendChars(csq, idx, end)\n        }\n\n        while (idx < end) {\n            idx = appendNewBuffer().appendChars(csq, idx, end)\n        }\n\n        this._size = -1\n        return idx\n    }\n\n    fun writeStringUtf8(s: String) {\n        append(s, 0, s.length)\n    }\n\n    fun writeStringUtf8(cs: CharSequence) {\n        append(cs, 0, cs.length)\n    }\n\n//    fun writeStringUtf8(cb: CharBuffer) {\n//        append(cb, 0, cb.remaining())\n//    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun IoBuffer.putUtf8Char(v: Int) = when {\n        v in 1..0x7f -> {\n            writeByte(v.toByte())\n            1\n        }\n        v > 0x7ff -> {\n            writeByte((0xe0 or ((v shr 12) and 0x0f)).toByte())\n            writeByte((0x80 or ((v shr  6) and 0x3f)).toByte())\n            writeByte((0x80 or ( v         and 0x3f)).toByte())\n            3\n        }\n        else -> {\n            writeByte((0xc0 or ((v shr  6) and 0x1f)).toByte())\n            writeByte((0x80 or ( v         and 0x3f)).toByte())\n            2\n        }\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    abstract fun release()\n\n    @DangerousInternalIoApi\n    fun prepareWriteHead(n: Int): IoBuffer {\n        if (tail.writeRemaining >= n) return tail\n        return appendNewBuffer()\n    }\n\n    @DangerousInternalIoApi\n    fun afterHeadWrite() {\n        _size = -1\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    open fun reset() {\n    }\n\n    @PublishedApi\n    internal inline fun write(size: Int, block: (IoBuffer) -> Int) {\n        var buffer = tail\n        if (buffer.writeRemaining < size) {\n            buffer = appendNewBuffer()\n        }\n\n        addSize(block(buffer))\n    }\n\n    private inline fun writeLoop(size: Int, predicate: () -> Boolean, block: (IoBuffer, Int) -> Int) {\n        if (!predicate()) return\n        var written = 0\n        var buffer = tail\n        var rem = buffer.writeRemaining\n\n        do {\n            if (rem < size) {\n                buffer = appendNewBuffer()\n                rem = buffer.writeRemaining\n            }\n\n            val result = block(buffer, rem)\n            written += result\n            rem -= result\n        } while (predicate())\n\n        addSize(written)\n    }\n\n    @PublishedApi\n    internal fun addSize(n: Int) {\n        val size = _size\n        if (size != -1) {\n            _size = size + n\n        }\n    }\n\n    internal abstract fun last(buffer: IoBuffer)\n\n    @PublishedApi\n    internal fun appendNewBuffer(): IoBuffer {\n        val new = pool.borrow()\n        new.reserveEndGap(IoBuffer.ReservedSize)\n        new.byteOrder = byteOrder\n\n        last(new)\n\n        return new\n    }\n}\n\nprivate inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    return if (!predicate(this)) this else null\n}\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\nexpect interface Output : Appendable, Closeable {\n    @Deprecated(\n        \"Implementing this interface is highly experimental. Extend AbstractOutput instead.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    val doNotImplementOutputButExtendAbstractOutputInstead: Nothing\n\n    /**\n     * Byte order (Endianness) to be used by future write functions calls on this builder instance. Doesn't affect any\n     * previously written values.\n     * @default [ByteOrder.BIG_ENDIAN]\n     */\n    @Deprecated(\"Write with writeXXXLittleEndian or do X.reverseByteOrder() and then writeXXX instead.\")\n    var byteOrder: ByteOrder\n\n    fun writeByte(v: Byte)\n    fun writeShort(v: Short)\n    fun writeInt(v: Int)\n    fun writeLong(v: Long)\n    fun writeFloat(v: Float)\n    fun writeDouble(v: Double)\n\n    fun writeFully(src: ByteArray, offset: Int, length: Int)\n    fun writeFully(src: ShortArray, offset: Int, length: Int)\n    fun writeFully(src: IntArray, offset: Int, length: Int)\n    fun writeFully(src: LongArray, offset: Int, length: Int)\n    fun writeFully(src: FloatArray, offset: Int, length: Int)\n    fun writeFully(src: DoubleArray, offset: Int, length: Int)\n    fun writeFully(src: IoBuffer, length: Int)\n\n    fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    fun fill(n: Long, v: Byte)\n\n    fun flush()\n\n    override fun close()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.append(csq: CharSequence, start: Int = 0, end: Int = csq.length): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.append(csq: CharArray, start: Int = 0, end: Int = csq.size): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: ByteArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: ShortArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: IntArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: LongArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: FloatArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: DoubleArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFully(src, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.writeFully(src: IoBuffer, length: Int = src.readRemaining) {\n    writeFully(src, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun Output.fill(n: Long, v: Byte = 0) {\n    fill(n, v)\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is true.\n * Depending on the output underlying implementation it could invoke [block] function with the same buffer several times\n * however it is guaranteed that it is always non-empty.\n */\n@Deprecated(\"This is going to become internal. Write directly to output instead.\")\ninline fun Output.writeWhile(block: (IoBuffer) -> Boolean) {\n    var tail: IoBuffer = prepareWriteHead(1, null)\n    try {\n        while (true) {\n            if (!block(tail)) break\n            tail = prepareWriteHead(1, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is positive.\n * If returned value is positive then it will be invoked again with a buffer having at least requested number of\n * bytes space (could be the same buffer as before if it complies to the restriction).\n * @param initialSize for the first buffer passed to [block] function\n */\n@Deprecated(\"This is going to become internal. Write directly to output instead.\")\ninline fun Output.writeWhileSize(initialSize: Int = 1, block: (IoBuffer) -> Int) {\n    var tail = prepareWriteHead(initialSize, null)\n\n    try {\n        var size: Int\n        while (true) {\n            size = block(tail)\n            if (size <= 0) break\n            tail = prepareWriteHead(size, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\nfun Output.writePacket(packet: ByteReadPacket) {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        writePacket(packet)\n        return\n    }\n\n    packet.takeWhile { from ->\n        writeFully(from)\n        true\n    }\n}\n","package kotlinx.io.core.internal\n\n@PublishedApi\ninternal inline fun require(condition: Boolean, crossinline message: () -> String) {\n    if (!condition) {\n        val m = object : RequireFailureCapture() {\n            override fun doFail(): Nothing {\n                throw IllegalArgumentException(message())\n            }\n        }\n        m.doFail()\n    }\n}\n\n@PublishedApi\ninternal abstract class RequireFailureCapture {\n    abstract fun doFail(): Nothing\n}\n","package kotlinx.io.core\n\n/**\n * Copy all bytes to the [output].\n * Depending on actual input and output implementation it could be zero-copy or copy byte per byte.\n * All regular types such as [ByteReadPacket], [BytePacketBuilder], [AbstractInput] and [AbstractOutput]\n * are always optimized so no bytes will be copied.\n */\nfun Input.copyTo(output: Output): Long {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this !is ByteReadPacketBase || output !is BytePacketBuilderBase) {\n        // slow-path\n        return copyToFallback(output)\n    }\n\n    var copied = 0L\n    do {\n        val head = stealAll()\n        if (head == null) {\n            if (prepareRead(1) == null) break\n            continue\n        }\n\n        copied += head.remainingAll()\n        output.last(head)\n    } while (true)\n\n    return copied\n}\n\nprivate fun Input.copyToFallback(output: Output): Long {\n    val buffer = IoBuffer.Pool.borrow()\n    var copied = 0L\n\n    try {\n        do {\n            buffer.resetForWrite()\n            val rc = readAvailable(buffer)\n            if (rc == -1) break\n            copied += rc\n            output.writeFully(buffer)\n        } while (true)\n\n        return copied\n    } finally {\n        buffer.release(IoBuffer.Pool)\n    }\n}\n","@file:Suppress(\"Duplicates\")\n\npackage kotlinx.io.core\n\nimport kotlinx.io.bits.*\n\nfun Input.readShort(byteOrder: ByteOrder): Short =\n    readPrimitiveTemplate(byteOrder, { readShort() }, { reverseByteOrder() })\n\nfun Input.readInt(byteOrder: ByteOrder): Int =\n    readPrimitiveTemplate(byteOrder, { readInt() }, { reverseByteOrder() })\n\nfun Input.readLong(byteOrder: ByteOrder): Long =\n    readPrimitiveTemplate(byteOrder, { readLong() }, { reverseByteOrder() })\n\nfun Input.readFloat(byteOrder: ByteOrder): Float =\n    readPrimitiveTemplate(byteOrder, { readFloat() }, { reverseByteOrder() })\n\nfun Input.readDouble(byteOrder: ByteOrder): Double =\n    readPrimitiveTemplate(byteOrder, { readDouble() }, { reverseByteOrder() })\n\nfun Input.readShortLittleEndian(): Short = readPrimitiveTemplate({ readShort() }, { reverseByteOrder() })\n\nfun Input.readIntLittleEndian(): Int = readPrimitiveTemplate({ readInt() }, { reverseByteOrder() })\n\nfun Input.readLongLittleEndian(): Long = readPrimitiveTemplate({ readLong() }, { reverseByteOrder() })\n\nfun Input.readFloatLittleEndian(): Float = readPrimitiveTemplate({ readFloat() }, { reverseByteOrder() })\n\nfun Input.readDoubleLittleEndian(): Double = readPrimitiveTemplate({ readDouble() }, { reverseByteOrder() })\n\nfun Input.readFullyLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asShortArray(), offset, length)\n}\n\nfun Input.readFullyLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asIntArray(), offset, length)\n}\n\nfun Input.readFullyLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asLongArray(), offset, length)\n}\n\nfun Input.readFullyLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readFullyLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + length - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n}\n\nfun Input.readAvailableLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asShortArray(), offset, length)\n}\n\nfun Input.readAvailableLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asIntArray(), offset, length)\n}\n\nfun Input.readAvailableLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asLongArray(), offset, length)\n}\n\nfun Input.readAvailableLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nfun Input.readAvailableLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0 && byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nprivate inline fun <T : Any> Input.readPrimitiveTemplate(read: () -> T, reverse: T.() -> T): T {\n    return when (byteOrderDeprecated) {\n        ByteOrder.LITTLE_ENDIAN -> read()\n        else -> read().reverse()\n    }\n}\n\nprivate inline fun <T : Any> Input.readPrimitiveTemplate(byteOrder: ByteOrder, read: () -> T, reverse: T.() -> T): T {\n    return when {\n        byteOrderDeprecated == byteOrder -> read()\n        else -> read().reverse()\n    }\n}\n\n@Suppress(\"DEPRECATION\")\nprivate inline val Input.byteOrderDeprecated get() = byteOrder\n","package kotlinx.io.core\n\nimport kotlinx.io.bits.*\n\nfun Output.writeShort(value: Short, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeShort(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeInt(value: Int, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeInt(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeLong(value: Long, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeLong(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeFloat(value: Float, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeFloat(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeDouble(value: Double, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeDouble(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeShortLittleEndian(value: Short) {\n    writePrimitiveTemplate(value, { writeShort(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeIntLittleEndian(value: Int) {\n    writePrimitiveTemplate(value, { writeInt(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeLongLittleEndian(value: Long) {\n    writePrimitiveTemplate(value, { writeLong(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeFloatLittleEndian(value: Float) {\n    writePrimitiveTemplate(value, { writeFloat(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeDoubleLittleEndian(value: Double) {\n    writePrimitiveTemplate(value, { writeDouble(it) }, { reverseByteOrder() })\n}\n\nfun Output.writeFullyLittleEndian(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asShortArray(), offset, length)\n}\n\nfun Output.writeFullyLittleEndian(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        2,\n        { writeFully(source, offset, length) },\n        { writeShort(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asIntArray(), offset, length)\n}\n\nfun Output.writeFullyLittleEndian(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeFully(source, offset, length) },\n        { writeInt(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asLongArray(), offset, length)\n}\n\nfun Output.writeFullyLittleEndian(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeFully(source, offset, length) },\n        { writeLong(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeFully(source, offset, length) },\n        { writeFloat(source[it].reverseByteOrder()) })\n}\n\nfun Output.writeFullyLittleEndian(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeFully(source, offset, length) },\n        { writeDouble(source[it].reverseByteOrder()) })\n}\n\nprivate inline fun <T : Any> Output.writePrimitiveTemplate(value: T, write: (T) -> Unit, reverse: T.() -> T) {\n    write(\n        when (byteOrderDeprecated) {\n            ByteOrder.LITTLE_ENDIAN -> value\n            else -> value.reverse()\n        }\n    )\n}\n\nprivate inline fun <T : Any> Output.writePrimitiveTemplate(value: T, byteOrder: ByteOrder, write: (T) -> Unit, reverse: T.() -> T) {\n    write(\n        when {\n            byteOrderDeprecated == byteOrder -> value\n            else -> value.reverse()\n        }\n    )\n}\n\nprivate inline fun Output.writeArrayTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    writeFullyBE: () -> Unit,\n    writeComponent: IoBuffer.(Int) -> Unit\n) {\n    if (byteOrderDeprecated != ByteOrder.LITTLE_ENDIAN) {\n        val untilIndex = offset + length\n        var start = offset\n        writeWhileSize(componentSize) { buffer ->\n            val size = minOf(buffer.writeRemaining / componentSize, untilIndex - start)\n            val lastIndex = start + size - 1\n            for (index in start..lastIndex) {\n                writeComponent(buffer, index)\n            }\n            start += size\n            when {\n                start < untilIndex -> componentSize\n                else -> 0\n            }\n        }\n    } else {\n        writeFullyBE()\n    }\n}\n\n@Suppress(\"DEPRECATION\")\nprivate inline val Output.byteOrderDeprecated\n    get() = byteOrder\n","package kotlinx.io.core.internal\n\nimport kotlinx.io.core.*\n\ninternal inline fun IoBuffer.decodeASCII(consumer: (Char) -> Boolean): Boolean {\n    for (i in 0 until readRemaining) {\n        val v = readByte().toInt() and 0xff\n        if (v and 0x80 != 0 || !consumer(v.toChar())) {\n            pushBack(1)\n            return false\n        }\n    }\n\n    return true\n}\n\n@DangerousInternalIoApi\nsuspend fun decodeUTF8LineLoopSuspend(\n    out: Appendable,\n    limit: Int,\n    nextChunk: suspend (Int) -> ByteReadPacketBase?\n): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    while (!end && size != 0) {\n        val chunk = nextChunk(size) ?: break\n        chunk.takeWhileSize { buffer ->\n            var skip = 0\n            size = buffer.decodeUTF8 { ch ->\n                when (ch) {\n                    '\\r' -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n                        cr = true\n                        true\n                    }\n                    '\\n' -> {\n                        end = true\n                        skip = 1\n                        false\n                    }\n                    else -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n\n                        if (decoded == limit) {\n                            throw BufferLimitExceededException(\"Too many characters in line: limit $limit exceeded\")\n                        }\n                        decoded++\n                        out.append(ch)\n                        true\n                    }\n                }\n            }\n\n            if (skip > 0) {\n                buffer.discardExact(skip)\n            }\n\n            size = if (end) 0 else size.coerceAtLeast(1)\n\n            size\n        }\n    }\n\n    if (size > 1) prematureEndOfStreamUtf(size)\n    if (cr) {\n        end = true\n    }\n\n    return decoded > 0 || end\n}\n\nprivate fun prematureEndOfStreamUtf(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes to decode UTF-8 char\")\n\n@DangerousInternalIoApi\ninternal fun byteCountUtf8(firstByte: Int): Int {\n    var byteCount = 0\n    var mask = 0x80\n    var value = firstByte\n\n    for (i in 1..6) {\n        if (value and mask != 0) {\n            value = value and mask.inv()\n            mask = mask shr 1\n            byteCount++\n        } else {\n            break\n        }\n    }\n\n    return byteCount\n}\n\n/**\n * Decodes all the bytes to utf8 applying every character on [consumer] until or consumer return `false`.\n * If a consumer returned false then a character will be pushed back (including all surrogates will be pushed back as well)\n * and [decodeUTF8] returns -1\n * @return number of bytes required to decode incomplete utf8 character or 0 if all bytes were processed\n * or -1 if consumer rejected loop\n */\n@DangerousInternalIoApi\ninline fun IoBuffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    var byteCount = 0\n    var value = 0\n    var lastByteCount = 0\n\n    while (canRead()) {\n        val v = readByte().toInt() and 0xff\n        when {\n            v and 0x80 == 0 -> {\n                if (byteCount != 0) malformedByteCount(byteCount)\n                if (!consumer(v.toChar())) {\n                    pushBack(1)\n                    return -1\n                }\n            }\n            byteCount == 0 -> {\n                // first unicode byte\n\n                var mask = 0x80\n                value = v\n\n                for (i in 1..6) { // TODO do we support 6 bytes unicode?\n                    if (value and mask != 0) {\n                        value = value and mask.inv()\n                        mask = mask shr 1\n                        byteCount++\n                    } else {\n                        break\n                    }\n                }\n\n                lastByteCount = byteCount\n                byteCount--\n\n                if (byteCount > readRemaining) {\n                    pushBack(1) // return one byte back\n                    return lastByteCount\n                }\n            }\n            else -> {\n                // trailing unicode byte\n                value = (value shl 6) or (v and 0x7f)\n                byteCount--\n\n                if (byteCount == 0) {\n                    if (isBmpCodePoint(value)) {\n                        if (!consumer(value.toChar())) {\n                            pushBack(lastByteCount)\n                            return -1\n                        }\n                    } else if (!isValidCodePoint(value)) {\n                        malformedCodePoint(value)\n                    } else {\n                        if (!consumer(highSurrogate(value).toChar()) ||\n                                !consumer(lowSurrogate(value).toChar())) {\n                            pushBack(lastByteCount)\n                            return -1\n                        }\n                    }\n\n                    value = 0\n                }\n            }\n        }\n    }\n\n    return 0\n}\n\n@PublishedApi\ninternal fun malformedByteCount(byteCount: Int): Nothing =\n    throw MalformedUTF8InputException(\"Expected $byteCount more character bytes\")\n\n@PublishedApi\ninternal fun malformedCodePoint(value: Int): Nothing =\n    throw IllegalArgumentException(\"Malformed code-point $value found\")\n\nprivate const val MaxCodePoint = 0x10ffff\nprivate const val MinLowSurrogate = 0xdc00\nprivate const val MinHighSurrogate = 0xd800\nprivate const val MinSupplementary = 0x10000\nprivate const val HighSurrogateMagic = MinHighSurrogate - (MinSupplementary ushr 10)\n\n@PublishedApi\ninternal fun isBmpCodePoint(cp: Int) = cp ushr 16 == 0\n\n@PublishedApi\ninternal fun isValidCodePoint(codePoint: Int) = codePoint <= MaxCodePoint\n\n@PublishedApi\ninternal fun lowSurrogate(cp: Int) = (cp and 0x3ff) + MinLowSurrogate\n\n@PublishedApi\ninternal fun highSurrogate(cp: Int) = (cp ushr 10) + HighSurrogateMagic\n\nclass MalformedUTF8InputException(message: String) : Exception(message)\n","package kotlinx.io.core\n\nimport kotlinx.io.charsets.*\nimport kotlinx.io.core.internal.*\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun String.toByteArray(charset: Charset = Charsets.UTF_8): ByteArray =\n    charset.newEncoder().encodeToByteArray(this, 0, length)\n\nexpect fun String(\n    bytes: ByteArray,\n    offset: Int = 0,\n    length: Int = bytes.size,\n    charset: Charset = Charsets.UTF_8\n): String\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\nfun ByteReadPacket.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    if (isEmpty) return null\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\nfun Input.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read UTF-8 line and append all line characters to [out] except line endings. Does support CR, LF and CR+LF\n * @return `true` if some characters were appended or line ending reached (empty line) or `false` if packet\n * if empty\n */\nfun Input.readUTF8LineTo(out: Appendable, limit: Int): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    takeWhileSize { buffer ->\n        var skip = 0\n        size = buffer.decodeUTF8 { ch ->\n            when (ch) {\n                '\\r' -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n                    cr = true\n                    true\n                }\n                '\\n' -> {\n                    end = true\n                    skip = 1\n                    false\n                }\n                else -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n\n                    if (decoded == limit) bufferLimitExceeded(limit)\n                    decoded++\n                    out.append(ch)\n                    true\n                }\n            }\n        }\n\n        if (skip > 0) {\n            buffer.discardExact(skip)\n        }\n\n        if (end) 0 else size.coerceAtLeast(1)\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded > 0 || !endOfInput\n}\n\n/**\n * Reads UTF-8 characters until one of the specified [delimiters] found, [limit] exceeded or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns a string of characters read before delimiter\n */\nfun Input.readUTF8UntilDelimiter(delimiters: String, limit: Int = Int.MAX_VALUE): String {\n    return buildString {\n        readUTF8UntilDelimiterTo(this, delimiters, limit)\n    }\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\nfun Input.readUTF8UntilDelimiterTo(out: Appendable, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n    }\n\n    if (!delimiter) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\nfun Input.readUTF8UntilDelimiterTo(out: Output, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    val delimitersCount = delimiters.length\n    if (delimitersCount == 1 && delimiters[0].isAsciiChar()) {\n        return readUntilDelimiter(delimiters[0].toByte(), out).toInt()\n    } else if (delimitersCount == 2 && delimiters[0].isAsciiChar() && delimiters[1].isAsciiChar()) {\n        return readUntilDelimiters(delimiters[0].toByte(), delimiters[1].toByte(), out).toInt()\n    }\n\n    return readUTFUntilDelimiterToSlowAscii(delimiters, limit, out)\n}\n\n@Suppress(\"unused\", \"DEPRECATION_ERROR\")\n@Deprecated(\"Use Output version instead\", level = DeprecationLevel.HIDDEN)\nfun Input.readUTF8UntilDelimiterTo(out: BytePacketBuilderBase, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    return readUTF8UntilDelimiterTo(out as Output, delimiters, limit)\n}\n\n/**\n * Read exactly [n] bytes (consumes all remaining if [n] is not specified but up to [Int.MAX_VALUE] bytes).\n * Does fail if not enough bytes remaining.\n */\nfun ByteReadPacket.readBytes(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to convert to a ByteArray: packet is too big\")\n): ByteArray =\n    ByteArray(n).also { readFully(it, 0, n) }\n\n/**\n * Reads exactly [n] bytes from the input or fails if not enough bytes available.\n */\nfun Input.readBytes(n: Int): ByteArray = readBytesOf(n, n)\n\n/**\n * Reads all remaining bytes from the input\n */\nfun Input.readBytes(): ByteArray = readBytesOf()\n\n/**\n * Reads at least [min] but no more than [max] bytes from the input to a new byte array\n * @throws EOFException if not enough bytes available to get [min] bytes\n */\nfun Input.readBytesOf(min: Int = 0, max: Int = Int.MAX_VALUE): ByteArray = if (min == max) {\n    ByteArray(min).also { readFully(it, 0, min) }\n} else {\n    var array = ByteArray(max.toLong().coerceAtMost(sizeEstimate()).coerceAtLeast(min.toLong()).toInt())\n    var size = 0\n\n    while (size < max) {\n        val partSize = minOf(max, array.size) - size\n        val rc = readAvailable(array, size, partSize)\n        if (rc <= 0) break\n        size += rc\n        if (array.size == size) {\n            array = array.copyOf(size * 2)\n        }\n    }\n\n    if (size < min) {\n        throw EOFException(\"Not enough bytes available to read $min bytes: ${min - size} more required\")\n    }\n\n    if (size == array.size) array else array.copyOf(size)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\n@Deprecated(\"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, out, max)\", \"kotlinx.io.charsets.decode\"),\n    level = DeprecationLevel.ERROR\n)\nfun Input.readText(out: Appendable, decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): Int {\n    return decoder.decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\nfun Input.readText(out: Appendable, charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): Int {\n    return charset.newDecoder().decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, max)\", \"kotlinx.io.charsets.decode\"),\n    level = DeprecationLevel.ERROR\n)\nfun Input.readText(decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): String {\n    return decoder.decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\nfun Input.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String {\n    return charset.newDecoder().decode(this, max)\n}\n\n/**\n * Read exactly [n] characters interpreting bytes in the specified [charset].\n */\n@Deprecated(\n    \"Use readTextExactCharacters instead.\",\n    ReplaceWith(\"readTextExactCharacters(n, charset)\")\n)\nfun Input.readTextExact(charset: Charset = Charsets.UTF_8, n: Int): String {\n    return readTextExactCharacters(n, charset)\n}\n\n/**\n * Read exactly [charactersCount] characters interpreting bytes in the specified [charset].\n */\nfun Input.readTextExactCharacters(charactersCount: Int, charset: Charset = Charsets.UTF_8): String {\n    val s = readText(charset, charactersCount)\n    if (s.length < charactersCount) {\n        prematureEndOfStreamToReadChars(charactersCount)\n    }\n    return s\n}\n\n\n/**\n * Read exactly the specified number of [bytes]\n * interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\n@Deprecated(\"Parameters order is changed.\", ReplaceWith(\"readTextExactBytes(bytes, charset)\"))\nfun Input.readTextExactBytes(charset: Charset = Charsets.UTF_8, bytes: Int): String {\n    return readTextExactBytes(bytes, charset)\n}\n\n/**\n * Read exactly [bytesCount] interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\nfun Input.readTextExactBytes(bytesCount: Int, charset: Charset = Charsets.UTF_8): String {\n    return charset.newDecoder().decodeExactBytes(this, inputLength = bytesCount)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [encoder]\n */\n@Deprecated(\n    \"Use the implementation with Charset instead\",\n    ReplaceWith(\"writeText(text, fromIndex, toIndex, encoder.charset)\", \"kotlinx.io.charsets.charset\")\n)\nfun Output.writeText(text: CharSequence, fromIndex: Int = 0, toIndex: Int = text.length, encoder: CharsetEncoder) {\n    encoder.encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\nfun Output.writeText(text: CharSequence, fromIndex: Int = 0, toIndex: Int = text.length, charset: Charset = Charsets.UTF_8) {\n    charset.newEncoder().encodeToImpl(this, text, fromIndex, toIndex)\n}\n\ninternal expect fun String.getCharsInternal(dst: CharArray, dstOffset: Int)\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Char.isAsciiChar() = toInt() <= 0x7f\n\nprivate fun Input.readUTFUntilDelimiterToSlowAscii(delimiters: String, limit: Int, out: Output): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        val before = buffer.readRemaining\n\n        val rc = buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.pushBack(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        rc\n    }\n\n    if (!delimiter && !endOfInput) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Output,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        val before = buffer.readRemaining\n\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.pushBack(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Appendable,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun bufferLimitExceeded(limit: Int): Nothing {\n    throw BufferLimitExceededException(\"Too many characters before delimiter: limit $limit exceeded\")\n}\n\nprivate fun prematureEndOfStream(size: Int): Nothing =\n    throw MalformedUTF8InputException(\"Premature end of stream: expected $size bytes\")\n\nprivate fun prematureEndOfStreamToReadChars(charactersCount: Int): Nothing =\n    throw EOFException(\"Not enough input bytes to read $charactersCount characters.\")\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage kotlinx.io.core\n\n@ExperimentalUnsignedTypes\ninline fun Input.readUByte(): UByte = readByte().toUByte()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readUShort(): UShort = readShort().toUShort()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readUInt(): UInt = readInt().toUInt()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readULong(): ULong = readLong().toULong()\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: UByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asByteArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asShortArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asIntArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Input.readFully(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asLongArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeUByte(v: UByte) {\n    writeByte(v.toByte())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeUShort(v: UShort) {\n    writeShort(v.toShort())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeUInt(v: UInt) {\n    writeInt(v.toInt())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeULong(v: ULong) {\n    writeLong(v.toLong())\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: UByteArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asByteArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: UShortArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asShortArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: UIntArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asIntArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\ninline fun Output.writeFully(array: ULongArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asLongArray(), offset, length)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"UArraysKt\")\n@file:kotlin.jvm.JvmPackageName(\"kotlin.collections.unsigned\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component1(): UInt {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component1(): ULong {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component1(): UByte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component1(): UShort {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component2(): UInt {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component2(): ULong {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component2(): UByte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component2(): UShort {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component3(): UInt {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component3(): ULong {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component3(): UByte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component3(): UShort {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component4(): UInt {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component4(): ULong {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component4(): UByte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component4(): UShort {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component5(): UInt {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component5(): ULong {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component5(): UByte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component5(): UShort {\n    return get(4)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.elementAt(index: Int): UInt\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.elementAt(index: Int): ULong\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.elementAt(index: Int): UByte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.elementAt(index: Int): UShort\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrNull(index: Int): UInt? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrNull(index: Int): ULong? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrNull(index: Int): UByte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrNull(index: Int): UShort? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.find(predicate: (UInt) -> Boolean): UInt? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.find(predicate: (ULong) -> Boolean): ULong? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.find(predicate: (UByte) -> Boolean): UByte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.find(predicate: (UShort) -> Boolean): UShort? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.findLast(predicate: (UInt) -> Boolean): UInt? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.findLast(predicate: (ULong) -> Boolean): ULong? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.findLast(predicate: (UByte) -> Boolean): UByte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.findLast(predicate: (UShort) -> Boolean): UShort? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(): UInt {\n    return storage.first().toUInt()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(): ULong {\n    return storage.first().toULong()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(): UByte {\n    return storage.first().toUByte()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(): UShort {\n    return storage.first().toUShort()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(predicate: (UInt) -> Boolean): UInt {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(predicate: (ULong) -> Boolean): ULong {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(predicate: (UByte) -> Boolean): UByte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(predicate: (UShort) -> Boolean): UShort {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.firstOrNull(): UInt? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.firstOrNull(): ULong? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.firstOrNull(): UByte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.firstOrNull(): UShort? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.firstOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.firstOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.firstOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.firstOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.getOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.getOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.getOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.getOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.getOrNull(index: Int): UInt? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.getOrNull(index: Int): ULong? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.getOrNull(index: Int): UByte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.getOrNull(index: Int): UShort? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOf(element: UInt): Int {\n    return storage.indexOf(element.toInt())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOf(element: ULong): Int {\n    return storage.indexOf(element.toLong())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOf(element: UByte): Int {\n    return storage.indexOf(element.toByte())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOf(element: UShort): Int {\n    return storage.indexOf(element.toShort())\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfFirst(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfFirst(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfFirst(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfFirst(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUShort()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfLast(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfLast(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfLast(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfLast(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUShort()) }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(): UInt {\n    return storage.last().toUInt()\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(): ULong {\n    return storage.last().toULong()\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(): UByte {\n    return storage.last().toUByte()\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(): UShort {\n    return storage.last().toUShort()\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(predicate: (UInt) -> Boolean): UInt {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(predicate: (ULong) -> Boolean): ULong {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(predicate: (UByte) -> Boolean): UByte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(predicate: (UShort) -> Boolean): UShort {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastIndexOf(element: UInt): Int {\n    return storage.lastIndexOf(element.toInt())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastIndexOf(element: ULong): Int {\n    return storage.lastIndexOf(element.toLong())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastIndexOf(element: UByte): Int {\n    return storage.lastIndexOf(element.toByte())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastIndexOf(element: UShort): Int {\n    return storage.lastIndexOf(element.toShort())\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.lastOrNull(): UInt? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.lastOrNull(): ULong? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.lastOrNull(): UByte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.lastOrNull(): UShort? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.random(): UInt {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.random(): ULong {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.random(): UByte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.random(): UShort {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.random(random: Random): UInt {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.random(random: Random): ULong {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.random(random: Random): UByte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.random(random: Random): UShort {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(): UInt {\n    return storage.single().toUInt()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(): ULong {\n    return storage.single().toULong()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(): UByte {\n    return storage.single().toUByte()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(): UShort {\n    return storage.single().toUShort()\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(predicate: (UInt) -> Boolean): UInt {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UInt\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(predicate: (ULong) -> Boolean): ULong {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as ULong\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(predicate: (UByte) -> Boolean): UByte {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UByte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(predicate: (UShort) -> Boolean): UShort {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UShort\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.singleOrNull(): UInt? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.singleOrNull(): ULong? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.singleOrNull(): UByte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.singleOrNull(): UShort? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.singleOrNull(predicate: (UInt) -> Boolean): UInt? {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.singleOrNull(predicate: (ULong) -> Boolean): ULong? {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.singleOrNull(predicate: (UByte) -> Boolean): UByte? {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.singleOrNull(predicate: (UShort) -> Boolean): UShort? {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.drop(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.drop(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.drop(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.drop(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.dropLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.dropLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.dropLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.dropLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    var yielding = false\n    val list = ArrayList<UInt>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    var yielding = false\n    val list = ArrayList<ULong>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    var yielding = false\n    val list = ArrayList<UByte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    var yielding = false\n    val list = ArrayList<UShort>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filter(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filter(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filter(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filter(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterIndexed(predicate: (index: Int, UInt) -> Boolean): List<UInt> {\n    return filterIndexedTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterIndexed(predicate: (index: Int, ULong) -> Boolean): List<ULong> {\n    return filterIndexedTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterIndexed(predicate: (index: Int, UByte) -> Boolean): List<UByte> {\n    return filterIndexedTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterIndexed(predicate: (index: Int, UShort) -> Boolean): List<UShort> {\n    return filterIndexedTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterIndexedTo(destination: C, predicate: (index: Int, UInt) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterIndexedTo(destination: C, predicate: (index: Int, ULong) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterIndexedTo(destination: C, predicate: (index: Int, UByte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterIndexedTo(destination: C, predicate: (index: Int, UShort) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterNot(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterNotTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterNot(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterNotTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterNot(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterNotTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterNot(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterNotTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterNotTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterNotTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterNotTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterNotTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: IntRange): List<UInt> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: IntRange): List<ULong> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: IntRange): List<UByte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: IntRange): List<UShort> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: Iterable<Int>): List<UInt> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UInt>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: Iterable<Int>): List<ULong> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<ULong>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: Iterable<Int>): List<UByte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UByte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: Iterable<Int>): List<UShort> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UShort>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: Collection<Int>): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: Collection<Int>): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: Collection<Int>): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: Collection<Int>): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: IntRange): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: IntRange): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: IntRange): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: IntRange): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.take(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UInt>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.take(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<ULong>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.take(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UByte>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.take(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UShort>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.takeLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UInt>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.takeLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<ULong>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.takeLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UByte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.takeLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UShort>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    val list = ArrayList<UInt>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    val list = ArrayList<ULong>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    val list = ArrayList<UByte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    val list = ArrayList<UShort>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.reversed(): List<UInt> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.reversed(): List<ULong> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.reversed(): List<UByte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.reversed(): List<UShort> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reversedArray(): UIntArray {\n    return UIntArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reversedArray(): ULongArray {\n    return ULongArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reversedArray(): UByteArray {\n    return UByteArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reversedArray(): UShortArray {\n    return UShortArray(storage.reversedArray())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sorted(): List<UInt> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sorted(): List<ULong> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sorted(): List<UByte> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sorted(): List<UShort> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArray(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArray(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArray(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArray(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArrayDescending(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArrayDescending(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArrayDescending(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArrayDescending(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedDescending(): List<UInt> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedDescending(): List<ULong> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedDescending(): List<UByte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedDescending(): List<UShort> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns an array of type [ByteArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.asByteArray(): ByteArray {\n    return storage\n}\n\n/**\n * Returns an array of type [IntArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.asIntArray(): IntArray {\n    return storage\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.asList(): List<UInt>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.asList(): List<ULong>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.asList(): List<UByte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.asList(): List<UShort>\n\n/**\n * Returns an array of type [LongArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.asLongArray(): LongArray {\n    return storage\n}\n\n/**\n * Returns an array of type [ShortArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.asShortArray(): ShortArray {\n    return storage\n}\n\n/**\n * Returns an array of type [UByteArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.asUByteArray(): UByteArray {\n    return UByteArray(this)\n}\n\n/**\n * Returns an array of type [UIntArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.asUIntArray(): UIntArray {\n    return UIntArray(this)\n}\n\n/**\n * Returns an array of type [ULongArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.asULongArray(): ULongArray {\n    return ULongArray(this)\n}\n\n/**\n * Returns an array of type [UShortArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.asUShortArray(): UShortArray {\n    return UShortArray(this)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.contentEquals(other: UIntArray): Boolean {\n    return storage.contentEquals(other.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.contentEquals(other: ULongArray): Boolean {\n    return storage.contentEquals(other.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.contentEquals(other: UByteArray): Boolean {\n    return storage.contentEquals(other.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.contentEquals(other: UShortArray): Boolean {\n    return storage.contentEquals(other.storage)\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentHashCode(): Int {\n    return storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentHashCode(): Int {\n    return storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentHashCode(): Int {\n    return storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentHashCode(): Int {\n    return storage.contentHashCode()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentToString(): String {\n    return joinToString(\", \", \"[\", \"]\")\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentToString(): String {\n    return joinToString(\", \", \"[\", \"]\")\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentToString(): String {\n    return joinToString(\", \", \"[\", \"]\")\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentToString(): String {\n    return joinToString(\", \", \"[\", \"]\")\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyInto(destination: UIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UIntArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyInto(destination: ULongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ULongArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyInto(destination: UByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UByteArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyInto(destination: UShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UShortArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(): UIntArray {\n    return UIntArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(): ULongArray {\n    return ULongArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(): UByteArray {\n    return UByteArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(): UShortArray {\n    return UShortArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(newSize: Int): UIntArray {\n    return UIntArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(newSize: Int): ULongArray {\n    return ULongArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(newSize: Int): UByteArray {\n    return UByteArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(newSize: Int): UShortArray {\n    return UShortArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOfRange(fromIndex: Int, toIndex: Int): UIntArray {\n    return UIntArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOfRange(fromIndex: Int, toIndex: Int): ULongArray {\n    return ULongArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOfRange(fromIndex: Int, toIndex: Int): UByteArray {\n    return UByteArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOfRange(fromIndex: Int, toIndex: Int): UShortArray {\n    return UShortArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray {\n    return UIntArray(storage + element.toInt())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray {\n    return ULongArray(storage + element.toLong())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray {\n    return UByteArray(storage + element.toByte())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray {\n    return UShortArray(storage + element.toShort())\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toInt()\n    return UIntArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toLong()\n    return ULongArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toByte()\n    return UByteArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toShort()\n    return UShortArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray {\n    return UIntArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray {\n    return ULongArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray {\n    return UByteArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray {\n    return UShortArray(storage + elements.storage)\n}\n\n/**\n * Sorts the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Returns an array of type [ByteArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.toByteArray(): ByteArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [IntArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.toIntArray(): IntArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [LongArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.toLongArray(): LongArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [ShortArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.toShortArray(): ShortArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.toTypedArray(): Array<UInt> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.toTypedArray(): Array<ULong> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.toTypedArray(): Array<UByte> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.toTypedArray(): Array<UShort> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of UByte containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.toUByteArray(): UByteArray {\n    return UByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UByteArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.toUByteArray(): UByteArray {\n    return UByteArray(this.copyOf())\n}\n\n/**\n * Returns an array of UInt containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.toUIntArray(): UIntArray {\n    return UIntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UIntArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.toUIntArray(): UIntArray {\n    return UIntArray(this.copyOf())\n}\n\n/**\n * Returns an array of ULong containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.toULongArray(): ULongArray {\n    return ULongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [ULongArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.toULongArray(): ULongArray {\n    return ULongArray(this.copyOf())\n}\n\n/**\n * Returns an array of UShort containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.toUShortArray(): UShortArray {\n    return UShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UShortArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.toUShortArray(): UShortArray {\n    return UShortArray(this.copyOf())\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMap(transform: (UInt) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMap(transform: (ULong) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMap(transform: (UByte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMap(transform: (UShort) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapTo(destination: C, transform: (UInt) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapTo(destination: C, transform: (ULong) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapTo(destination: C, transform: (UByte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapTo(destination: C, transform: (UShort) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UInt>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>> {\n    return groupByTo(LinkedHashMap<K, MutableList<ULong>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UByte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UShort>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UIntArray.groupBy(keySelector: (UInt) -> K, valueTransform: (UInt) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> ULongArray.groupBy(keySelector: (ULong) -> K, valueTransform: (ULong) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UByteArray.groupBy(keySelector: (UByte) -> K, valueTransform: (UByte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UShortArray.groupBy(keySelector: (UShort) -> K, valueTransform: (UShort) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UInt>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UInt>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<ULong>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<ULong>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UByte>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UByte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UShort>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UShort>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K, valueTransform: (UInt) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K, valueTransform: (ULong) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K, valueTransform: (UByte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K, valueTransform: (UShort) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.map(transform: (UInt) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.map(transform: (ULong) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.map(transform: (UByte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.map(transform: (UShort) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.mapIndexed(transform: (index: Int, UInt) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.mapIndexed(transform: (index: Int, ULong) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.mapIndexed(transform: (index: Int, UByte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.mapIndexed(transform: (index: Int, UShort) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapIndexedTo(destination: C, transform: (index: Int, UInt) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapIndexedTo(destination: C, transform: (index: Int, ULong) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapIndexedTo(destination: C, transform: (index: Int, UByte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapIndexedTo(destination: C, transform: (index: Int, UShort) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapTo(destination: C, transform: (UInt) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapTo(destination: C, transform: (ULong) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapTo(destination: C, transform: (UByte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapTo(destination: C, transform: (UShort) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.withIndex(): Iterable<IndexedValue<UInt>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.withIndex(): Iterable<IndexedValue<ULong>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.withIndex(): Iterable<IndexedValue<UByte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.withIndex(): Iterable<IndexedValue<UShort>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.all(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.all(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.all(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.all(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.count(predicate: (UInt) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.count(predicate: (ULong) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.count(predicate: (UByte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.count(predicate: (UShort) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.fold(initial: R, operation: (acc: R, UInt) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.fold(initial: R, operation: (acc: R, ULong) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.fold(initial: R, operation: (acc: R, UByte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.fold(initial: R, operation: (acc: R, UShort) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRight(initial: R, operation: (UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRight(initial: R, operation: (ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRight(initial: R, operation: (UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRight(initial: R, operation: (UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRightIndexed(initial: R, operation: (index: Int, UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRightIndexed(initial: R, operation: (index: Int, ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRightIndexed(initial: R, operation: (index: Int, UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRightIndexed(initial: R, operation: (index: Int, UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEach(action: (UInt) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEach(action: (ULong) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEach(action: (UByte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEach(action: (UShort) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEachIndexed(action: (index: Int, UInt) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEachIndexed(action: (index: Int, ULong) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEachIndexed(action: (index: Int, UByte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEachIndexed(action: (index: Int, UShort) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.max(): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.max(): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.max(): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.max(): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxBy(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxBy(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxBy(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxBy(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWith(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWith(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWith(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWith(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.min(): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.min(): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.min(): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.min(): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minBy(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minBy(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minBy(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minBy(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWith(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWith(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWith(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWith(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduce(operation: (acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduce(operation: (acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduce(operation: (acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduce(operation: (acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRight(operation: (UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRight(operation: (ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRight(operation: (UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRight(operation: (UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexed(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexed(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexed(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexed(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumBy(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumBy(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumBy(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumBy(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumByDouble(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumByDouble(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumByDouble(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumByDouble(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Array<out R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Array<out R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Array<out R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Array<out R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Array<out R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Array<out R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Array<out R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Array<out R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Iterable<R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Iterable<R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Iterable<R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Iterable<R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Iterable<R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Iterable<R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Iterable<R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Iterable<R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.zip(other: UIntArray): List<Pair<UInt, UInt>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.zip(other: ULongArray): List<Pair<ULong, ULong>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.zip(other: UByteArray): List<Pair<UByte, UByte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.zip(other: UShortArray): List<Pair<UShort, UShort>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.zip(other: UIntArray, transform: (a: UInt, b: UInt) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.zip(other: ULongArray, transform: (a: ULong, b: ULong) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.zip(other: UByteArray, transform: (a: UByte, b: UByte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.zip(other: UShortArray, transform: (a: UShort, b: UShort) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.sum(): ULong {\n    var sum: ULong = 0uL\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUByte\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUShort\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sum(): UInt {\n    return storage.sum().toUInt()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sum(): ULong {\n    return storage.sum().toULong()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sum(): UInt {\n    return sumBy { it.toUInt() }\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sum(): UInt {\n    return sumBy { it.toUInt() }\n}\n\n","package kotlinx.io.core.internal\n\nimport kotlinx.io.core.*\n\n/**\n * API marked with this annotation is internal and extremely fragile and not intended to be used by library users.\n * Such API could be changed without notice including rename, removal and behaviour change.\n * Also using API marked with this annotation could cause data loss or any other damage.\n */\n@Experimental(level = Experimental.Level.ERROR)\nannotation class DangerousInternalIoApi\n\n@DangerousInternalIoApi\nfun ByteReadPacket.`$unsafeAppend$`(builder: BytePacketBuilder) {\n    val builderSize = builder.size\n    val builderHead = builder.head\n\n    if (builderSize <= PACKET_MAX_COPY_SIZE && builderHead.next == null && tryWriteAppend(builderHead)) {\n        builder.afterBytesStolen()\n        return\n    }\n\n    builder.stealAll()?.let { chain ->\n        append(chain)\n    }\n}\n\n@DangerousInternalIoApi\nfun Input.prepareReadFirstHead(minSize: Int): IoBuffer? {\n    if (this is ByteReadPacketBase) {\n        return prepareReadHead(minSize)\n    }\n    if (this is IoBuffer) {\n        return if (canRead()) this else null\n    }\n\n    return prepareReadHeadFallback(minSize)\n}\n\nprivate fun Input.prepareReadHeadFallback(minSize: Int): IoBuffer? {\n    if (endOfInput) return null\n\n    val buffer = IoBuffer.Pool.borrow()\n\n    val rc = peekTo(buffer)\n    if (rc < minSize) {\n        buffer.release(IoBuffer.Pool)\n        return null\n    }\n\n    return buffer\n}\n\n@DangerousInternalIoApi\nfun Input.completeReadHead(current: IoBuffer) {\n    if (current === this) {\n        return\n    }\n    if (this is ByteReadPacketBase) {\n        val remaining = current.readRemaining\n        if (remaining == 0) {\n            ensureNext(current)\n        } else if (current.endGap < IoBuffer.ReservedSize) {\n            fixGapAfterRead(current)\n        } else {\n            updateHeadRemaining(remaining)\n        }\n        return\n    }\n\n    completeReadHeadFallback(current)\n}\n\nprivate fun Input.completeReadHeadFallback(current: IoBuffer) {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.release(IoBuffer.Pool)\n}\n\n@DangerousInternalIoApi\nfun Input.prepareReadNextHead(current: IoBuffer): IoBuffer? {\n    if (current === this) {\n        return if (canRead()) this else null\n    }\n    if (this is ByteReadPacketBase) {\n        return ensureNextHead(current)\n    }\n\n    return prepareNextReadHeadFallback(current)\n}\n\nprivate fun Input.prepareNextReadHeadFallback(current: IoBuffer): IoBuffer? {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.resetForWrite()\n\n    if (endOfInput || peekTo(current) <= 0) {\n        current.release(IoBuffer.Pool)\n        return null\n    }\n\n    return current\n}\n\n@DangerousInternalIoApi\nfun Output.prepareWriteHead(capacity: Int, current: IoBuffer?): IoBuffer {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        return prepareWriteHead(capacity)\n    }\n\n    return prepareWriteHeadFallback(current)\n}\n\nprivate fun Output.prepareWriteHeadFallback(current: IoBuffer?): IoBuffer {\n    if (current != null) {\n        writeFully(current)\n        current.resetForWrite()\n        return current\n    }\n\n    return IoBuffer.Pool.borrow()\n}\n\n@DangerousInternalIoApi\nfun Output.afterHeadWrite(current: IoBuffer) {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        return afterHeadWrite()\n    }\n\n    afterWriteHeadFallback(current)\n}\n\nprivate fun Output.afterWriteHeadFallback(current: IoBuffer) {\n    writeFully(current)\n    current.release(IoBuffer.Pool)\n}\n","package kotlinx.io.pool\n\nimport kotlinx.atomicfu.*\nimport kotlinx.io.core.*\nimport kotlin.jvm.*\n\ninterface ObjectPool<T : Any> : Closeable {\n    /**\n     * Pool capacity\n     */\n    val capacity: Int\n\n    /**\n     * borrow an instance. Pool can recycle an old instance or create a new one\n     */\n    fun borrow(): T\n\n    /**\n     * Recycle an instance. Should be recycled what was borrowed before otherwise could fail\n     */\n    fun recycle(instance: T)\n\n    /**\n     * Dispose the whole pool. None of borrowed objects could be used after the pool gets disposed\n     * otherwise it can result in undefined behaviour\n     */\n    fun dispose()\n\n    /**\n     * Does pool dispose\n     */\n    override fun close() = dispose()\n}\n\n/**\n * A pool implementation of zero capacity that always creates new instances\n */\nabstract class NoPoolImpl<T : Any> : ObjectPool<T> {\n    override val capacity: Int\n        get() = 0\n\n    override fun recycle(instance: T) {\n    }\n\n    override fun dispose() {\n    }\n}\n\n/**\n * A pool that produces at most one instance\n */\nabstract class SingleInstancePool<T : Any> : ObjectPool<T> {\n    private val borrowed = atomic(0)\n    private val disposed = atomic(false)\n\n    @Volatile\n    private var instance: T? = null\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected abstract fun disposeInstance(instance: T)\n\n    final override val capacity: Int get() = 1\n\n    final override fun borrow(): T {\n        borrowed.update {\n            if (it != 0) throw IllegalStateException(\"Instance is already consumed\")\n            1\n        }\n\n        val instance = produceInstance()\n        this.instance = instance\n\n        return instance\n    }\n\n    final override fun recycle(instance: T) {\n        if (this.instance !== instance) {\n            if (this.instance == null && borrowed.value != 0) {\n                throw IllegalStateException(\"Already recycled or an irrelevant instance tried to be recycled\")\n            }\n\n            throw IllegalStateException(\"Unable to recycle irrelevant instance\")\n        }\n\n        this.instance = null\n\n        if (!disposed.compareAndSet(false, true)) {\n            throw IllegalStateException(\"An instance is already disposed\")\n        }\n\n        disposeInstance(instance)\n    }\n\n    final override fun dispose() {\n        if (disposed.compareAndSet(false, true)) {\n            val instance = this.instance ?: return\n            this.instance = null\n\n            disposeInstance(instance)\n        }\n    }\n}\n\n/**\n * Default object pool implementation.\n */\nexpect abstract class DefaultPool<T : Any>(capacity: Int) : ObjectPool<T> {\n    /**\n     * Pool capacity.\n     */\n    final override val capacity: Int\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected open fun disposeInstance(instance: T)\n\n    /**\n     * Clear [instance]'s state before reuse: reset pointers, counters and so on\n     */\n    protected open fun clearInstance(instance: T): T\n\n    /**\n     * Validate [instance] of [T]. Could verify that the object has been borrowed from this pool\n     */\n    protected open fun validateInstance(instance: T)\n\n    final override fun borrow(): T\n\n    final override fun recycle(instance: T)\n\n    final override fun dispose()\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\n@Deprecated(\"Use useInstance instead\", ReplaceWith(\"useInstance(block)\"), level = DeprecationLevel.ERROR)\ninline fun <T : Any, R> ObjectPool<T>.useBorrowed(block: (T) -> R): R {\n    return useInstance(block)\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\ninline fun <T : Any, R> ObjectPool<T>.useInstance(block: (T) -> R): R {\n    val instance = borrow()\n    try {\n        return block(instance)\n    } finally {\n        recycle(instance)\n    }\n}\n\n",null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()","package kotlinx.io.charsets\n\nimport kotlinx.io.core.*\nimport kotlinx.io.js.*\nimport org.khronos.webgl.*\n\nactual abstract class Charset(internal val _name: String) {\n    actual abstract fun newEncoder(): CharsetEncoder\n    actual abstract fun newDecoder(): CharsetDecoder\n\n    override fun toString(): String {\n        return name\n    }\n\n    actual companion object {\n        actual fun forName(name: String): Charset {\n            if (name == \"UTF-8\" || name == \"utf-8\" || name == \"UTF8\" || name == \"utf8\") return Charsets.UTF_8\n            if (name == \"ISO-8859-1\" || name == \"iso-8859-1\"\n                || name.toLowerCase().replace('_', '-') == \"iso-8859-1\"\n                || name == \"latin1\"\n            ) {\n                return Charsets.ISO_8859_1\n            }\n            throw IllegalArgumentException(\"Charset $name is not supported\")\n        }\n\n    }\n}\n\nactual val Charset.name: String get() = _name\n\n// -----------------------\n\nactual abstract class CharsetEncoder(internal val _charset: Charset)\nprivate data class CharsetEncoderImpl(private val charset: Charset) : CharsetEncoder(charset)\nactual val CharsetEncoder.charset: Charset get() = _charset\n\nactual fun CharsetEncoder.encodeToByteArray(input: CharSequence, fromIndex: Int, toIndex: Int): ByteArray\n        = encodeToByteArrayImpl1(input, fromIndex, toIndex)\n\ninternal actual fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: IoBuffer): Int {\n    require(fromIndex <= toIndex)\n    if (charset == Charsets.ISO_8859_1) {\n        return encodeISO88591(input, fromIndex, toIndex, dst)\n    }\n\n    require(charset === Charsets.UTF_8) { \"Only UTF-8 encoding is supported in JS\" }\n\n    val encoder = TextEncoderCtor()  // Only UTF-8 is supported so we know that at most 6 bytes per character is used\n    var start = fromIndex\n    var dstRemaining = dst.writeRemaining\n\n    while (start < toIndex && dstRemaining > 0) {\n        val numChars = minOf(toIndex - start, dstRemaining / 6).coerceAtLeast(1)\n        val dropLastChar = input[start + numChars - 1].isHighSurrogate()\n        val endIndexExclusive = when {\n            dropLastChar && numChars == 1 -> start + 2\n            dropLastChar -> start + numChars - 1\n            else -> start + numChars\n        }\n\n        val array1 = encoder.encode(input.substring(start, endIndexExclusive))\n        if (array1.length > dst.writeRemaining) break\n        dst.writeFully(array1, 0, array1.length)\n        start = endIndexExclusive\n        dstRemaining -= array1.length\n    }\n\n    return start - fromIndex\n}\n\nactual fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output) {\n    require(charset === Charsets.UTF_8)\n    // we only support UTF-8 so as far as input is UTF-8 encoded string then we simply copy bytes\n    dst.writePacket(input)\n}\n\ninternal actual fun CharsetEncoder.encodeComplete(dst: IoBuffer): Boolean = true\n\n// ----------------------------------------------------------------------\n\nactual abstract class CharsetDecoder(internal val _charset: Charset)\n\nprivate data class CharsetDecoderImpl(private val charset: Charset) : CharsetDecoder(charset)\n\nactual val CharsetDecoder.charset: Charset get() = _charset\n\nactual fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int {\n    val decoder = TextDecoderFatal(charset.name, true)\n    var copied = 0\n\n    input.takeWhileSize { buffer ->\n        val rem = max - copied\n        if (rem == 0) return@takeWhileSize 0\n\n        copied += buffer.readText(decoder, dst, buffer.next == null, rem)\n        1\n    }\n\n    if (copied < max) {\n        val s = decodeWrap { decoder.decode() }\n        if (s.length > max - copied) {\n            throw UnsupportedOperationException(\"Partial trailing characters are not supported\")\n        }\n\n        dst.append(s)\n        copied += s.length\n    }\n\n    return copied\n}\n\nactual fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String {\n    if (inputLength == 0) return \"\"\n    if (input is ByteReadPacketBase && input.headRemaining >= inputLength) {\n        val decoder = TextDecoderFatal(charset._name, true)\n\n        val head = input.head\n        val text = decodeWrap {\n            when {\n                head.readPosition == 0 && inputLength == head.content.byteLength -> decoder.decode(head.content)\n                else -> decoder.decode(Int8Array(head.content, head.readPosition, inputLength))\n            }\n        }\n\n        input.discardExact(inputLength)\n        return text\n    }\n\n    return decodeExactBytesSlow(input, inputLength)\n}\n\n// -----------------------------------------------------------\n\nactual object Charsets {\n    actual val UTF_8: Charset = CharsetImpl(\"UTF-8\")\n    actual val ISO_8859_1: Charset = CharsetImpl(\"ISO-8859-1\")\n}\n\nprivate data class CharsetImpl(val name: String) : Charset(name) {\n    override fun newEncoder(): CharsetEncoder = CharsetEncoderImpl(this)\n    override fun newDecoder(): CharsetDecoder = CharsetDecoderImpl(this)\n}\n\n\nactual class MalformedInputException actual constructor(message: String) : Throwable(message)\n\n\nprivate fun CharsetDecoder.decodeExactBytesSlow(input: Input, inputLength: Int): String {\n    val decoder = TextDecoderFatal(charset.name, true)\n    var inputRemaining = inputLength\n    val sb = StringBuilder(inputLength)\n\n    decodeWrap {\n        input.takeWhileSize(6) { buffer ->\n            val chunkSize = buffer.readRemaining\n            val size = minOf(chunkSize, inputRemaining)\n            val text = when {\n                buffer.readPosition == 0 && buffer.content.byteLength == size -> decoder.decodeStream(buffer.content, true)\n                else -> decoder.decodeStream(Int8Array(buffer.content, buffer.readPosition, size), true)\n            }\n            sb.append(text)\n\n            buffer.discardExact(size)\n            inputRemaining -= size\n\n            if (inputRemaining > 0) 6 else 0\n        }\n\n        if (inputRemaining > 0) {\n            input.takeWhile { buffer ->\n                val chunkSize = buffer.readRemaining\n                val size = minOf(chunkSize, inputRemaining)\n                val text = when {\n                    buffer.readPosition == 0 && buffer.content.byteLength == size -> decoder.decode(buffer.content)\n                    else -> decoder.decodeStream(Int8Array(buffer.content, buffer.readPosition, size), true)\n                }\n                sb.append(text)\n                buffer.discardExact(size)\n                inputRemaining -= size\n                true\n            }\n        }\n\n        sb.append(decoder.decode())\n    }\n\n    return sb.toString()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","package kotlinx.io.js\n\nimport kotlinx.io.charsets.*\nimport kotlinx.io.core.*\nimport org.khronos.webgl.*\n\n@Deprecated(\"Use readText with charset instead\", ReplaceWith(\"readText(Charset.forName(encoding), max)\", \"kotlinx.io.core.readText\", \"kotlinx.io.charsets.Charset\"), level = DeprecationLevel.ERROR)\nfun ByteReadPacket.readText(encoding: String, max: Int = Int.MAX_VALUE): String = readText(Charset.forName(encoding), max)\n\n@Deprecated(\"Use readText with charset instead\", ReplaceWith(\"readText(out, Charset.forName(encoding), max)\", \"kotlinx.io.core.readText\", \"kotlinx.io.charsets.Charset\"), level = DeprecationLevel.ERROR)\nfun ByteReadPacket.readText(encoding: String = \"UTF-8\", out: Appendable, max: Int = Int.MAX_VALUE): Int {\n    return readText(out, Charset.forName(encoding), max)\n}\n\ninternal external class TextDecoder(encoding: String, options: dynamic = definedExternally) {\n    val encoding: String\n\n    fun decode(): String\n    fun decode(buffer: ArrayBuffer): String\n    fun decode(buffer: ArrayBuffer, options: dynamic): String\n    fun decode(buffer: ArrayBufferView): String\n    fun decode(buffer: ArrayBufferView, options: dynamic): String\n}\n\nprivate val STREAM_TRUE = Any().apply {\n    with(this.asDynamic()) {\n        stream = true\n    }\n}\n\nprivate val FATAL_TRUE = Any().apply {\n    with(this.asDynamic()) {\n        fatal = true\n    }\n}\n\ninternal fun TextDecoderFatal(encoding: String, fatal: Boolean = true): TextDecoder {\n    // PhantomJS does not support TextDecoder yet so we use node module text-encoding for tests\n    if (js(\"typeof TextDecoder\") == \"undefined\") {\n        val module = js(\"require('text-encoding')\")\n        if (module.TextDecoder === undefined) throw IllegalStateException(\"TextDecoder is not supported by your browser and no text-encoding module found\")\n        val ctor = module.TextDecoder\n        val objPrototype = js(\"Object\").create(ctor.prototype)\n\n        @Suppress(\"UnsafeCastFromDynamic\")\n        return if (fatal) ctor.call(objPrototype, encoding, FATAL_TRUE)\n        else ctor.call(objPrototype, encoding)\n    }\n\n    return if (fatal) TextDecoder(encoding, FATAL_TRUE) else TextDecoder(encoding)\n}\n\ninternal inline fun TextDecoder.decodeStream(buffer: ArrayBufferView, stream: Boolean): String {\n    decodeWrap {\n        return if (stream) {\n            decode(buffer, STREAM_TRUE)\n        } else {\n            decode(buffer)\n        }\n    }\n}\n\ninternal inline fun TextDecoder.decodeStream(buffer: ArrayBuffer, stream: Boolean): String {\n    decodeWrap {\n        return if (stream) {\n            decode(buffer, STREAM_TRUE)\n        } else {\n            decode(buffer)\n        }\n    }\n}\n\ninternal inline fun <R> decodeWrap(block: () -> R): R {\n    try {\n        return block()\n    } catch (t: Throwable) {\n        throw MalformedInputException(\"Failed to decode bytes: ${t.message ?: \"no cause provided\"}\")\n    }\n}\n","@file:Suppress(\"ReplaceRangeToWithUntil\", \"RedundantModalityModifier\")\n\npackage kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.js.*\nimport kotlinx.io.pool.*\nimport org.khronos.webgl.*\n\nactual class IoBuffer internal constructor(\n        internal var content: ArrayBuffer,\n        internal actual val origin: IoBuffer?\n) : Input, Output {\n    @Deprecated(\n        \"Suppress warning.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    @Suppress(\"unused\")\n    actual final override val doNotImplementInputButExtendAbstractInputInstead: Nothing\n        get() = error(\"Should be never accessed.\")\n\n    @Deprecated(\n        \"Suppress warning.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    @Suppress(\"unused\")\n    actual final override val doNotImplementOutputButExtendAbstractOutputInstead: Nothing\n        get() = error(\"Should be never accessed.\")\n\n    private var refCount = 1\n\n    internal var readPosition = 0\n    internal var writePosition = 0\n    private var limit = content.byteLength\n\n    private var view = if (content === EmptyBuffer) EmptyDataView else DataView(content)\n    private var i8 = if (content === EmptyBuffer) Empty8 else Int8Array(content, 0, limit)\n    private var i16 = if (content === EmptyBuffer) Empty16 else Int16Array(content, 0, limit / 2)\n    private var i32 = if (content === EmptyBuffer) Empty32 else Int32Array(content, 0, limit / 4)\n    private var f32 = if (content === EmptyBuffer) EmptyF32 else Float32Array(content, 0, limit / 4)\n    private var f64 = if (content === EmptyBuffer) EmptyF64 else Float64Array(content, 0, limit / 8)\n\n    private var littleEndian = false\n    private var platformEndian = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN\n\n    init {\n        require(origin !== this) { \"origin shouldn't point to itself\" }\n    }\n\n    @ExperimentalIoApi\n    actual var attachment: Any? = null\n\n    actual var next: IoBuffer? = null\n\n    override val endOfInput: Boolean get() = writePosition == readPosition\n\n    /**\n     * Backing buffer capacity. Value for released buffer is unspecified\n     */\n    actual val capacity: Int get() = content.byteLength\n    actual val readRemaining get() = writePosition - readPosition\n    actual val writeRemaining get() = limit - writePosition\n\n    actual fun canRead() = writePosition > readPosition\n    actual fun canWrite() = writePosition < limit\n\n    actual fun reserveStartGap(n: Int) {\n        if (readPosition > 0) throw IllegalStateException(\"Start gap is already reserved\")\n        if (writePosition > 0) throw IllegalStateException(\"Start gap is already reserved\")\n        writePosition = n\n        readPosition = n\n    }\n\n    actual fun reserveEndGap(n: Int) {\n        if (limit != content.byteLength) throw IllegalStateException(\"End gap is already reserved\")\n        limit -= n\n    }\n\n    actual val startGap: Int get() = readPosition\n    actual val endGap: Int get() = content.byteLength - limit\n\n    @Deprecated(\"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n        \"do readXXX/writeXXX with X.reverseByteOrder() instead.\")\n    actual final override var byteOrder: ByteOrder\n        get() = if (littleEndian) ByteOrder.LITTLE_ENDIAN else  ByteOrder.BIG_ENDIAN\n        set(value) {\n            littleEndian = when (value) {\n                ByteOrder.BIG_ENDIAN -> false\n                ByteOrder.LITTLE_ENDIAN -> true\n            }\n            platformEndian = value === ByteOrder.nativeOrder()\n        }\n\n    actual final override fun readByte(): Byte {\n        if (readRemaining < 0) throw IllegalStateException(\"No bytes available for read\")\n        val value = i8[readPosition]\n        readPosition++\n        return value\n    }\n\n    actual final override fun writeByte(v: Byte) {\n        if (writeRemaining < 1) throw IllegalStateException(\"No space left for writing\")\n        i8[writePosition] = v\n        writePosition++\n    }\n\n    actual final override fun readShort(): Short {\n        if (readRemaining < 2) throw IllegalStateException(\"Not enough bytes available to read a short\")\n        val value = view.getInt16(readPosition, littleEndian)\n        readPosition += 2\n        return value\n    }\n\n    actual final override fun writeShort(v: Short) {\n        if (writeRemaining < 2) throw IllegalStateException(\"Not enough space left to write a short\")\n        view.setInt16(writePosition, v, littleEndian)\n        writePosition += 2\n    }\n\n    actual final override fun readInt(): Int {\n        if (readRemaining < 4) throw IllegalStateException(\"Not enough bytes available to read an int\")\n        return readIntUnsafe()\n    }\n\n    private fun readIntUnsafe(): Int {\n        val value = view.getInt32(readPosition, littleEndian)\n        readPosition += 4\n        return value\n    }\n\n    actual final override fun writeInt(v: Int) {\n        if (writeRemaining < 4) throw IllegalStateException(\"Not enough space left to write an int\")\n        view.setInt32(writePosition, v, littleEndian)\n        writePosition += 4\n    }\n\n    actual final override fun readFloat(): Float {\n        if (readRemaining < 4) throw IllegalStateException(\"Not enough bytes available to read a float\")\n        val value = view.getFloat32(readPosition, littleEndian)\n        readPosition += 4\n        return value\n    }\n\n    actual final override fun writeFloat(v: Float) {\n        if (writeRemaining < 4) throw IllegalStateException(\"Not enough space left to write a float\")\n        view.setFloat32(writePosition, v, littleEndian)\n        writePosition += 4\n    }\n\n    actual final override fun readDouble(): Double {\n        if (readRemaining < 8) throw IllegalStateException(\"Not enough bytes available to read a double\")\n        val value = view.getFloat64(readPosition, littleEndian)\n        readPosition += 8\n        return value\n    }\n\n    actual final override fun writeDouble(v: Double) {\n        if (writeRemaining < 8) throw IllegalStateException(\"Not enough space left to write a double\")\n        view.setFloat64(writePosition, v, littleEndian)\n        writePosition += 8\n    }\n\n    actual final override fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        if (writeRemaining < length) throw IllegalStateException(\"Not enough space left ($writeRemaining) to write $length bytes\")\n        val wp = writePosition\n        val i8 = i8\n\n        for (idx in 0 .. length - 1) {\n            i8[wp + idx] = src[offset + idx]\n        }\n\n        writePosition = wp + length\n    }\n\n    actual final override fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 2) throw IllegalStateException(\"Not enough space left to write a short array of length $length\")\n        var wp = writePosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && wp and 1 == 0) {\n            val array = i16\n            var j = wp / 2\n\n            for (i in offset .. offset + length - 1) {\n                array[j++] = src[i]\n            }\n\n            writePosition = wp + length * 2\n        }\n        else if (platformEndian) {\n            val array = Int16Array(content, wp)\n            for (i in offset .. offset + length - 1) {\n                array[i - offset] = src[i]\n            }\n            writePosition = wp + length * 2\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (i in offset .. offset + length - 1) {\n                view.setInt16(wp, src[i], littleEndian)\n                wp += 2\n            }\n\n            writePosition = wp\n        }\n    }\n\n    actual final override fun writeFully(src: IntArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 4) throw IllegalStateException(\"Not enough space left to write an int array of length $length\")\n        var wp = writePosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && wp and 3 == 0) {\n            val array = i32\n            var j = wp / 4\n\n            for (i in offset .. offset + length - 1) {\n                array[j++] = src[i]\n            }\n\n            writePosition = wp + length * 4\n        }\n        else if (platformEndian) {\n            val array = Int32Array(content, wp)\n            for (i in offset .. offset + length - 1) {\n                array[i - offset] = src[i]\n            }\n            writePosition = wp + length * 4\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (i in offset..offset + length - 1) {\n                view.setInt32(wp, src[i], littleEndian)\n                wp += 4\n            }\n\n            writePosition = wp\n        }\n    }\n\n    actual final override fun writeFully(src: LongArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 8) throw IllegalStateException(\"Not enough space left to write a long array of length $length\")\n\n        for (i in offset .. offset + length - 1) {\n            writeLong(src[i])\n        }\n    }\n\n    actual final override fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 4) throw IllegalStateException(\"Not enough space left to write a float array of length $length\")\n        var wp = writePosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && wp and 3 == 0) {\n            val array = f32\n            var j = wp / 4\n\n            for (i in offset .. offset + length - 1) {\n                array[j++] = src[i]\n            }\n\n            writePosition = wp + length * 4\n        }\n        else if (platformEndian) {\n            val array = Float32Array(content, wp)\n            for (i in offset .. offset + length - 1) {\n                array[i - offset] = src[i]\n            }\n            writePosition = wp + length * 4\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (i in offset..offset + length - 1) {\n                view.setFloat32(wp, src[i], littleEndian)\n                wp += 4\n            }\n\n            writePosition = wp\n        }\n    }\n\n    actual final override fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        if (writeRemaining < length * 8) throw IllegalStateException(\"Not enough space left to write a double array of length $length\")\n        var wp = writePosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && wp and 7 == 0) {\n            val array = f64\n            var j = wp / 8\n\n            for (i in offset .. offset + length - 1) {\n                array[j++] = src[i]\n            }\n\n            writePosition = wp + length * 8\n        }\n        else if (platformEndian) {\n            val array = Float64Array(content, wp)\n            for (i in offset .. offset + length - 1) {\n                array[i - offset] = src[i]\n            }\n            writePosition = wp + length * 8\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (i in offset..offset + length - 1) {\n                view.setFloat64(wp, src[i], littleEndian)\n                wp += 8\n            }\n\n            writePosition = wp\n        }\n    }\n\n    actual final override fun writeFully(src: IoBuffer, length: Int) {\n        require(length <= src.readRemaining) { \"length is too large: not enough bytes to read $length > ${src.readRemaining}\"}\n        require(length <= writeRemaining) { \"length is too large: not enough room to write $length > $writeRemaining\" }\n\n        val otherEnd = src.readPosition + length\n        val sub = src.i8.subarray(src.readPosition, otherEnd)\n        i8.set(sub, writePosition)\n        src.readPosition = otherEnd\n        writePosition += length\n    }\n\n    actual final override fun fill(n: Long, v: Byte) {\n        if (writeRemaining.toLong() < n) throw IllegalStateException(\"Not enough space to fill with $n values\")\n\n        val wp = writePosition\n        repeat(n.toInt()) {\n            i8[wp + it] = v\n        }\n\n        writePosition += n.toInt()\n    }\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    actual fun read(dst: ByteArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    actual final override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        val rp = readPosition\n        val i8 = i8\n\n        for (idx in 0 .. length - 1) {\n            dst[offset + idx] = i8[rp + idx]\n        }\n\n        readPosition += length\n    }\n\n    actual final override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        if (readRemaining < length * 2) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length short integers\")\n        var rp = readPosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && rp and 1 == 0) {\n            val array = i16\n            var j = rp / 2\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 2\n        } else if (platformEndian) {\n            val array = Int16Array(content, rp)\n            var j = 0\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 2\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n            for (idx in offset..offset + length - 1) {\n                dst[idx] = view.getInt16(rp, littleEndian)\n                rp += 2\n            }\n\n            readPosition = rp\n        }\n    }\n\n    actual final override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: IntArray, offset: Int, length: Int) {\n        if (readRemaining < length * 4) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length integers\")\n        var rp = readPosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && rp and 3 == 0) {\n            val array = i32\n            var j = rp / 4\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 4\n        } else if (platformEndian) {\n            val array = Int32Array(content, rp)\n            var j = 0\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 4\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (idx in offset..offset + length - 1) {\n                dst[idx] = view.getInt32(rp, littleEndian)\n                rp += 4\n            }\n\n            readPosition = rp\n        }\n    }\n\n    actual final override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: LongArray, offset: Int, length: Int) {\n        if (readRemaining < length * 8) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length long integers\")\n\n        for (idx in offset .. offset + length - 1) {\n            dst[idx] = readLongUnsafe()\n        }\n    }\n\n    actual final override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        if (readRemaining < length * 4) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length float numbers\")\n        var rp = readPosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && rp and 3 == 0) {\n            val array = f32\n            var j = rp / 4\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 4\n        } else if (platformEndian) {\n            val array = Float32Array(content, rp)\n            var j = 0\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 4\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (idx in offset..offset + length - 1) {\n                dst[idx] = view.getFloat32(rp, littleEndian)\n                rp += 4\n            }\n\n            readPosition = rp\n        }\n    }\n\n    actual final override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        if (readRemaining < length * 8) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length double float numbers\")\n        var rp = readPosition\n        val platformEndian = platformEndian\n\n        if (platformEndian && rp and 7 == 0) {\n            val array = f64\n            var j = rp / 8\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 8\n        } else if (platformEndian) {\n            val array = Float64Array(content, rp)\n            var j = 0\n\n            for (i in offset..offset + length - 1) {\n                dst[i] = array[j++]\n            }\n\n            readPosition = rp + length * 8\n        } else {\n            val littleEndian = littleEndian\n            val view = view\n\n            for (idx in offset..offset + length - 1) {\n                dst[idx] = view.getFloat64(rp, littleEndian)\n                rp += 8\n            }\n\n            readPosition = rp\n        }\n    }\n\n    actual final override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, length)\n        return size\n    }\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    fun read(dst: Array<Byte>, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    fun readFully(dst: Array<Byte>, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        val rp = readPosition\n        val i8 = i8\n\n        for (idx in 0 .. length - 1) {\n            dst[offset + idx] = i8[rp + idx]\n        }\n\n        readPosition += length\n    }\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    fun read(dst: ArrayBuffer, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    final override fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        val to = Int8Array(dst, offset, length)\n\n        val rp = readPosition\n        val rem = writePosition - rp\n        val i8 = i8\n\n        if (rp == 0 && length == rem) {\n            to.set(i8, offset)\n        } else if (length < 100) {\n            for (i in 0 .. length - 1) {\n                to[offset + i] = i8[rp + i]\n            }\n        } else {\n            val from = Int8Array(content, rp, length)\n            to.set(from)\n        }\n\n        readPosition = rp + length\n    }\n\n    override fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readAvailable(dst: IoBuffer, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(dst.writeRemaining, readRemaining, length)\n        readFully(dst, size)\n        return size\n    }\n\n    override fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        if (length > dst.byteLength) throw IllegalArgumentException(\"Destination buffer overflow: length = $length, buffer capacity ${dst.byteLength}\")\n        require(offset >= 0) { \"offset should be positive\" }\n        require(offset + length <= dst.byteLength) { throw IndexOutOfBoundsException(\"\") }\n\n        readFully(dst.buffer, dst.byteOffset + offset, length)\n    }\n\n    override fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(length, readRemaining)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    @Deprecated(\"Use readFully instead\", ReplaceWith(\"readFully(dst, offset, length)\"), level = DeprecationLevel.ERROR)\n    fun read(dst: Int8Array, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    override fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        val rp = readPosition\n        val rem = writePosition - rp\n        val i8 = i8\n\n        if (rp == 0 && rem == length) {\n            dst.set(i8, offset)\n        } else if (length < 100) {\n            for (i in 0 .. length - 1) {\n                dst[offset + i] = i8[rp + i]\n            }\n        } else {\n            val from = Int8Array(content, rp, length)\n            dst.set(from, offset)\n        }\n\n        readPosition = rp + length\n    }\n\n    override fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(readRemaining, length)\n        readFully(dst, offset, size)\n        return size\n    }\n\n    actual final override fun readFully(dst: IoBuffer, length: Int) {\n        if (readRemaining < length) throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        if (dst.writeRemaining < length) throw IllegalArgumentException(\"Not enough free space in dst buffer to write $length bytes\")\n\n        val srcBuffer = if (i8.length == length) i8 else Int8Array(content, readPosition, length)\n        dst.i8.set(srcBuffer, dst.writePosition)\n\n        dst.writePosition += length\n        readPosition += length\n    }\n\n    actual final override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq ?: \"null\", start, end)\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    actual final override fun append(csq: CharSequence?): Appendable {\n        return if (csq == null) append(\"null\") else append(csq, 0, csq.length)\n    }\n\n    actual final override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq, start, end)\n\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    actual override fun append(c: Char): Appendable {\n        val wp = writePosition\n        val s = i8.putUtf8Char(c.toInt(), limit - wp, wp)\n        if (s == 0) notEnoughFreeSpace(c)\n        writePosition = wp + s\n        return this\n    }\n\n    private fun notEnoughFreeSpace(c: Char): Nothing {\n        throw IllegalStateException(\"Not Enough free space to append character '$c', remaining $writeRemaining bytes\")\n    }\n\n    actual fun appendChars(csq: CharArray, start: Int, end: Int): Int {\n        val i8 = i8\n        var wp = writePosition\n        val l = limit\n        var rc = end\n\n        for (idx in start until end) {\n            val ch = csq[idx].toInt()\n            if (ch > 0x7f || wp >= l) {\n                rc = idx\n                break\n            }\n\n            i8[wp++] = ch.toByte()\n        }\n\n        if (rc >= end || wp == l) {\n            writePosition = wp\n            return rc\n        }\n\n        return appendCharsUtf8(csq, rc, end, wp)\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Int.isSurrogateCodePoint() = this in 55296..57343\n\n    private fun appendCharsUtf8(csq: CharArray, start: Int, end: Int, wp0: Int): Int {\n        val i8 = i8\n        val l = limit\n        var wp = wp0\n        var idx = start\n\n        while (idx < end) {\n            val ch = csq[idx++].toInt()\n\n            val size = if (ch.isSurrogateCodePoint()) i8.putUtf8CharSurrogate(ch, csq[idx++].toInt(), l - wp, wp)\n            else i8.putUtf8Char(ch, l - wp, wp)\n\n            if (size == 0) {\n                return appendCharFailed(ch, idx, wp)\n            }\n\n            wp += size\n        }\n\n        writePosition = wp\n        return end\n    }\n\n    actual fun appendChars(csq: CharSequence, start: Int, end: Int): Int {\n        val i8 = i8\n        var wp = writePosition\n        val l = limit\n        var rc = end\n\n        for (idx in start until end) {\n            val ch = csq[idx].toInt()\n            if (ch > 0x7f || wp >= l) {\n                rc = idx\n                break\n            }\n\n            i8[wp++] = ch.toByte()\n        }\n\n        if (rc >= end || wp == limit) {\n            writePosition = wp\n            return rc\n        }\n\n        return appendCharsUtf8(csq, rc, end, wp)\n    }\n\n    private fun appendCharsUtf8(csq: CharSequence, start: Int, end: Int, wp0: Int): Int {\n        val i8 = i8\n        val l = limit\n        var wp = wp0\n        var idx = start\n\n        while (idx < end) {\n            val ch = csq[idx++].toInt()\n            val remaining = l - wp\n            val size = if (ch.isSurrogateCodePoint()) i8.putUtf8CharSurrogate(ch, csq[idx++].toInt(), remaining, wp)\n                else i8.putUtf8Char(ch, remaining, wp)\n\n            if (size == 0) {\n                return appendCharFailed(ch, idx, wp)\n            }\n\n            wp += size\n        }\n\n        writePosition = wp\n        return end\n    }\n\n    private fun appendCharFailed(ch: Int, idx: Int, wp: Int): Int {\n        writePosition = wp\n        return if (ch.isSurrogateCodePoint()) idx - 2 else idx - 1\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Int8Array.putUtf8Char(v: Int, remaining: Int, wp: Int): Int {\n        return when {\n            v in 1..0x7f -> {\n                if (remaining < 1) return 0\n                this[wp] = v.toByte()\n                1\n            }\n            v > 0xffff -> {\n                if (remaining < 4) return 0\n                this[wp    ] = (0xf0 or ((v shr 18) and 0x3f)).toByte()\n                this[wp + 1] = (0x80 or ((v shr 12) and 0x3f)).toByte()\n                this[wp + 2] = (0x80 or ((v shr  6) and 0x3f)).toByte()\n                this[wp + 3] = (0x80 or ( v         and 0x3f)).toByte()\n                4\n            }\n            v > 0x7ff -> {\n                if (remaining < 3) return 0\n                this[wp    ] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n                this[wp + 1] = (0x80 or ((v shr  6) and 0x3f)).toByte()\n                this[wp + 2] = (0x80 or ( v         and 0x3f)).toByte()\n                3\n            }\n            else -> {\n                if (remaining < 2) return 0\n                this[wp    ] = (0xc0 or ((v shr  6) and 0x1f)).toByte()\n                this[wp + 1] = (0x80 or ( v         and 0x3f)).toByte()\n                2\n            }\n        }\n    }\n\n    private fun Int8Array.putUtf8CharSurrogate(high: Int, low: Int, remaining: Int, wp: Int): Int {\n        val highValue = (high and 0x7ff) shl 10\n        val lowValue = (low and 0x3ff)\n        val value = 0x010000 or (highValue or lowValue)\n\n        return putUtf8Char(value, remaining, wp)\n    }\n\n    actual final override fun tryPeek(): Int {\n        val readPosition = readPosition\n        val writePosition = writePosition\n        if (readPosition == writePosition) return -1\n\n        return i8[readPosition].toInt() and 0xff\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    actual final override fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    @Deprecated(\"Use discardExact instead.\")\n    actual final override fun discard(n: Long): Long {\n        val size = minOf(readRemaining.toLong(), n).toInt()\n        readPosition += size\n        return size.toLong()\n    }\n\n    @Deprecated(\"Use writeFully instead\", level = DeprecationLevel.ERROR)\n    actual fun write(array: ByteArray, offset: Int, length: Int) {\n        writeFully(array, offset, length)\n    }\n\n    fun writeFully(src: ArrayBufferView, offset: Int, length: Int) {\n        if (writeRemaining < length) throw IllegalStateException(\"Not enough space left ($writeRemaining) to write $length bytes\")\n        val wp = writePosition\n        val rem = limit - wp\n        val i8 = i8\n\n        if (length > rem) throw IndexOutOfBoundsException()\n\n        val from = Int8Array(src.buffer, src.byteOffset + offset, length)\n        i8.set(from, wp)\n\n        writePosition = wp + length\n    }\n\n    fun write(src: Int8Array, offset: Int, length: Int) {\n        if (writeRemaining < length) throw IllegalStateException(\"Not enough space left ($writeRemaining) to write $length bytes\")\n        val wp = writePosition\n        val rem = limit - wp\n        val i8 = i8\n\n        if (length > rem) throw IndexOutOfBoundsException()\n        if (offset == 0 && length == src.length) {\n            i8.set(src, wp)\n        } else if (length < 100) {\n            for (i in 0 .. length - 1) {\n                i8[wp + i] = src[offset + i]\n            }\n        } else {\n            val from = Int8Array(src.buffer, src.byteOffset + offset, length)\n            i8.set(from, wp)\n        }\n\n        writePosition = wp + length\n    }\n\n    actual final override fun readLong(): Long {\n        if (readRemaining < 8) throw IllegalStateException(\"Not enough bytes available to read a long\")\n        return readLongUnsafe()\n    }\n\n    private fun readLongUnsafe(): Long {\n        val m = 0xffffffff\n        val a = readIntUnsafe().toLong() and m\n        val b = readIntUnsafe().toLong() and m\n\n        return if (littleEndian) {\n            (b shl 32) or a\n        } else {\n            (a shl 32) or b\n        }\n    }\n\n    actual final override fun writeLong(v: Long) {\n        if (writeRemaining < 8) throw IllegalStateException(\"Not enough space left to write a long\")\n        val m = 0xffffffff\n        val a = (v shr 32).toInt()\n        val b = (v and m).toInt()\n\n        if (littleEndian) {\n            writeInt(b)\n            writeInt(a)\n        } else {\n            writeInt(a)\n            writeInt(b)\n        }\n    }\n\n    actual fun discardExact(n: Int) {\n        require(n >= 0) { \"Number of bytes to be discarded shouldn't be negative: $n\" }\n\n        val rem = readRemaining\n        if (n > rem) {\n            throw IllegalArgumentException(\"Can't discard $n bytes: only $rem bytes available\")\n        }\n\n        readPosition += n\n    }\n\n    actual fun pushBack(n: Int) {\n        if (readPosition < n) throw IllegalStateException(\"Nothing to push back\")\n        readPosition -= n\n    }\n\n    actual fun resetForWrite() {\n        resetForWrite(content.byteLength)\n    }\n\n    actual fun resetForWrite(limit: Int) {\n        require(limit >= 0) { \"Limit shouldn't be negative: $limit\" }\n        require(limit <= content.byteLength) { \"Limit shouldn't be bigger than buffer size: limit = $limit, size = ${content.byteLength}\"}\n\n        readPosition = 0\n        writePosition = 0\n        this.limit = limit\n    }\n\n    actual fun resetForRead() {\n        readPosition = 0\n        limit = content.byteLength\n        writePosition = limit\n    }\n\n    actual fun isExclusivelyOwned(): Boolean = refCount == 1\n\n    actual fun makeView(): IoBuffer {\n        if (this === Empty) return this\n\n        val o = origin ?: this\n        o.acquire()\n\n        val view = IoBuffer(content, o)\n        view.attachment = attachment\n        view.readPosition = readPosition\n        view.writePosition = writePosition\n        view.limit = limit\n\n        return view\n    }\n\n    actual fun release(pool: ObjectPool<IoBuffer>) {\n        if (release()) {\n            resetForWrite()\n\n            if (origin != null) {\n                unlink()\n                origin.release(pool)\n            } else {\n                pool.recycle(this)\n            }\n        }\n    }\n\n    @Deprecated(\"Use writeFully instead\", ReplaceWith(\"writeFully(src, length)\"), level = DeprecationLevel.ERROR)\n    actual fun writeBuffer(src: IoBuffer, length: Int): Int {\n        writeFully(src, length)\n        return length\n    }\n\n    actual final override fun flush() {\n    }\n\n    internal fun readText(decoder: TextDecoder, out: Appendable, lastBuffer: Boolean, max: Int = Int.MAX_VALUE): Int {\n        require(max >= 0) { \"max shouldn't be negative: $max\" }\n\n        if (readRemaining == 0) return 0\n\n        val rawResult = decoder.decodeStream(i8.subarray(readPosition, writePosition), !lastBuffer)\n        val result = if (rawResult.length <= max) {\n            readPosition = writePosition\n            rawResult\n        } else {\n            val actual = rawResult.substring(0, max)\n\n            // as js's text decoder is too stupid, let's guess new readPosition\n            val subDecoder = TextDecoderFatal(decoder.encoding, true)\n            val subArray = Int8Array(1)\n            var subDecoded = 0\n\n            for (i in readPosition until writePosition) {\n                subArray[0] = i8[i]\n                subDecoded += subDecoder.decodeStream(subArray, true).length\n\n                if (subDecoded >= max) {\n                    readPosition = i + 1\n                    break\n                }\n            }\n\n            if (subDecoded < max) {\n                subDecoded += decodeWrap { subDecoder.decode().length }\n\n                if (subDecoded >= max) {\n                    readPosition = writePosition\n                } else {\n                    throw IllegalStateException(\"Failed to readText: don't know how to update read position\")\n                }\n            }\n\n            actual\n        }\n\n        out.append(result)\n\n        return result.length\n    }\n\n    @PublishedApi\n    internal fun readableView(): DataView {\n        val readPosition = readPosition\n        val writePosition = writePosition\n\n        return when {\n            readPosition == writePosition -> EmptyDataView\n            readPosition == 0 && writePosition == content.byteLength -> view\n            else -> DataView(content, readPosition, writePosition - readPosition)\n        }\n    }\n\n    @PublishedApi\n    internal fun writableView(): DataView {\n        val writePosition = writePosition\n        val limit = limit\n\n        return when {\n            writePosition == limit -> EmptyDataView\n            writePosition == 0 && limit == content.byteLength -> view\n            else -> DataView(content, writePosition, limit - writePosition)\n        }\n    }\n\n    @PublishedApi\n    internal fun commitWritten(n: Int) {\n        writePosition += n\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of readable bytes.\n     * The [block] function should return number of consumed bytes.\n     * @return number of bytes consumed\n     */\n    @ExperimentalIoApi\n    inline fun readDirect(block: (DataView) -> Int): Int {\n        val view = readableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        discardExact(rc)\n        return rc\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of the free space.\n     * The [block] function should return number of written bytes.\n     * @return number of bytes written\n     */\n    @ExperimentalIoApi\n    inline fun writeDirect(block: (DataView) -> Int): Int {\n        val view = writableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\"}\n        check(rc <= writeRemaining) { \"The returned value from block function is too big: $rc > $writeRemaining\" }\n        commitWritten(rc)\n        return rc\n    }\n\n    internal actual fun restoreEndGap(n: Int) {\n        val newLimit = limit - n\n        limit = newLimit\n        if (writePosition > newLimit) {\n            writePosition = newLimit\n        }\n        if (readPosition > newLimit) {\n            readPosition = newLimit\n        }\n    }\n\n    internal actual fun restoreStartGap(n: Int) {\n        val rp = readPosition\n        if (rp < n) {\n            throw IllegalArgumentException(\"Can't restore start gap: $n bytes were not reserved before\")\n        }\n\n        readPosition = rp - n\n    }\n\n    internal actual fun writeBufferPrepend(other: IoBuffer) {\n        val size = other.readRemaining\n        require(size <= startGap) { \"size should be greater than startGap (size = $size, startGap = $startGap)\" }\n\n        val otherEnd = other.readPosition + size\n        val sub = other.i8.subarray(other.readPosition, otherEnd)\n\n        i8.set(sub, readPosition - size)\n        readPosition -= size\n        other.readPosition += size\n    }\n\n    internal actual fun writeBufferAppend(other: IoBuffer, maxSize: Int) {\n        val size = minOf(other.readRemaining, maxSize)\n        require(size <= writeRemaining + endGap) { \"should be greater than write space + end gap (size = $size, \" +\n                \"writeRemaining = $writeRemaining, endGap = $endGap, rem+gap = ${writeRemaining + endGap}\" }\n\n        val otherEnd = other.readPosition + size\n        val sub = other.i8.subarray(other.readPosition, otherEnd)\n\n        i8.set(sub, writePosition)\n        writePosition += size\n        if (writePosition > limit) {\n            limit = writePosition\n        }\n        other.readPosition += size\n    }\n\n    internal fun unlink() {\n        if (refCount != 0) throw IllegalStateException(\"Unable to unlink buffers: buffer view is in use\")\n        content = EmptyBuffer\n        i8 = Empty8\n        i16 = Empty16\n        i32 = Empty32\n        f32 = EmptyF32\n        f64 = EmptyF64\n        view = EmptyDataView\n        resetForWrite()\n    }\n\n    private fun acquire() {\n        val v = refCount\n        if (v == 0) throw IllegalStateException(\"Failed to acquire buffer: buffer has been already released\")\n        refCount = v + 1\n    }\n\n    private fun release(): Boolean {\n        if (this === Empty) throw IllegalStateException(\"attempted to release IoBuffer.Empty\")\n\n        val v = refCount\n        if (v == 0) throw IllegalStateException(\"Unable to release: buffer has been already released\")\n        val newCount = v - 1\n        refCount = newCount\n        return newCount == 0\n    }\n\n    actual override fun close() {\n        throw UnsupportedOperationException(\"close for buffer view is not supported\")\n    }\n\n    override fun toString(): String =\n        \"Buffer[readable = $readRemaining, writable = $writeRemaining, startGap = $startGap, endGap = $endGap]\"\n\n    actual companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [IoBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @Deprecated(\"This implementation detail is going to become internal.\")\n        actual val ReservedSize: Int = 8\n\n        private val EmptyBuffer = ArrayBuffer(0)\n        private val EmptyDataView = DataView(EmptyBuffer)\n        private val Empty8 = Int8Array(0)\n        private val Empty16 = Int16Array(0)\n        private val Empty32 = Int32Array(0)\n        private val EmptyF32 = Float32Array(0)\n        private val EmptyF64 = Float64Array(0)\n\n        actual val Empty = IoBuffer(EmptyBuffer, null)\n        actual val Pool: ObjectPool<IoBuffer> = object: DefaultPool<IoBuffer>(BUFFER_VIEW_POOL_SIZE) {\n            override fun produceInstance(): IoBuffer {\n                return IoBuffer(ArrayBuffer(BUFFER_VIEW_SIZE), null)\n            }\n\n            override fun clearInstance(instance: IoBuffer): IoBuffer {\n                return super.clearInstance(instance).apply {\n                    instance.resetForWrite()\n                    instance.next = null\n                    instance.attachment = null\n\n                    if (instance.refCount != 0) throw IllegalStateException(\"Unable to clear instance: refCount is ${instance.refCount} != 0\")\n                    instance.refCount = 1\n                }\n            }\n\n            override fun validateInstance(instance: IoBuffer) {\n                super.validateInstance(instance)\n\n                require(instance.refCount == 0) { \"unable to recycle buffer: buffer view is in use (refCount = ${instance.refCount})\"}\n                require(instance.origin == null) { \"Unable to recycle buffer view: view copy shouldn't be recycled\" }\n            }\n\n            override fun disposeInstance(instance: IoBuffer) {\n                instance.unlink()\n            }\n        }\n\n        actual val NoPool: ObjectPool<IoBuffer> = object : NoPoolImpl<IoBuffer>() {\n            override fun borrow(): IoBuffer {\n                return IoBuffer(ArrayBuffer(4096), null)\n            }\n        }\n\n        actual val EmptyPool: ObjectPool<IoBuffer> = EmptyBufferPoolImpl\n    }\n}\n","package kotlinx.io.charsets\n\nimport kotlinx.io.core.*\nimport org.khronos.webgl.*\n\ninternal fun encodeISO88591(input: CharSequence, fromIndex: Int, toIndex: Int, dst: IoBuffer): Int {\n    if (fromIndex >= toIndex) return 0\n\n    dst.writeDirect { view ->\n        val i8 = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n        var writeIndex = 0\n        for (index in fromIndex until toIndex) {\n            val character = input[index].toInt()\n            if (character > 0xff) {\n                failedToMapError(character)\n            }\n            i8[writeIndex++] = character.toByte()\n        }\n        writeIndex\n    }\n    return toIndex - fromIndex\n}\n\nprivate fun failedToMapError(ch: Int): Nothing {\n    throw MalformedInputException(\"The character with unicode point $ch couldn't be mapped to ISO-8859-1 character\" )\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.khronos.webgl\n\nimport kotlin.js.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\npublic external interface WebGLContextAttributes {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var depth: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var stencil: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var antialias: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultipliedAlpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preserveDrawingBuffer: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preferLowPowerToHighPerformance: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var failIfMajorPerformanceCaveat: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextAttributes(alpha: Boolean? = true, depth: Boolean? = true, stencil: Boolean? = false, antialias: Boolean? = true, premultipliedAlpha: Boolean? = true, preserveDrawingBuffer: Boolean? = false, preferLowPowerToHighPerformance: Boolean? = false, failIfMajorPerformanceCaveat: Boolean? = false): WebGLContextAttributes {\n    val o = js(\"({})\")\n\n    o[\"alpha\"] = alpha\n    o[\"depth\"] = depth\n    o[\"stencil\"] = stencil\n    o[\"antialias\"] = antialias\n    o[\"premultipliedAlpha\"] = premultipliedAlpha\n    o[\"preserveDrawingBuffer\"] = preserveDrawingBuffer\n    o[\"preferLowPowerToHighPerformance\"] = preferLowPowerToHighPerformance\n    o[\"failIfMajorPerformanceCaveat\"] = failIfMajorPerformanceCaveat\n\n    return o\n}\n\npublic external abstract class WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLBuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLBuffer) to Kotlin\n */\npublic external abstract class WebGLBuffer : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLFramebuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLFramebuffer) to Kotlin\n */\npublic external abstract class WebGLFramebuffer : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLProgram](https://developer.mozilla.org/en/docs/Web/API/WebGLProgram) to Kotlin\n */\npublic external abstract class WebGLProgram : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderbuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderbuffer) to Kotlin\n */\npublic external abstract class WebGLRenderbuffer : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLShader](https://developer.mozilla.org/en/docs/Web/API/WebGLShader) to Kotlin\n */\npublic external abstract class WebGLShader : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLTexture](https://developer.mozilla.org/en/docs/Web/API/WebGLTexture) to Kotlin\n */\npublic external abstract class WebGLTexture : WebGLObject {\n}\n\n/**\n * Exposes the JavaScript [WebGLUniformLocation](https://developer.mozilla.org/en/docs/Web/API/WebGLUniformLocation) to Kotlin\n */\npublic external abstract class WebGLUniformLocation {\n}\n\n/**\n * Exposes the JavaScript [WebGLActiveInfo](https://developer.mozilla.org/en/docs/Web/API/WebGLActiveInfo) to Kotlin\n */\npublic external abstract class WebGLActiveInfo {\n    open val size: Int\n    open val type: Int\n    open val name: String\n}\n\n/**\n * Exposes the JavaScript [WebGLShaderPrecisionFormat](https://developer.mozilla.org/en/docs/Web/API/WebGLShaderPrecisionFormat) to Kotlin\n */\npublic external abstract class WebGLShaderPrecisionFormat {\n    open val rangeMin: Int\n    open val rangeMax: Int\n    open val precision: Int\n}\n\npublic external interface WebGLRenderingContextBase {\n    val canvas: HTMLCanvasElement\n    val drawingBufferWidth: Int\n    val drawingBufferHeight: Int\n    fun getContextAttributes(): WebGLContextAttributes?\n    fun isContextLost(): Boolean\n    fun getSupportedExtensions(): Array<String>?\n    fun getExtension(name: String): dynamic\n    fun activeTexture(texture: Int): Unit\n    fun attachShader(program: WebGLProgram?, shader: WebGLShader?): Unit\n    fun bindAttribLocation(program: WebGLProgram?, index: Int, name: String): Unit\n    fun bindBuffer(target: Int, buffer: WebGLBuffer?): Unit\n    fun bindFramebuffer(target: Int, framebuffer: WebGLFramebuffer?): Unit\n    fun bindRenderbuffer(target: Int, renderbuffer: WebGLRenderbuffer?): Unit\n    fun bindTexture(target: Int, texture: WebGLTexture?): Unit\n    fun blendColor(red: Float, green: Float, blue: Float, alpha: Float): Unit\n    fun blendEquation(mode: Int): Unit\n    fun blendEquationSeparate(modeRGB: Int, modeAlpha: Int): Unit\n    fun blendFunc(sfactor: Int, dfactor: Int): Unit\n    fun blendFuncSeparate(srcRGB: Int, dstRGB: Int, srcAlpha: Int, dstAlpha: Int): Unit\n    fun bufferData(target: Int, size: Int, usage: Int): Unit\n    fun bufferData(target: Int, data: BufferDataSource?, usage: Int): Unit\n    fun bufferSubData(target: Int, offset: Int, data: BufferDataSource?): Unit\n    fun checkFramebufferStatus(target: Int): Int\n    fun clear(mask: Int): Unit\n    fun clearColor(red: Float, green: Float, blue: Float, alpha: Float): Unit\n    fun clearDepth(depth: Float): Unit\n    fun clearStencil(s: Int): Unit\n    fun colorMask(red: Boolean, green: Boolean, blue: Boolean, alpha: Boolean): Unit\n    fun compileShader(shader: WebGLShader?): Unit\n    fun compressedTexImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, data: ArrayBufferView): Unit\n    fun compressedTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, data: ArrayBufferView): Unit\n    fun copyTexImage2D(target: Int, level: Int, internalformat: Int, x: Int, y: Int, width: Int, height: Int, border: Int): Unit\n    fun copyTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, x: Int, y: Int, width: Int, height: Int): Unit\n    fun createBuffer(): WebGLBuffer?\n    fun createFramebuffer(): WebGLFramebuffer?\n    fun createProgram(): WebGLProgram?\n    fun createRenderbuffer(): WebGLRenderbuffer?\n    fun createShader(type: Int): WebGLShader?\n    fun createTexture(): WebGLTexture?\n    fun cullFace(mode: Int): Unit\n    fun deleteBuffer(buffer: WebGLBuffer?): Unit\n    fun deleteFramebuffer(framebuffer: WebGLFramebuffer?): Unit\n    fun deleteProgram(program: WebGLProgram?): Unit\n    fun deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?): Unit\n    fun deleteShader(shader: WebGLShader?): Unit\n    fun deleteTexture(texture: WebGLTexture?): Unit\n    fun depthFunc(func: Int): Unit\n    fun depthMask(flag: Boolean): Unit\n    fun depthRange(zNear: Float, zFar: Float): Unit\n    fun detachShader(program: WebGLProgram?, shader: WebGLShader?): Unit\n    fun disable(cap: Int): Unit\n    fun disableVertexAttribArray(index: Int): Unit\n    fun drawArrays(mode: Int, first: Int, count: Int): Unit\n    fun drawElements(mode: Int, count: Int, type: Int, offset: Int): Unit\n    fun enable(cap: Int): Unit\n    fun enableVertexAttribArray(index: Int): Unit\n    fun finish(): Unit\n    fun flush(): Unit\n    fun framebufferRenderbuffer(target: Int, attachment: Int, renderbuffertarget: Int, renderbuffer: WebGLRenderbuffer?): Unit\n    fun framebufferTexture2D(target: Int, attachment: Int, textarget: Int, texture: WebGLTexture?, level: Int): Unit\n    fun frontFace(mode: Int): Unit\n    fun generateMipmap(target: Int): Unit\n    fun getActiveAttrib(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getActiveUniform(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getAttachedShaders(program: WebGLProgram?): Array<WebGLShader>?\n    fun getAttribLocation(program: WebGLProgram?, name: String): Int\n    fun getBufferParameter(target: Int, pname: Int): Any?\n    fun getParameter(pname: Int): Any?\n    fun getError(): Int\n    fun getFramebufferAttachmentParameter(target: Int, attachment: Int, pname: Int): Any?\n    fun getProgramParameter(program: WebGLProgram?, pname: Int): Any?\n    fun getProgramInfoLog(program: WebGLProgram?): String?\n    fun getRenderbufferParameter(target: Int, pname: Int): Any?\n    fun getShaderParameter(shader: WebGLShader?, pname: Int): Any?\n    fun getShaderPrecisionFormat(shadertype: Int, precisiontype: Int): WebGLShaderPrecisionFormat?\n    fun getShaderInfoLog(shader: WebGLShader?): String?\n    fun getShaderSource(shader: WebGLShader?): String?\n    fun getTexParameter(target: Int, pname: Int): Any?\n    fun getUniform(program: WebGLProgram?, location: WebGLUniformLocation?): Any?\n    fun getUniformLocation(program: WebGLProgram?, name: String): WebGLUniformLocation?\n    fun getVertexAttrib(index: Int, pname: Int): Any?\n    fun getVertexAttribOffset(index: Int, pname: Int): Int\n    fun hint(target: Int, mode: Int): Unit\n    fun isBuffer(buffer: WebGLBuffer?): Boolean\n    fun isEnabled(cap: Int): Boolean\n    fun isFramebuffer(framebuffer: WebGLFramebuffer?): Boolean\n    fun isProgram(program: WebGLProgram?): Boolean\n    fun isRenderbuffer(renderbuffer: WebGLRenderbuffer?): Boolean\n    fun isShader(shader: WebGLShader?): Boolean\n    fun isTexture(texture: WebGLTexture?): Boolean\n    fun lineWidth(width: Float): Unit\n    fun linkProgram(program: WebGLProgram?): Unit\n    fun pixelStorei(pname: Int, param: Int): Unit\n    fun polygonOffset(factor: Float, units: Float): Unit\n    fun readPixels(x: Int, y: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?): Unit\n    fun renderbufferStorage(target: Int, internalformat: Int, width: Int, height: Int): Unit\n    fun sampleCoverage(value: Float, invert: Boolean): Unit\n    fun scissor(x: Int, y: Int, width: Int, height: Int): Unit\n    fun shaderSource(shader: WebGLShader?, source: String): Unit\n    fun stencilFunc(func: Int, ref: Int, mask: Int): Unit\n    fun stencilFuncSeparate(face: Int, func: Int, ref: Int, mask: Int): Unit\n    fun stencilMask(mask: Int): Unit\n    fun stencilMaskSeparate(face: Int, mask: Int): Unit\n    fun stencilOp(fail: Int, zfail: Int, zpass: Int): Unit\n    fun stencilOpSeparate(face: Int, fail: Int, zfail: Int, zpass: Int): Unit\n    fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, pixels: ArrayBufferView?): Unit\n    fun texImage2D(target: Int, level: Int, internalformat: Int, format: Int, type: Int, source: TexImageSource?): Unit\n    fun texParameterf(target: Int, pname: Int, param: Float): Unit\n    fun texParameteri(target: Int, pname: Int, param: Int): Unit\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?): Unit\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, format: Int, type: Int, source: TexImageSource?): Unit\n    fun uniform1f(location: WebGLUniformLocation?, x: Float): Unit\n    fun uniform1fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform1fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform1i(location: WebGLUniformLocation?, x: Int): Unit\n    fun uniform1iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform1iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniform2f(location: WebGLUniformLocation?, x: Float, y: Float): Unit\n    fun uniform2fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform2fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform2i(location: WebGLUniformLocation?, x: Int, y: Int): Unit\n    fun uniform2iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform2iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniform3f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float): Unit\n    fun uniform3fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform3fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform3i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int): Unit\n    fun uniform3iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform3iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniform4f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float, w: Float): Unit\n    fun uniform4fv(location: WebGLUniformLocation?, v: Float32Array): Unit\n    fun uniform4fv(location: WebGLUniformLocation?, v: Array<Float>): Unit\n    fun uniform4i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int, w: Int): Unit\n    fun uniform4iv(location: WebGLUniformLocation?, v: Int32Array): Unit\n    fun uniform4iv(location: WebGLUniformLocation?, v: Array<Int>): Unit\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array): Unit\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>): Unit\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array): Unit\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>): Unit\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array): Unit\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>): Unit\n    fun useProgram(program: WebGLProgram?): Unit\n    fun validateProgram(program: WebGLProgram?): Unit\n    fun vertexAttrib1f(index: Int, x: Float): Unit\n    fun vertexAttrib1fv(index: Int, values: dynamic): Unit\n    fun vertexAttrib2f(index: Int, x: Float, y: Float): Unit\n    fun vertexAttrib2fv(index: Int, values: dynamic): Unit\n    fun vertexAttrib3f(index: Int, x: Float, y: Float, z: Float): Unit\n    fun vertexAttrib3fv(index: Int, values: dynamic): Unit\n    fun vertexAttrib4f(index: Int, x: Float, y: Float, z: Float, w: Float): Unit\n    fun vertexAttrib4fv(index: Int, values: dynamic): Unit\n    fun vertexAttribPointer(index: Int, size: Int, type: Int, normalized: Boolean, stride: Int, offset: Int): Unit\n    fun viewport(x: Int, y: Int, width: Int, height: Int): Unit\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderingContext](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext) to Kotlin\n */\npublic external abstract class WebGLRenderingContext : WebGLRenderingContextBase, RenderingContext {\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLContextEvent](https://developer.mozilla.org/en/docs/Web/API/WebGLContextEvent) to Kotlin\n */\npublic external open class WebGLContextEvent(type: String, eventInit: WebGLContextEventInit = definedExternally) : Event {\n    open val statusMessage: String\n}\n\npublic external interface WebGLContextEventInit : EventInit {\n    var statusMessage: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextEventInit(statusMessage: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): WebGLContextEventInit {\n    val o = js(\"({})\")\n\n    o[\"statusMessage\"] = statusMessage\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/**\n * Exposes the JavaScript [ArrayBuffer](https://developer.mozilla.org/en/docs/Web/API/ArrayBuffer) to Kotlin\n */\npublic external open class ArrayBuffer(length: Int) : BufferDataSource {\n    open val byteLength: Int\n    fun slice(begin: Int, end: Int = definedExternally): ArrayBuffer\n\n    companion object {\n        fun isView(value: Any?): Boolean\n    }\n}\n\n/**\n * Exposes the JavaScript [ArrayBufferView](https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView) to Kotlin\n */\npublic external interface ArrayBufferView : BufferDataSource {\n    val buffer: ArrayBuffer\n    val byteOffset: Int\n    val byteLength: Int\n}\n\n/**\n * Exposes the JavaScript [Int8Array](https://developer.mozilla.org/en/docs/Web/API/Int8Array) to Kotlin\n */\npublic external open class Int8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int8Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Byte>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Int8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Int8Array.get(index: Int): Byte = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Int8Array.set(index: Int, value: Byte): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint8Array](https://developer.mozilla.org/en/docs/Web/API/Uint8Array) to Kotlin\n */\npublic external open class Uint8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Byte>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint8Array.get(index: Int): Byte = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint8Array.set(index: Int, value: Byte): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint8ClampedArray](https://developer.mozilla.org/en/docs/Web/API/Uint8ClampedArray) to Kotlin\n */\npublic external open class Uint8ClampedArray : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8ClampedArray)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8ClampedArray, offset: Int = definedExternally): Unit\n    fun set(array: Array<Byte>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint8ClampedArray\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint8ClampedArray.get(index: Int): Byte = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint8ClampedArray.set(index: Int, value: Byte): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Int16Array](https://developer.mozilla.org/en/docs/Web/API/Int16Array) to Kotlin\n */\npublic external open class Int16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int16Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Short>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Int16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Int16Array.get(index: Int): Short = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Int16Array.set(index: Int, value: Short): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint16Array](https://developer.mozilla.org/en/docs/Web/API/Uint16Array) to Kotlin\n */\npublic external open class Uint16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint16Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Short>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint16Array.get(index: Int): Short = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint16Array.set(index: Int, value: Short): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Int32Array](https://developer.mozilla.org/en/docs/Web/API/Int32Array) to Kotlin\n */\npublic external open class Int32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int32Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Int>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Int32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Int32Array.get(index: Int): Int = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Int32Array.set(index: Int, value: Int): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Uint32Array](https://developer.mozilla.org/en/docs/Web/API/Uint32Array) to Kotlin\n */\npublic external open class Uint32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint32Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Int>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Uint32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Uint32Array.get(index: Int): Int = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Uint32Array.set(index: Int, value: Int): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Float32Array](https://developer.mozilla.org/en/docs/Web/API/Float32Array) to Kotlin\n */\npublic external open class Float32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float32Array)\n    constructor(array: Array<Float>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float32Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Float>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Float32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Float32Array.get(index: Int): Float = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Float32Array.set(index: Int, value: Float): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [Float64Array](https://developer.mozilla.org/en/docs/Web/API/Float64Array) to Kotlin\n */\npublic external open class Float64Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float64Array)\n    constructor(array: Array<Double>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float64Array, offset: Int = definedExternally): Unit\n    fun set(array: Array<Double>, offset: Int = definedExternally): Unit\n    fun subarray(start: Int, end: Int): Float64Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n@kotlin.internal.InlineOnly inline operator fun Float64Array.get(index: Int): Double = asDynamic()[index]\n@kotlin.internal.InlineOnly inline operator fun Float64Array.set(index: Int, value: Double): Unit { asDynamic()[index] = value; }\n\n/**\n * Exposes the JavaScript [DataView](https://developer.mozilla.org/en/docs/Web/API/DataView) to Kotlin\n */\npublic external open class DataView(buffer: ArrayBuffer, byteOffset: Int = definedExternally, byteLength: Int = definedExternally) : ArrayBufferView {\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun getInt8(byteOffset: Int): Byte\n    fun getUint8(byteOffset: Int): Byte\n    fun getInt16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getUint16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getInt32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getUint32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getFloat32(byteOffset: Int, littleEndian: Boolean = definedExternally): Float\n    fun getFloat64(byteOffset: Int, littleEndian: Boolean = definedExternally): Double\n    fun setInt8(byteOffset: Int, value: Byte): Unit\n    fun setUint8(byteOffset: Int, value: Byte): Unit\n    fun setInt16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally): Unit\n    fun setUint16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally): Unit\n    fun setInt32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally): Unit\n    fun setUint32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally): Unit\n    fun setFloat32(byteOffset: Int, value: Float, littleEndian: Boolean = definedExternally): Unit\n    fun setFloat64(byteOffset: Int, value: Double, littleEndian: Boolean = definedExternally): Unit\n}\n\npublic external @marker interface BufferDataSource {\n}\n\npublic external @marker interface TexImageSource {\n}\n\n","package kotlinx.io.core\n\nimport org.khronos.webgl.*\n\nactual enum class ByteOrder {\n    BIG_ENDIAN, LITTLE_ENDIAN;\n\n    actual companion object {\n        private val native: ByteOrder\n\n        init {\n            val buffer = ArrayBuffer(4)\n            val arr = Int32Array(buffer)\n            val view = DataView(buffer)\n\n            arr[0] = 0x11223344\n\n            native = if (view.getInt32(0, true) == 0x11223344) LITTLE_ENDIAN else BIG_ENDIAN\n        }\n\n        actual fun nativeOrder(): ByteOrder = native\n    }\n}\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport kotlinx.io.pool.*\nimport org.khronos.webgl.*\n\n@DangerousInternalIoApi\nactual abstract class ByteReadPacketPlatformBase\nprotected actual constructor(head: IoBuffer, remaining: Long, pool: ObjectPool<IoBuffer>) : ByteReadPacketBase(head, remaining, pool), Input {\n\n    override fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        if (remaining < length) throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n        var copied = 0\n\n        takeWhile { buffer: IoBuffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc > 0) copied += rc\n            copied < length\n        }\n    }\n\n    override fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        if (remaining < length) throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n        var copied = 0\n\n        takeWhile { buffer: IoBuffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc > 0) copied += rc\n            copied < length\n        }\n    }\n\n    override fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        if (remaining < length) throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n        var copied = 0\n\n        takeWhile { buffer: IoBuffer ->\n            val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n            if (rc > 0) copied += rc\n            copied < length\n        }\n    }\n\n    override fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) return -1\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    override fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) return -1\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n    override fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        val remaining = remaining\n        if (remaining == 0L) return -1\n        val size = minOf(remaining, length.toLong()).toInt()\n        readFully(dst, offset, size)\n        return size\n    }\n\n}\n\nactual class ByteReadPacket\n    internal actual constructor(head: IoBuffer, remaining: Long, pool: ObjectPool<IoBuffer>) : ByteReadPacketPlatformBase(head, remaining, pool), Input {\n    actual constructor(head: IoBuffer, pool: ObjectPool<IoBuffer>) : this(head, head.remainingAll(), pool)\n\n    init {\n        markNoMoreChunksAvailable()\n    }\n\n    final override fun fill() = null\n\n    override fun closeSource() {\n    }\n\n    actual companion object {\n        actual val Empty: ByteReadPacket\n            get() = ByteReadPacket(IoBuffer.Empty, object : NoPoolImpl<IoBuffer>() {\n                override fun borrow() = IoBuffer.Empty\n            })\n\n        @Deprecated(\"This implementation detail is going to become internal.\")\n        actual inline val ReservedSize get() = IoBuffer.ReservedSize\n    }\n}\n\nactual fun ByteReadPacket(array: ByteArray, offset: Int, length: Int, block: (ByteArray) -> Unit): ByteReadPacket {\n    val content = array.asDynamic() as Int8Array\n    val sub = when {\n        offset == 0 && length == array.size -> content.buffer\n        else -> content.buffer.slice(offset, offset + length)\n    }\n\n    val pool = object : SingleInstancePool<IoBuffer>() {\n        override fun produceInstance(): IoBuffer {\n            return IoBuffer(sub, null)\n        }\n\n        override fun disposeInstance(instance: IoBuffer) {\n            block(array)\n        }\n    }\n\n    return ByteReadPacket(pool.borrow().apply { resetForRead() }, pool)\n}\n","package kotlinx.io.core\n\nimport kotlinx.io.core.internal.*\nimport org.khronos.webgl.*\n\n/**\n * Shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\nactual interface Input : Closeable {\n    @Deprecated(\n        \"Implementing this interface is highly experimental. Extend AbstractInput instead.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    @Suppress(\"unused\")\n    actual val doNotImplementInputButExtendAbstractInputInstead: Nothing\n\n    @Deprecated(\"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\")\n    actual var byteOrder: ByteOrder\n    actual val endOfInput: Boolean\n\n    actual fun readByte(): Byte\n    actual fun readShort(): Short\n    actual fun readInt(): Int\n    actual fun readLong(): Long\n    actual fun readFloat(): Float\n    actual fun readDouble(): Double\n\n    actual fun readFully(dst: ByteArray, offset: Int, length: Int)\n    actual fun readFully(dst: ShortArray, offset: Int, length: Int)\n    actual fun readFully(dst: IntArray, offset: Int, length: Int)\n    actual fun readFully(dst: LongArray, offset: Int, length: Int)\n    actual fun readFully(dst: FloatArray, offset: Int, length: Int)\n    actual fun readFully(dst: DoubleArray, offset: Int, length: Int)\n    actual fun readFully(dst: IoBuffer, length: Int)\n\n    fun readFully(dst: Int8Array, offset: Int, length: Int)\n    fun readFully(dst: ArrayBuffer, offset: Int, length: Int)\n    fun readFully(dst: ArrayBufferView, offset: Int, length: Int)\n\n    actual fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: IntArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: LongArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int\n    actual fun readAvailable(dst: IoBuffer, length: Int): Int\n\n    fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int\n    fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int\n    fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    actual fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * If the underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    actual fun peekTo(buffer: IoBuffer): Int\n\n    @Deprecated(\"Use discardExact instead.\")\n    actual fun discard(n: Long): Long\n\n    actual override fun close()\n}\n","package kotlinx.io.core\n\nimport org.khronos.webgl.*\n\ninternal actual fun IoBuffer.discardUntilDelimiterImpl(delimiter: Byte): Int {\n    val content = Int8Array(content)\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        if (content[idx] == delimiter) break\n        idx++\n    }\n\n    val start = readPosition\n    readPosition = idx\n    return idx - start\n}\n\ninternal actual fun IoBuffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int {\n    val content = Int8Array(content)\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        val v = content[idx]\n        if (v == delimiter1 || v == delimiter2) break\n        idx++\n    }\n\n    val start = readPosition\n    readPosition = idx\n    return idx - start\n}\n\n\ninternal actual fun IoBuffer.readUntilDelimiterImpl(delimiter: Byte,\n                                                    dst: ByteArray, offset: Int, length: Int): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n\n    return readUntilImpl({ it == delimiter }, dst, offset, length)\n}\n\ninternal actual fun IoBuffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte,\n                                                     dst: ByteArray, offset: Int, length: Int): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst, offset, length)\n}\n\ninternal actual fun IoBuffer.readUntilDelimiterImpl(delimiter: Byte, dst: Output): Int {\n    return readUntilImpl({ it == delimiter }, dst)\n}\n\ninternal actual fun IoBuffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte, dst: Output): Int {\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst)\n}\n\nprivate inline fun IoBuffer.readUntilImpl(predicate: (Byte) -> Boolean,\n                                          dst: ByteArray, offset: Int, length: Int): Int {\n\n    val array = Int8Array(content)\n    val start = readPosition\n    var i = start\n    val end = i + minOf(length, readRemaining)\n\n    while (i < end) {\n        if (predicate(array[i])) break\n        i++\n    }\n\n    val copied = i - start\n    val dstArray = dst.asDynamic() as Int8Array\n    dstArray.set(array.subarray(start, end), offset)\n    readPosition = i\n\n    return copied\n}\n\nprivate inline fun IoBuffer.readUntilImpl(predicate: (Byte) -> Boolean,\n                                          dst: Output): Int {\n    val array = Int8Array(content)\n    var i = readPosition\n    var copiedTotal = 0\n\n    dst.writeWhile { chunk ->\n        chunk.writeFully(chunk, 0)\n        val start = i\n        val end = minOf(i + chunk.writeRemaining, writePosition)\n\n        while (i < end) {\n            if (predicate(array[i])) break\n            i++\n        }\n\n        val size = i - start\n\n        Int8Array(chunk.content).set(array.subarray(start, i), chunk.writePosition)\n        chunk.writePosition += size\n        copiedTotal += size\n\n        chunk.writeRemaining == 0 && i < end\n    }\n\n    readPosition = i\n    return copiedTotal\n}","package kotlinx.io.core\n\nimport kotlinx.io.charsets.*\nimport org.khronos.webgl.*\n\nactual fun String(bytes: ByteArray, offset: Int, length: Int, charset: Charset): String {\n    if (offset < 0 || length < 0 || offset + length > bytes.size) {\n        checkIndices(offset, length, bytes)\n    }\n\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val i8: Int8Array = bytes.asDynamic() // we know that K/JS generates Int8Array for ByteBuffer\n    val bufferOffset = i8.byteOffset + offset\n    val buffer = i8.buffer.slice(bufferOffset, bufferOffset + length)\n\n    val view = IoBuffer(buffer, null)\n    view.resetForRead()\n    val packet = ByteReadPacket(view, IoBuffer.NoPool)\n\n    return charset.newDecoder().decode(packet, Int.MAX_VALUE)\n}\n\nfun checkIndices(offset: Int, length: Int, bytes: ByteArray): Nothing {\n    require(offset >= 0) { throw IndexOutOfBoundsException(\"offset ($offset) shouldn't be negative\") }\n    require(length >= 0) { throw IndexOutOfBoundsException(\"length ($length) shouldn't be negative\") }\n    require(offset + length <= bytes.size) {\n        throw IndexOutOfBoundsException(\"offset ($offset) + length ($length) > bytes.size (${bytes.size})\")\n    }\n\n    throw IndexOutOfBoundsException()\n}\n\ninternal actual fun String.getCharsInternal(dst: CharArray, dstOffset: Int) {\n    val length = length\n    require(dstOffset + length <= dst.size)\n\n    var dstIndex = dstOffset\n    for (srcIndex in 0 until length) {\n        dst[dstIndex++] = this[srcIndex]\n    }\n}\n","package kotlinx.io.errors\n\nactual open class IOException actual constructor(message: String, cause: Throwable?) : Exception(message, cause) {\n    actual constructor(message: String) : this(message, null)\n}\n\nactual open class EOFException actual constructor(message: String) : IOException(message)\n","package kotlinx.io.js\n\nimport org.khronos.webgl.*\n\ninternal external class TextEncoder() {\n    val encoding: String\n\n    fun encode(input: String): Uint8Array\n}\n\ninternal fun TextEncoderCtor(): TextEncoder {\n    // PhantomJS does not support TextEncoder yet so we use node module text-encoding for tests\n    if (js(\"typeof TextEncoder\") == \"undefined\") {\n        val module = js(\"require('text-encoding')\")\n        if (module.TextEncoder === undefined) throw IllegalStateException(\"TextEncoder is not supported by your browser and no text-encoding module found\")\n        val ctor = module.TextEncoder\n        val objPrototype = js(\"Object\").create(ctor.prototype)\n\n        @Suppress(\"UnsafeCastFromDynamic\")\n        return ctor.call(objPrototype)\n    }\n\n    return TextEncoder()\n}\n","package kotlinx.io.js\n\nimport kotlinx.io.core.*\nimport org.khronos.webgl.*\n\n/**\n * Read exactly [n] bytes to a new array buffer instance\n */\nfun ByteReadPacket.readArrayBuffer(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to make a new ArrayBuffer: packet is too big\")\n): ArrayBuffer {\n    val buffer = ArrayBuffer(n)\n    readFully(buffer, 0, n)\n    return buffer\n}\n\n/**\n * Write exactly [length] bytes from the specified [src] array buffer\n */\nfun BytePacketBuilder.writeFully(src: ArrayBuffer, offset: Int = 0, length: Int = src.byteLength - offset) {\n    writeFully(Int8Array(src), offset, length)\n}\n\n/**\n * Write exactly [length] bytes from the specified [src] typed array\n */\nfun BytePacketBuilder.writeFully(src: Int8Array, offset: Int = 0, length: Int = src.length - offset) {\n    var written = 0\n    var rem = length\n\n    while (rem > 0) {\n        write(1) { bb: IoBuffer ->\n            val size = minOf(bb.writeRemaining, rem)\n            bb.write(src, written + offset, size)\n            written += size\n            rem -= size\n            size\n        }\n    }\n}\n","package kotlinx.io.js\n\nimport kotlinx.io.core.*\nimport org.khronos.webgl.*\nimport org.w3c.dom.*\n\nfun WebSocket.sendPacket(packet: ByteReadPacket) {\n    send(packet.readArrayBuffer())\n}\n\ninline fun WebSocket.sendPacket(block: BytePacketBuilder.() -> Unit) {\n    sendPacket(buildPacket(block = block))\n}\n\ninline fun MessageEvent.packet(): ByteReadPacket {\n    @Suppress(\"NON_PUBLIC_CALL_FROM_PUBLIC_INLINE\", \"UnsafeCastFromDynamic\")\n    return ByteReadPacket(IoBuffer(data.asDynamic(), null), IoBuffer.NoPool)\n}\n\n\n\n\n","package kotlinx.io.js\n\nimport kotlinx.io.core.*\nimport org.w3c.xhr.*\n\ninline fun XMLHttpRequest.sendPacket(block: BytePacketBuilder.() -> Unit) {\n    sendPacket(buildPacket(block = block))\n}\n\nfun XMLHttpRequest.sendPacket(packet: ByteReadPacket) {\n    send(packet.readArrayBuffer())\n}\n\n@Suppress(\"UnsafeCastFromDynamic\")\nfun XMLHttpRequest.responsePacket(): ByteReadPacket = when (responseType) {\n    XMLHttpRequestResponseType.ARRAYBUFFER -> ByteReadPacket(IoBuffer(response.asDynamic(), null), IoBuffer.NoPool)\n    XMLHttpRequestResponseType.EMPTY -> ByteReadPacket.Empty\n    else -> throw IllegalStateException(\"Incompatible type ${responseType}: only ARRAYBUFFER and EMPTY are supported\")\n}\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See libraries/tools/idl2k for details\n\n@file:Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npackage org.w3c.xhr\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\n\n/**\n * Exposes the JavaScript [XMLHttpRequestEventTarget](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequestEventTarget) to Kotlin\n */\npublic external abstract class XMLHttpRequestEventTarget : EventTarget {\n    open var onloadstart: ((ProgressEvent) -> dynamic)?\n    open var onprogress: ((ProgressEvent) -> dynamic)?\n    open var onabort: ((Event) -> dynamic)?\n    open var onerror: ((Event) -> dynamic)?\n    open var onload: ((Event) -> dynamic)?\n    open var ontimeout: ((Event) -> dynamic)?\n    open var onloadend: ((Event) -> dynamic)?\n}\n\npublic external abstract class XMLHttpRequestUpload : XMLHttpRequestEventTarget {\n}\n\n/**\n * Exposes the JavaScript [XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest) to Kotlin\n */\npublic external open class XMLHttpRequest : XMLHttpRequestEventTarget {\n    var onreadystatechange: ((Event) -> dynamic)?\n    open val readyState: Short\n    var timeout: Int\n    var withCredentials: Boolean\n    open val upload: XMLHttpRequestUpload\n    open val responseURL: String\n    open val status: Short\n    open val statusText: String\n    var responseType: XMLHttpRequestResponseType\n    open val response: Any?\n    open val responseText: String\n    open val responseXML: Document?\n    fun open(method: String, url: String): Unit\n    fun open(method: String, url: String, async: Boolean, username: String? = definedExternally, password: String? = definedExternally): Unit\n    fun setRequestHeader(name: String, value: String): Unit\n    fun send(body: dynamic = definedExternally): Unit\n    fun abort(): Unit\n    fun getResponseHeader(name: String): String?\n    fun getAllResponseHeaders(): String\n    fun overrideMimeType(mime: String): Unit\n\n    companion object {\n        val UNSENT: Short\n        val OPENED: Short\n        val HEADERS_RECEIVED: Short\n        val LOADING: Short\n        val DONE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [FormData](https://developer.mozilla.org/en/docs/Web/API/FormData) to Kotlin\n */\npublic external open class FormData(form: HTMLFormElement = definedExternally) {\n    fun append(name: String, value: String): Unit\n    fun append(name: String, value: Blob, filename: String = definedExternally): Unit\n    fun delete(name: String): Unit\n    fun get(name: String): dynamic\n    fun getAll(name: String): Array<dynamic>\n    fun has(name: String): Boolean\n    fun set(name: String, value: String): Unit\n    fun set(name: String, value: Blob, filename: String = definedExternally): Unit\n}\n\n/**\n * Exposes the JavaScript [ProgressEvent](https://developer.mozilla.org/en/docs/Web/API/ProgressEvent) to Kotlin\n */\npublic external open class ProgressEvent(type: String, eventInitDict: ProgressEventInit = definedExternally) : Event {\n    open val lengthComputable: Boolean\n    open val loaded: Int\n    open val total: Int\n}\n\npublic external interface ProgressEventInit : EventInit {\n    var lengthComputable: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var loaded: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var total: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ProgressEventInit(lengthComputable: Boolean? = false, loaded: Int? = 0, total: Int? = 0, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): ProgressEventInit {\n    val o = js(\"({})\")\n\n    o[\"lengthComputable\"] = lengthComputable\n    o[\"loaded\"] = loaded\n    o[\"total\"] = total\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n\n    return o\n}\n\n/* please, don't implement this interface! */\npublic external interface XMLHttpRequestResponseType {\n    companion object\n}\npublic inline val XMLHttpRequestResponseType.Companion.EMPTY: XMLHttpRequestResponseType get() = \"\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.ARRAYBUFFER: XMLHttpRequestResponseType get() = \"arraybuffer\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.BLOB: XMLHttpRequestResponseType get() = \"blob\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.DOCUMENT: XMLHttpRequestResponseType get() = \"document\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.JSON: XMLHttpRequestResponseType get() = \"json\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\npublic inline val XMLHttpRequestResponseType.Companion.TEXT: XMLHttpRequestResponseType get() = \"text\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\n","package kotlinx.io.pool\n\nactual abstract class DefaultPool<T : Any> actual constructor(actual final override val capacity: Int) : ObjectPool<T> {\n    private val instances = arrayOfNulls<Any?>(capacity)\n    private var size = 0\n\n    protected actual abstract fun produceInstance(): T\n    protected actual open fun disposeInstance(instance: T) {}\n\n    protected actual open fun clearInstance(instance: T): T = instance\n    protected actual open fun validateInstance(instance: T) {}\n\n    actual final override fun borrow(): T {\n        if (size == 0) return produceInstance()\n        val idx = --size\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val instance = instances[idx] as T\n        instances[idx] = null\n\n        return clearInstance(instance)\n    }\n\n    actual final override fun recycle(instance: T) {\n        validateInstance(instance)\n        if (size == capacity) {\n            disposeInstance(instance)\n        } else {\n            instances[size++] = instance\n        }\n    }\n\n    actual final override fun dispose() {\n        for (i in 0 until size) {\n            @Suppress(\"UNCHECKED_CAST\")\n            val instance = instances[i] as T\n            instances[i] = null\n            disposeInstance(instance)\n        }\n        size = 0\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;oBA2QA,oB;kBCqBA,kB;mBCeA,mB;YCtKY,uB;;2BCvHZ,6C;mCCmEA,gD;;WC+NiD,gB;;;;;;;;;;;;;;;;;eClIjD,I;;iCCjCmB,qB;;;;;;oBC0T0B,+B;;;;;;;;6BLjc7C,qC;;;;;oBM0BkG,sB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IPmBnD,yB;MAAA,YAAiB,C;IAAG,uB;MAAA,UAAe,KAAM,O;IAAU,sB;IQ5C9F,cAAc,oBAD2B,CAC3B,C;;MR6Cd,wBQ3CU,OR2CV,4B;MQ1CI,qBAAO,OAAQ,Q;;;;QACjB,iB;cACE,C;;;;;WAJJ,kB;;;;MRgDmD,gB;;;IAef,iF;IAAW,4C;IAAqC,OAAA,WAAU,W;;;IAC9F,yB;MADwE,SSAjE,I;;;ITiCP,qB;QAAA,gB;MACA,qB;QAAA,SAAe,8BAAf,gB;;MAGA,8B;MAAsB,SAAO,oD;MAC7B,QAAA,KAAa,S;;QAGT,2BAAA,MAAS,cAAT,C;QACA,SAAS,gB;QACT,a;;UAEI,cAAa,iBAAb,CAA8B,CAA9B,EAA8B,8BAA9B,Q;MACO,oBAAU,mB;MACV,uD;;;;MAIX,sBAAa,uC;;;;;MAIb,OAAO,mB;;;;MAKX,OAAA,iBAD4C,CAC5C,CAD4C,CAC5C,a;;;aACA,G;;;QAFsC,OI3E3B,M;;;;MJmFX,Y;QACA,e;QUxCA,aAAqB,mB;;UAEjB,U;;;UVyCA,SAAA,IAAa,EAAK,Q;;;;;QAId,qC;;;;MAGJ,yB;;WU9CI,YAAO,E;;;;;MViDf,OAAO,C;;IAUP,iD;;MACsB,Q;MAEtB,Y;QU/CA,WAAW,I;;QAGP,gC;QACA,6D;QACW,YAAM,CAAN,E;UAAA,6B;UV6CX,oD;;QE7EJ,KAAI,EF+EM,mB;QE9EN,iBAdW,cAcX,qC;YACA,KAAM,a;;;cF8EN,a;UACA,gB;;;UAJA,eAOwB,C;;eACpB,Y;YARJ,S;;;;;;MU7CI,iC;;;WAEA,YAAO,E;;;IVwDf,mC;IACA,UAAO,W;EACX,C;;WG+EgC,sC;;0CAEhC,W,cAAsC,qB;;;;;;;;;;;IAAtC,yB;IAAA,qB;;IAAA,sB;EAAA,C;;IAKI,IAAI,I;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AAA,MAAS,KAAT,C;;MAGU,QAhTA,E;;IAClB,kD;;MA0SI,Y;;QAEI,WAAS,C;;QAGC,QA5SA,IA4Sd,MA5Sc,C;IAClB,2B;;MAwSQ,MAAA,SAAS,MAAT,E;;MAGU,IAxSA,W;MAwSd,sB;;;QApSqB,Y;UAAE,+B;;;;QACkB,gB;QAAE,mB;;;;QG5b3C,SH2bQ,EAAU,GG3btB,SH2bsB,Y;QG1blB,wB;QAKE,O;;QANF,IH4bQ,gB;QG3bR,kC;;MAKE,yB;;;IHwbE,c;;;IAGJ,mB;;K;;;;aAqSA,UAAU,GAAO,c;;;EAIA,kD;UACT,UAAM,C;;MAGG,U;;WA1SH,MAA4B,a;UAAtC,UJ/QD,qBI+QC,gE;MACA,Y;;gBAEA,W;oBAwSA,W;;;;MAIJ,e;;;;;UAtSqB,+B;UAAE,2B;;;;QACkB,mB;QAAE,UAAA,UAAU,M;;;;QG9crD,IH6cQ,SG7cR,GH6cQ,Q;QG5cR,8B;QAKE,sB;;QANF,gBH8ciB,GAAT,SAAsB,M;;MG7c9B,yB;MAKA,IAAE,gB;;;;;;aH6tBF,gC;;;;;;;;EAQqB,kD;;UAGJ,gF;MA1RH,U;;UJ/RN,CI+RJ,SJ/RD,MAAK,QAAO,eAAP,K;UIgSJ,UAAO,qBAAP,CAAO,yCAAP,sB;MACA,Y;;gBAwRA,W;oBAEA,W;;;QAGJ,+B;;;;;QAtRqB,Y;UAAE,+B;;;;QACkB,gB;QAAE,mB;;;;QG9d3C,SH6dQ,EAAU,GG7dtB,SH6dsB,Y;QG5dlB,wB;QAKE,O;;QANF,IH8dQ,gB;QG7dR,kC;;MAKE,yB;;;IH0dF,c;;;;aAmQkB,gC;;;;;aAMd,U;;;;UAKa,W;UA1QH,QA0QiB,qBA1QjB,mD;MAAA,U;;UACH,CAAP,MAAO,iBAAA,eAAgB,CAAhB,GAAgB,C;UACvB,+F;MACA,Y;;gBAwQA,W;oBAEK,W;;MAET,uB;;;;;;QAtQuB,Y;;;;QACkB,qB;QAAE,gB;;;;QG9e3C,KH6eQ,sB;QG5eR,cAAA,iBH4eqB,I;QGvenB,wB;;QANF,GH8eQ,SAAS,MAAT,I;QG7eR,oB;QAKA,gB;;;MH0eA,6B;;IACA,c;;;;aAmPA,gC;;;;;aAMiB,4C;;;EAIM,+B;UA1PT,UA0PiB,C;UA1PjB,QAA4B,qBAA5B,mD;MAAV,U;;UAES,CAAT,mBAAS,IAAT,eAAS,K;UACT,+F;MAuPA,Y;;gBAEA,W;oBA7PW,W;;;;;;MAUM,+B;;;;;;QACsB,qB;;;;QG9f3C,QH6fQ,mB;QG5fR,2B;QAKE,S;;QANF,OH8fQ,GAAA,gBAAsB,I;QG7f9B,sB;QAKA,IAAE,gB;;;MH0fF,yB;MACA,oBAAgB,S;;;;;;aAoOhB,gC;;;;;;;;EAjOuC,+B;UAAzB,UAA4B,C;UAAtC,gF;MACA,U;;UAEA,2B;UAuOA,mF;MACA,Y;;YAEK,iB;oBA9OM,qB;;;QAgPf,qB;;;;;;UAtOuB,yB;MAAF,iB;;;MACgB,gC;UAAE,e;;;;;IG9gB3C,+B;;;;aAAI,kD;;;;QHghBgB,EAAA,iBAAU,IAAV,M;MAAhB,kCAAyC,iCAAzC,I;MACA,QAAI,E;;QACJ,UAEA,CAFA,C;;;;MAQe,cAAW,C;MAAX,aAA2B,IAA3B,K;MAAX,YJrWD,MAAK,e;;QIuWJ,c;UAEI,+B;UAAgB,K;;;QAEf,kC;QAET,sD;;;QAIiB,iB;QAAE,8B;;;;;MAAX,yB;MGriBR,6B;;IAKE,c;;;;QH6tBF,MA1Le,mB;MA0LG,+B;;QAElB,W;QACA,S;;QAGI,MAAI,SAAJ,G;MACa,+B;MACI,gC;;;MAGE,gD;MApMa,4BAAA,GAoML,cApMK,E;MJ5W7B,0C;MI6Wc,gC;;;MAEjB,+C;MAkMA,qBAAA,MAAW,CAAA,GAAX,SAAW,CAAX,C;MACA,gC;;IAvMW,kD;;;EA0Mf,+BAAQ,e;;;;;;;WAxBJ,I;;;QAII,OAAM,I;MAzKP,OAAA,IAAc,eAAd,oB;;IA0HP,0B;WACI,I;;;;WAIA,I;MACA,wB;UACA,Y;QAR0C,K;;;MAY1C,yB;;;;QAoCJ,I;QAvKA,kB;;MAIA,IAAI,+B;UACA,iBAAA,SAAY,E;;;QAEZ,iB;;;;;;QAMJ,IAAI,M;QACA,WAAO,M;yBAGX,kB;QAEA,iB;;;UAKmB,M;UADnB,kB;;;UACiB,a;;;QAAb,cAAa,IAAb,C;UACA,uB;;;;YAcW,e;;UAJf,IAAO,WAAP,C;YACI,oBAAsB,Q;;;;;;;EAGlB,+B;;;WFzVR,WAAW,gB;UACX,gBAAA,MAAkB,aAAlB,iB;UACa,aAAI,gB;QACQ,cAAA,SAArB,0B;QAAqC,wB;YAAT,Y;gBAAP,4C;;;;;;YADzB,a;YAMA,SAAI,uB;YAEA,Y;cACA,YAAY,qBAAZ,S;cACA,M;UACI,yCAAiB,SAAjB,2C;;;;UAGA,a;;;YE8UA,M;;;;;YAeO,e;;UAJf,IAAO,WAAP,C;YACI,oBAAoC,Q;;;;;;;EAGhC,+B;;;;EF7WG,+B;cACX,K;QACa,OAAI,G;aACQ,G;eAAgB,S;QAAT,e;YAAP,wB;;;YAErB,oB;;IAHJ,e;WAMA,G;;EAEgB,+BAAO,sB;cACnB,K;QACA,U;;;QAGA,aAAI,E;YACA,wBAAW,e;;;MEkWX,+D;;;IAGZ,U;;EAGI,+BAAY,wB;IACZ,mB;;;IAIA,mB;;;QAEA,UAAW,Q;MACX,SAAS,kB;aACL,C;;;MAGJ,SAAO,kB;MACG,4BAAA,MAAkB,mBAAlB,C;;MAGV,Q;;;;;MAKA,Q;;;EAEW,+B;QACX,IAAI,KAAK,e;aACL,IAAM,K;;;EAIA,8CAAkB,e;;G;;;;QAQ5B,kB;IACJ,iC;;;IAIA,I;;EAQY,+B;QACJ,Y;;;iBAGJ,IAAI,K;QACA,2B;;UAEA,U;QAR0C,MAS1C,yB;;;UAGA,2B;MACA,8B;MAb0C,sB;;;IAAA,I;;EAyBrC,+BAAL,gB;QAA0B,OAAO,U;QACrC,IAAO,O;;;;EAMX,qB;;IAOA,K;;IAII,iBAAa,O;WACT,K;;4CAIJ,U;;IIztBJ,IAAI,iBAAJ,C;MAEI,MAAO,I;;MAGX,gC;;;;;IP8FqC,0B;MAAA,kH;;;;;;EQmBxB,oCAAA,aAAc,CAAd,qBAAc,W;;;IACT,oBA8C+B,kB;;;EA7C7B,iCAAS,OAAT,e;UAChB,8BAAA,IAAsB,gBAAtB,G;G;sEAIG,uB;;;MAG0C,U;QAAA,c;MAAiB,O;QAAA,QAAc,KAAI,C;MACpF,gB;IACI,0C;IAAA,uC;MAAc,OAmC+B,sBAnC/B,WAmC+B,EAnC/B,MAmC+B,EAnC/B,GAmC+B,EAnC/B,GAmC+B,C;;IAnCjD,iD;MACI,0BAAyB,CAAA,MAAS,GAAlB,GAAS,K;MACzB,OAAA,4BAAsB,cAAtB,MAAsB,W;;;;;;;MAOwB,Q;QAAA,8B;IAAiB,kC;QAAA,OAAc,MAAI,IAAJ,IAAW,CAAX,EAAW,GAAX,C;IACjF,8BAAa,Q;IACT,4B;IAAA,S;WAAc,I;;;;aAEd,gCAAsB,iB;;;;IAI1B,mB;MACJ,wD;K;;;;;;;;;aAUW,kD;;;;QAEY,c;MAFnB,+D;;;IAOiD,gB;;MF7KrD,Y;;;MAGgB,qE;MAAS,Y;;IAHzB,yC;MAKgB,IAAM,kCAAyB,oBAAzB,mB;;;EALtB,C;;QAGQ,iB;MAKA,MAAE,oB;;;EGwFA,oCAAA,MAAuB,wC;;;IAuCjB,sC;IAPJ,0B;;;;;EJHA,kC,kCACe,uB;;;;;IAInB,gB;;;;IInCE,4C;;;;EAMF,qB;UAC+B,0B;;EACb,qBAAN,8D;IAGpB,+B;GAHoB,2B;IAQR,mC;;GARQ,E;EASM,qBAAN,8D;IAGpB,gF;GAHoB,E;EVgEpB,4B;QMhEA,0B;QAAA,e;WIKA,2D;;EAQQ,4BAAiB,QAAS,e;WAC1B,yC;G;;WJHA,W;;EAEW,iF;WIGI,kBAAa,UAAA,MAAP,kC;GJHV,E;EIGP,oF;WAEA,qBAAc,CAAA,IAAA,IAAd,wCAAc,Q;GAFd,E;;WAOI,yF;;;;;;eJVJ,S;gBACA,8B;iBAAe,K;MACf,iB;;;;;;;;SIaJ,oC;;;;;EAMI,4B;IAAA,oB;IHlJZ,kD;IAAA,mB;;IAGgB,iB;IAAS,sB;IAHzB,I;IAAA,W;;EAMY,kB;IANZ,Q;IAAA,oB;IAAA,oB;IAAA,kD;;ML85BI,W;QAj5B8B,oF;IAAA,YAAA,IAAuB,uB;IADvB,kB;IAEA,4B;IAGrB,gB;WAWT,I;;EA4BA,2CAAkC,oB;QAWlC,UAAA,8BAAoC,EAApC,M;;;;MJyE6C,SAAM,Q;MIlHvC,I;;;;;MAEZ,qE;;;G;EAIa,4BAAL,uB;;;;;IAMoB,8BAAc,CAAd,KAAc,EAAd,IAAc,C;;;;;MAGN,4BAAV,8D;;WAAA,I;;;QAKV,kC;IAAA,sB;;MAKO,2B;;;;EAWX,oDAAsB,e;;;;;UAGtB,2B;MAAA,I;;;;;;G;;;MAUiB,yE;IAAA,sB;;EAOd,4B;QACX,I;QAEA,MAAI,IAAS,yCAAb,4D;QACI,mB;QACA,wB;QACA,W;MACK,uBAAW,I;;;;;WAKpB,E;;EAEI,qD;;QAEJ,+G;IACJ,uB;;QAGI,UAAW,C;MACX,uBAAY,I;;;MAEQ,kB;;WAEpB,E;G;;IAGJ,Q;;QAQwB,oB;QALpB,QAAA,EAAW,c;QACX,UAAW,C;MACX,uBAAY,I;;;MACQ,kB;;WAIpB,E;;EAEA,oCAAK,e;QACL,kC;QAEA,a;;;;WAI8B,I;G;EAG1B,4BAAS,qC;QACT,I;QACA,aAAA,wBAAsB,cAAtB,4D;QACA,iB;;;MAEK,uBAAL,I;;;;;IAKR,S;G;EAGoB,4BAAL,S;QACX,gBAAiB,kB;QAEjB,aAAI,GAAa,C;MAA4B,kB;MAC7C,OAAK,oB;;WAGD,6B;;;QAEA,I;;QAGJ,KAAO,WAAP,E;IACJ,4B;;MAGI,uBAAoB,I;;;MAEhB,0B;;;;EAKR,kB;;;;IAMI,mB;aACI,gCAAqB,iB;K;;;;;;;;;aAQzB,4C;;;EAEJ,kB;;MAyda,oF;MAAT,U;;QAGA,YAAe,CAAf,C;MACA,IAAI,UAAS,uBAAT,mD;MACA,Y;;;UAEA,iG;;;IA9dyB,kE;;;QAud7B,KAAA,IAAS,sBA+K8C,cAAqB,MAArB,C;QA9KvD,OAAe,M;MAEf,uBAAe,4CAAf,8C;;EAEI,4BAAW,gB;;;EAEX,4BAAgB,qB;;MA7dS,gF;;;QAsdpB,I;QAAT,OAAS,S;QACT,SAtdyC,IAwdzC,kBAxdyC,C;QAydzC,MAAI,M;UACA,6C;;;MAEA,gB;;;MA5d0B,OA+dvB,I;;;QA5dP,c;MACA,KAAI,Q;UACA,4B;UACA,QAAO,MAAK,UAAZ,I;;QAGJ,kBAAO,iC;;;QA4cE,uB;;;;;QAKL,I;;qBAEA,kB;;MAhdyB,iD;;;MAG7B,gB;;;MAEI,W;;;QAIJ,MAAO,Q;;;MAgcE,gC;MAAT,IAAA,KAAS,IAAT,C;QACA,kBA9b0C,iC;;MAic1C,IAAI,UAAS,CAAb,C;QACI,wBAAW,MAAX,C;;;;;QAlc2B,e;;;;MAaV,oC;MAAE,iB;;;;;;;;;UAEc,4B;UAAE,iBAAU,MAAV,E;;;;UAF/B,2C;UK/NR,mB;YAKE,K;;UL2NM,WKjOR,M;UACA,c;UAKE,O;;;;;QALF,Y;UAKE,gB;;;;;;MLqOF,UAAS,YAAT,CAAS,qCAAT,4D;;;EAEJ,kB;;QAO4B,qB;;;MAQxB,OAAI,0BAAJ,qB;;IACJ,mC;;IAWiB,sB;WAFb,I;;EAEa,4B;QACY,e;;;;MAErB,oC;;QAHJ,qB;;MAPQ,kB;;;UAiBA,SAAJ,OAAI,yE;UACA,c;;UAEA,WAAJ,MAAI,W;UACA,yB;;;;;UAdK,mB;YAFb,K;;UAEiB,iB;UACQ,c;UAAgB,O;;QAAA,a;;;;;;;;IADzC,c;QAMA,MAAI,a;YACA,IAAM,YAAN,4F;;;;oBAII,c;;UAEJ,IAAI,iB;eACA,E;;;IAGZ,mC;;IAGI,sB;;;ED5GU,4B;QACA,e;;MAAd,gB;;;UC6GQ,Y;;;UAEA,c;;;;UDxGA,WAAU,EAAV,C;YACW,mF;UAAA,4B;cAAgC,oB;;;UAC3C,UAAU,K;UACV,2C;;YACK,K;;;UAET,OAAI,O;UACA,c;;;;;;;;;;;ICwGR,wB;;;;EAKY,kD;;QACJ,OAAO,SAAP,EAAO,EAAP,C;;QAEO,OAAwB,E;MAAnC,OAAA,IAA6C,sBFjHtC,cAAJ,MAAI,C;;QEmHP,+B;IACJ,sE;;WAGI,I;;EDpIU,4B;QADd,e;;;MACA,cAAc,I;;;;;oBCuIc,I;;;cDlIhB,qF;;YAEJ,UAAU,YAAV,yD;UACW,4B;UAAA,yB;YAAgC,K;;UAA3C,e;UACA,2C;UACA,IAAA,MAAU,QAAV,C;;;;;UAGJ,OAAI,O;;QACA,a;;;;;;;;IC+HM,c;;;;;EAMN,4B;QACA,YAAI,c;QAAkB,qB;UACtB,qBAAO,U;;MAEA,OAAA,IAAwB,sBAAP,CAAO,GAAP,iB;;QAC5B,IAAA,mBAAU,CAAV,MAAU,C;QACV,QAAO,SAAP,iD;IACJ,I;;;;QD1Jc,e;;UAA2B,I,EAAA,M;;MAAzC,oC;;;;UCgKQ,UAAI,I;;;UD5JJ,IAAI,KC8JJ,6BD9JI,mD;cACA,E;;UAEJ,WAAU,MAAV,W;UACW,yB;YAAA,K;;;UAAX,2C;UACA,IAAA,MAAU,QAAV,C;YACA,K;;UACK,iB;;;;QAEL,a;;;;;;;;ICwJA,c;QACA,MAAM,a;;;;EAKM,kD;QAChB,YAAI,c;QACA,MAAI,e;UAAkB,qB;QACtB,OAAO,E;;;QAEX,IAAA,MAAiB,aFnKV,Q;QEoKP,QAAA,0BAAuB,CAAvB,CAAuB,KAAvB,yB;IACA,sB;IACJ,W;;;;aDnLc,uD;;;EAAA,4B;UAA2B,4B;;MAAzC,U;;;;UC0LQ,I,EAAA,M;UDtLA,UCuLA,I;aDtLI,oB;;;;UAGO,c;;;UAAX,SAAA,OAAW,sBAAX,4B;UACA,W;YACA,QAAU,oB;;YACL,K;;;UAET,MAAI,GAAJ,mBAAI,e;UACA,mB;;;;;UCgLA,c;;QACM,a;;;;;;;;IAOF,c;QAAkB,QAAO,W;YAC7B,IAAO,YAAP,CAAO,qCAAP,mD;;;EAEa,4BF5LV,sBE4LU,0B;QACjB,0B;QACA,MAAO,e;;;MAIP,8C;;QD/MU,+B;QADd,IAAA,WAAc,QAAd,oB;QACc,kCAAqB,CAArB,I;QAAA,sE;IAA2B,iC;;G;;;eCiNjC,S;QACA,kB;aAAc,YAAM,E;;QD9MpB,OAAA,ICgNA,wBDhNA,K;;;;EAIW,2CAAoB,qB;WAApB,oB;G;;YAAX,W;WACA,WAAU,Q;;;IAEL,iB;;;;;;;;;QC4MT,I,EAAI,M;QACA,OAAM,GAAA,a;;;;;MAKV,iB;MACA,KAAI,SAAJ,EAAI,QAAJ,M;QACI,IAAI,uE;;;;;EFlND,mDEqNU,eAA4B,8B;UAC7C,sC;G;EAEJ,yC,6CAG0C,Y;EAAE,0E;;;;WKzZxC,ILyZQ,iBAAc,SKzZ1B,GLyZ0B,C;G;;;MAEtB,O;;MD1OU,gB;QADd,mB;UACc,sD;MAAA,qB;aAA2B,Q;;WAAzC,wB;;;IAImB,2BCwOK,eDxOL,ECwOK,eDxOL,C;;ECyOC,6C;QDzOZ,QAAI,KC0OJ,C;;;YDvOA,U;QACW,wC;aAAA,E;;;aAAX,oB;oBACA,kB;;;;;;;EAKA,gD;;;;;QCmOJ,OAAI,C;;;;;QAMJ,aACA,CADA,C;QAEI,OAAI,U;;MAGG,UAAwB,M;MAAxB,cAAqD,I;MF5K7D,OAAA,oBAnEI,OAAJ,CAAI,C;ME+OP,IAAA,IAA0E,IAAzD,IAAjB,C;QACA,qB;;;;;UASI,oB;UACA,IAAO,Y;;;YAKJ,U;;;cAKA,QAAO,MAAP,iB;;;gBAKwB,+B;gBAA6C,mB;;;;;kBAOtD,kB;;;;gBAGd,MAAK,mB;;;;;gBAKD,uB;;;;;UAIK,c;UACiB,2B;UAAtB,O;YACI,YAAK,O;;;;;;;;;;;;;;;YAjBjB,gB;;UAEJ,iB;UA2BO,c;;;;;;QAOmB,IAAW,OAAX,C;UAAc,gB;;;;IAEpC,c;QACA,IAAI,E;aACJ,MAAS,yE;;QAEb,MAAO,Q;;;;EAQX,kB;;QAKa,mB;QAAA,U;QAAc,a;WAAA,MAAW,M;MAClC,IAAI,YAAA,OAAa,c;UAAsB,S;QACvC,QAAA,SAAgB,W;QAChB,IAAI,oB;QAA4C,WAAO,gB;QLhfnC,yBAAxB,cKkf6C,ILlf7C,C;QKmfQ,Q;QADJ,MGhcG,GAAA,MRlDsC,W;;;;;;;QKggBrC,K;;MACA,c;;WAAyB,M;;EAAc,iE;cACvC,Y;;EAGJ,4B;UACA,6B;;ED1WU,4B;UADd,sH;;EACc,4B;UAA2B,uF;;EAA3B,4B;;;UC6WU,I,EAAA,M;;aS7hBN,oB;UAAA,Y;;;oBAEV,I;iBAAA,C;;;uBT4hBI,qB;;;;kBAGI,gB;kBAHJ,Y;;;gBS5hBR,iB;gBT2hBa,IS1hBT,S;gBACA,oBAAO,C;gBAAP,wB;;;oBAIR,oB;;;oBTqhBQ,mB;;sBAAA,e;;;sBAWI,kB;sBAXJ,M;;;oBAae,qB;sBAbf,M;;sBDzWI,sB;;;;oBAGM,c;oBACC,S;oBAAA,4B;;;;;;;;;;;;oBAMX,IAAA,SAAiB,GAAjB,MAAiB,cAAjB,C;;;;;;;oBCmXgB,yBAAS,G;;;sBAEX,0B;;;;;;;;;;;;0BAYmB,M;0BAAM,iB;0BF3Y/B,sB;;;;wBE8YM,kB;;;;wBAEF,IAAR,iB;;;;;;;;;;;;0BAUW,qB;;;;;;;4BAKuD,iBAC1E,O;;;;;;;;;;sBDtYU,S;;;;gBAAA,iB;;;;;gBAKN,YAAqB,I;;;gBAGjB,Y;;;gBAEW,YAAM,I;;cCsYH,mB;;;cSpf1B,6B;;;;YAIA,c;;UAGQ,e;cACI,UAAI,C;qBAAgB,mBAAmB,e;mBAClC,QAAW,IAAA,oD;YAAX,+B;YT4eL,yC;;;;;sBAEQ,I;YACJ,e;;;US/eJ,c;oBT2eO,I;;QSzeH,iB;;;;;;;;;;MAUI,yCAAkB,GAAlB,W;;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,GAAA,cAAO,U;;kBE/C/B,qB;;;;0BACF,2H;;;;;;;cF2CE,mB;cAOM,iBAAa,Q;cACZ,Q;;cAGJ,U;;;cAKX,iB;cACI,MAA4B,wC;cAC5B,IAAA,MAAiC,QAAjC,C;;;;;;;;;;;cAFJ,kC;;;;QAAA,c;;;;;UAK+B,6B;;;;QACiB,S;;;;;;;;;;;IADjB,qD;;;QAA/B,2B;;;;;;MAAA,mF;MAA+B,oD;;;;MAA/B,sD;;;;;;;;;;;;;;;;;;;;;;;;;MAUI,gC;;IAEA,oBAAS,E;IE3EsD,uC;;;;IrBsI/D,oB;QACc,2B;QAAA,4B;eAAqC,oB;;IAAnD,gBAAA,IAAc,SAAd,oG;;;;;;;;ImBvDoC,sB;QpB6BxB,iCoB7Ba,I;;;;;;;;;;;;;eEjFvB,kC;;;;;;;;IFoF0B,iCAAa,IAAb,C;;;;;;EEtGpB,sD;;YAHJ,4H;;;;;;;;;oBFuGI,I;;;mBAOA,mCAAkB,MAAlB,uC;cnByDQ,M;;;;;;;cAKJ,UAAQ,I;;;cAMR,a;UAAc,c;UACd,c;;QACI,a;;;;;;;;IAMR,c;;;;;iBAMA,M;;;UAGJ,UAAI,I;aACA,2BAAiB,CAAjB,C;;;;;;;UArEM,yF;UADd,W;YACc,4B;UAAA,yB;YAA2B,K;;UAAzC,e;;;;;cmBVY,a;UACW,c;UAAX,c;;QAEI,a;;;;UACgB,uBAAa,OAAb,C;;;;;;;QExHxB,kC;;;;;;aAoBN,6B;;;;oBAFF,I;;;;cFoGY,M;YAIG,WAAA,QAAO,S;cACV,EAAA,MAAO,WAAP,C;;;UnBQA,e;;cAEJ,c;;;;;UACA,c;;QACA,a;;;;;;;;IAIJ,c;;;;;;;QmBVG,QAAA,yBAAe,CAAf,CAAe,CAAf,8B;;;;EE5GG,0DAAwB,kC;;;aAHlC,E;;QFkHA,QAAU,yBAAV,iC;IACJ,I;;G;;QGy5BQ,YAAW,c;QC1kCmB,M;MAF9B,S;QACA,IAAA,WAAiB,QAAjB,Q;QACA,kE;IACI,sBAAgB,mB;WAChB,I;;iDCu7BmF,U,wDDl7BvF,2B;;IDqkCiB,sC;IzBt/BX,sCAAsB,IAAtB,EAA8B,SAA9B,O;;;EADN,0ByBw/B8B,oB;WzBv/B9B,I;G;EyBw/BA,sC;;;;;;;;;W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qC;EAAqB,wCAA0B,Y;;mEhCYvD,+B;EgCTU,4C;;EAGJ,wC;EACV,Y;;EAIY,yCAA0B,+B;EhCE9B,sC;;EgCEI,0D;ECpC2E,0C;;;;;;ETKzC,4C;EAAW,yC;EAAyB,Y;EA+CnE,2B;;EAsBD,4D;;EADR,uG;;EAHN,8D;EAIQ,8BAAM,Y;;EAHV,gC;;EU3DgD,uCAAsB,uB;;ECMtE,kDAA2B,GAA3B,yB;;EAM6C,uC;;EAAiB,2C;EAAkB,sC;EAChF,qC;EAGO,4C;E7BisBQ,sC;qBACE,yC;;EAGL,uB;E6BnsBgC,+B;EAEpC,qC;EACA,qC;E7BgsBJ,qC;;E6B5rBR,Y;oDChCI,6B;EACJ,gB;;EAEA,gD;E9BHA,kD;EAAA,mC;E8BIe,uC;E9BAX,+BAAc,iB;;EAEJ,+B;EACN,yC;;EACF,wC;EACU,uC;;;sD8BLZ,+B;;;;EAGJ,iG;EAAA,wC;EAEW,8C;;;qDCXX,8B;E/BEA,4B;;;E+BGI,qCAAK,GAAL,gB;EACJ,kE;;;EAG4D,0C;MACxD,aAAA,UCsHiH,2B;EDrHjH,mC;;;;;EETwD,kB;;EAEE,kB;EAAA,c;;EACD,e;;;EAGjD,0B;EAAkB,0B;EACZ,2B;EAGK,uB;MACf,qB;EAEO,uB;EACX,W;;;EAGI,wB;SAEI,C;;"}