{"version":3,"file":"mirror-ktor.js","sources":["../../../../../src/commonMain/kotlin/com/lightningkite/mirror/request/Request.returnType.kt","../../../../../src/commonMain/kotlin/com/lightningkite/mirror/ktor/HttpClientRequestHandler.kt","../../../../../../../../../../../dummy.kt","../../../../../src/commonMain/kotlin/com/lightningkite/mirror/ktor/Serialization.kt"],"sourcesContent":["package com.lightningkite.mirror.request\r\n\r\nimport com.lightningkite.mirror.info.MirrorClassMirror\r\nimport com.lightningkite.mirror.info.MirrorRegistry\r\nimport com.lightningkite.mirror.info.MirrorType\r\nimport kotlin.reflect.KClass\r\n\r\n@Suppress(\"UNCHECKED_CAST\")\r\nval KClass<out Request<*>>.returnType: MirrorType<*>\r\n    get() = MirrorRegistry[this]!!.implements\r\n            .find { it.name == \"com.lightningkite.mirror.request.Request\" }\r\n            .let { if (it == null) throw IllegalArgumentException(\"This type (${this}) does not extend Request\") else it }\r\n            .typeParameters.first()\r\n\r\ninline val <reified R : Request<*>> R.returnType: MirrorType<*>\r\n    get() = this::class.returnType\r\n\r\n","package com.lightningkite.mirror.ktor\r\n\r\nimport com.lightningkite.mirror.info.MirrorRegistry\r\nimport com.lightningkite.mirror.request.*\r\nimport io.ktor.client.HttpClient\r\nimport io.ktor.client.call.call\r\nimport io.ktor.client.request.accept\r\nimport io.ktor.http.ContentType\r\nimport io.ktor.http.HttpMethod\r\nimport io.ktor.http.contentType\r\nimport kotlinx.serialization.SerialFormat\r\n\r\nclass HttpClientRequestHandler(\r\n        val client: HttpClient,\r\n        val url: String,\r\n        val serializer: SerialFormat,\r\n        val contentType: ContentType = serializer.contentTypeOrFail()\r\n) : Request.Handler {\r\n    override suspend fun <T> invoke(request: Request<T>): T {\r\n        val result = client.call(url) {\r\n            method = HttpMethod.Post\r\n            @Suppress(\"UNCHECKED_CAST\")\r\n            body = serializer.ktorContent(\r\n                    serializationStrategy = RequestMirror.minimal as RequestMirror<T>,\r\n                    value = request,\r\n                    contentType = contentType\r\n            )\r\n            accept(contentType)\r\n        }\r\n        @Suppress(\"UNCHECKED_CAST\") val raw = serializer.ktorResponse(\r\n                deserializer = RemoteResultMirror(request.returnType) as RemoteResultMirror<T>,\r\n                response = result.response\r\n        )\r\n        return raw.result\r\n    }\r\n}",null,"package com.lightningkite.mirror.ktor\r\n\r\nimport io.ktor.client.response.HttpResponse\r\nimport io.ktor.client.response.readBytes\r\nimport io.ktor.client.response.readText\r\nimport io.ktor.http.ContentType\r\nimport io.ktor.http.content.ByteArrayContent\r\nimport io.ktor.http.content.OutgoingContent\r\nimport io.ktor.http.content.TextContent\r\nimport kotlinx.serialization.*\r\nimport kotlinx.serialization.cbor.Cbor\r\nimport kotlinx.serialization.json.Json\r\nimport kotlinx.serialization.protobuf.ProtoBuf\r\n\r\nfun SerialFormat.contentType(): ContentType? = when (this) {\r\n    is Json -> ContentType.Application.Json\r\n    is Cbor -> ContentType(\"application\", \"cbor\")\r\n    is ProtoBuf -> ContentType(\"application\", \"protobuf\")\r\n    else -> null\r\n}\r\n\r\nfun SerialFormat.contentTypeOrFail(): ContentType = contentType()\r\n        ?: throw IllegalArgumentException(\"Content type for serializer $this is not known.\")\r\n\r\nfun <V> StringFormat.ktorContent(\r\n        serializationStrategy: SerializationStrategy<V>,\r\n        value: V,\r\n        contentType: ContentType = this.contentTypeOrFail()\r\n                ?: throw UnsupportedOperationException(\"No content type known for format ${this}\")\r\n): TextContent {\r\n    return TextContent(\r\n            text = stringify(serializationStrategy, value),\r\n            contentType = contentType\r\n    )\r\n}\r\n\r\nfun <V> BinaryFormat.ktorContent(\r\n        serializationStrategy: SerializationStrategy<V>,\r\n        value: V,\r\n        contentType: ContentType = this.contentTypeOrFail()\r\n): ByteArrayContent {\r\n    return ByteArrayContent(\r\n            bytes = dump(serializationStrategy, value),\r\n            contentType = contentType\r\n    )\r\n}\r\n\r\nfun <V> SerialFormat.ktorContent(\r\n        serializationStrategy: SerializationStrategy<V>,\r\n        value: V,\r\n        contentType: ContentType = this.contentTypeOrFail()\r\n): OutgoingContent = when (this) {\r\n    is StringFormat -> this.ktorContent(serializationStrategy, value, contentType)\r\n    is BinaryFormat -> this.ktorContent(serializationStrategy, value, contentType)\r\n    else -> throw IllegalArgumentException(\"Unknown serial format type $this\")\r\n}\r\n\r\nsuspend fun <V> StringFormat.ktorResponse(deserializer: DeserializationStrategy<V>, response: HttpResponse): V {\r\n    return parse(deserializer, response.readText())\r\n}\r\n\r\nsuspend fun <V> BinaryFormat.ktorResponse(deserializer: DeserializationStrategy<V>, response: HttpResponse): V {\r\n    return load(deserializer, response.readBytes())\r\n}\r\n\r\nsuspend fun <V> SerialFormat.ktorResponse(\r\n        deserializer: DeserializationStrategy<V>,\r\n        response: HttpResponse\r\n): V = when (this) {\r\n    is StringFormat -> this.ktorResponse(deserializer = deserializer, response = response)\r\n    is BinaryFormat -> this.ktorResponse(deserializer = deserializer, response = response)\r\n    else -> throw IllegalArgumentException(\"Unknown serial format type $this\")\r\n}"],"names":[],"mappings":"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"}